<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Docker Notes | Xenojoshua</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://xenojoshua.com/js/jquery.min.js"></script>
  <script src="https://xenojoshua.com/js/bootstrap.min.js"></script>
  <script src="https://xenojoshua.com/js/header.js"></script>
  <script src="https://xenojoshua.com/js/toc.js"></script>
  <link href="https://xenojoshua.com//2019/01/docker-note/" rel="canonical" />
  <link href="https://xenojoshua.com/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://xenojoshua.com/css/theme.css" rel="stylesheet">
  <link href="https://xenojoshua.com/css/syntax.css" rel="stylesheet">
  <link href="https://xenojoshua.com/css/font-awesome/css/font-awesome.min.css" rel="stylesheet">
  <link href="https://xenojoshua.com/favicon.ico?" type="image/x-icon" rel="shortcut icon">
  <style>
    /* Enhance table style */
    table {
      border: 2px solid #4F7849;
      background-color: #EEEEEE;
      width: 100%;
      text-align: center;
      border-collapse: collapse;
    }
    table td, table.comicGreen th {
      border: 1px solid #4F7849;
      padding: 3px 5px;
    }
    table tbody td {
      font-size: 14px;
      color: #4F7849;
    }
    table tr:nth-child(even) {
      background: #CEE0CC;
    }
    table thead {
      background: #4F7849;
      border-bottom: 1px solid #444444;
    }
    table thead th {
      font-size: 16px;
      font-weight: bold;
      color: #FFFFFF;
      text-align: center;
      border-left: 2px solid #D0E4F5;
      padding: 3px 5px;
    }
    table thead th:first-child {
      border-left: none;
    }
    table tfoot td {
      font-size: 21px;
    }

    /* Enhance pre style */
    pre {
      color: #FFFFFF;
      background-color: #000000;
      border-color: #000000;
    }

    /* Image bg color white while dark background */
    img {
      background-color: #FFFFFF;
    }

    /* Keep gist style clean */
    .gist table tr:nth-child(even) {
      background: #FFFFFF;
    }
    .gist td, th {
      border: none;
    }
  </style>
</head>

<body>

  
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-11349149-4']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


  

 <script type="text/javascript">
   var host = "xenojoshua.com";
   if ((host == window.location.host) && (window.location.protocol != "https:"))
     window.location.protocol = "https";
 </script>
 <script type="text/javascript">
  WebFontConfig = {
    google: {
      families: ['Ubuntu::latin']
    }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="https://xenojoshua.com/">Xenojoshua</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="https://xenojoshua.com/">/home</a></li>
          <li><a href="https://xenojoshua.com/archive/">/archive</a></li>
          <li><a href="https://xenojoshua.com/categories/">/categories</a></li>
          <li><a href="https://xenojoshua.com/tags/">/tags</a></li>
          <li><a href="https://xenojoshua.com/feed.xml" target="_blank">/rss</a></li>
          <li><a href="https://xenojoshua.com/about/">/about</a></li>
        </ul>
      </div>
    </div>
  </nav>


<div class="wrapper">
  <div class="content">
    <div class="container container-center">
      <div class="row">
        <div class="col-md-8">
          <div class="article">
            <div class="well">
              <h1><a href="https://xenojoshua.com/2019/01/docker-note/">Docker Notes</a></h1>
              <div class="post-meta">
                <div class="post-time">
                  <i class="fa fa-calendar"></i>
                  <time>17 Jan 2019</time>
                </div>
                <ul>
                  
                    <li><a href="https://xenojoshua.com/tag/Docker">Docker</a></li>
                  
                    <li><a href="https://xenojoshua.com/tag/Keynote">Keynote</a></li>
                  
                </ul>
              </div>
              <div class="post-content">
                <h4>Table of Contents</h4>
<ul id="markdown-toc">
  <li><a href="#1-前言" id="markdown-toc-1-前言">1. 前言</a></li>
  <li><a href="#2-安装" id="markdown-toc-2-安装">2. 安装</a></li>
  <li><a href="#3-镜像仓库" id="markdown-toc-3-镜像仓库">3. 镜像仓库</a>    <ul>
      <li><a href="#31-创建镜像仓库" id="markdown-toc-31-创建镜像仓库">3.1 创建镜像仓库</a></li>
      <li><a href="#32-login" id="markdown-toc-32-login">3.2 login</a></li>
      <li><a href="#33-push--pull" id="markdown-toc-33-push--pull">3.3 push &amp; pull</a></li>
      <li><a href="#34-list-tags" id="markdown-toc-34-list-tags">3.4 list tags</a></li>
    </ul>
  </li>
  <li><a href="#4-日常使用" id="markdown-toc-4-日常使用">4. 日常使用</a>    <ul>
      <li><a href="#41-docker-images" id="markdown-toc-41-docker-images">4.1 docker images</a></li>
      <li><a href="#42-docker-rmi" id="markdown-toc-42-docker-rmi">4.2 docker rmi</a></li>
      <li><a href="#43-docker-ps--a" id="markdown-toc-43-docker-ps--a">4.3 docker ps -a</a></li>
      <li><a href="#44-docker-rm" id="markdown-toc-44-docker-rm">4.4 docker rm</a></li>
      <li><a href="#ID_DOCKER_BUILD" id="markdown-toc-ID_DOCKER_BUILD">4.5 docker build</a>        <ul>
          <li><a href="#451-镜像命名及tag" id="markdown-toc-451-镜像命名及tag">4.5.1 镜像命名及tag</a></li>
          <li><a href="#452-指定dockerfile" id="markdown-toc-452-指定dockerfile">4.5.2 指定Dockerfile</a></li>
          <li><a href="#453-指定全局变量" id="markdown-toc-453-指定全局变量">4.5.3 指定全局变量</a></li>
          <li><a href="#454-指定ulimit" id="markdown-toc-454-指定ulimit">4.5.4 指定ulimit</a></li>
          <li><a href="#455-指定父级cgroup" id="markdown-toc-455-指定父级cgroup">4.5.5 指定父级cgroup</a></li>
          <li><a href="#456-添加etchosts" id="markdown-toc-456-添加etchosts">4.5.6 添加/etc/hosts</a></li>
          <li><a href="#457-构建目标环境" id="markdown-toc-457-构建目标环境">4.5.7 构建目标环境</a></li>
          <li><a href="#458-其他" id="markdown-toc-458-其他">4.5.8 其他</a>            <ul>
              <li><a href="#资源限制相关会在后面的章节深入" id="markdown-toc-资源限制相关会在后面的章节深入">资源限制相关（会在后面的章节深入）</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#46-docker-run" id="markdown-toc-46-docker-run">4.6 docker run</a>        <ul>
          <li><a href="#461-后台进程" id="markdown-toc-461-后台进程">4.6.1 后台进程</a></li>
          <li><a href="#462-指定名称" id="markdown-toc-462-指定名称">4.6.2 指定名称</a></li>
          <li><a href="#463-网络设置" id="markdown-toc-463-网络设置">4.6.3 网络设置</a></li>
          <li><a href="#464-添加etchosts" id="markdown-toc-464-添加etchosts">4.6.4 添加/etc/hosts</a></li>
          <li><a href="#465-重启策略" id="markdown-toc-465-重启策略">4.6.5 重启策略</a></li>
          <li><a href="#466-退出代码-exit-status" id="markdown-toc-466-退出代码-exit-status">4.6.6 退出代码 Exit Status</a></li>
          <li><a href="#467-退出清理" id="markdown-toc-467-退出清理">4.6.7 退出清理</a></li>
          <li><a href="#468-安全选项" id="markdown-toc-468-安全选项">4.6.8 安全选项</a></li>
          <li><a href="#469-权限与linux-capabilities" id="markdown-toc-469-权限与linux-capabilities">4.6.9 权限与Linux Capabilities</a></li>
          <li><a href="#4610-日志输出" id="markdown-toc-4610-日志输出">4.6.10 日志输出</a></li>
          <li><a href="#4611-覆盖dockerfile设置" id="markdown-toc-4611-覆盖dockerfile设置">4.6.11 覆盖Dockerfile设置</a></li>
          <li><a href="#4612-其他" id="markdown-toc-4612-其他">4.6.12 其他</a>            <ul>
              <li><a href="#命令测试" id="markdown-toc-命令测试">命令测试</a></li>
              <li><a href="#隔离与共享" id="markdown-toc-隔离与共享">隔离与共享</a></li>
              <li><a href="#资源限制相关会在后面的章节深入-1" id="markdown-toc-资源限制相关会在后面的章节深入-1">资源限制相关（会在后面的章节深入）</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#47-docker-attach" id="markdown-toc-47-docker-attach">4.7 docker attach</a>        <ul>
          <li><a href="#471-attach" id="markdown-toc-471-attach">4.7.1 attach</a></li>
          <li><a href="#472-detach" id="markdown-toc-472-detach">4.7.2 detach</a></li>
        </ul>
      </li>
      <li><a href="#48-docker-exec" id="markdown-toc-48-docker-exec">4.8 docker exec</a></li>
      <li><a href="#49-tips" id="markdown-toc-49-tips">4.9 tips</a></li>
    </ul>
  </li>
  <li><a href="#ID_DOCKERFILE" id="markdown-toc-ID_DOCKERFILE">5. Dockerfile</a>    <ul>
      <li><a href="#51-dockerfile指令" id="markdown-toc-51-dockerfile指令">5.1 Dockerfile指令</a>        <ul>
          <li><a href="#ID_DOCKERFILE_RUN" id="markdown-toc-ID_DOCKERFILE_RUN">5.1.1 RUN</a></li>
          <li><a href="#512-cmd--entrypoint" id="markdown-toc-512-cmd--entrypoint">5.1.2 CMD &amp; ENTRYPOINT</a></li>
          <li><a href="#513-volume" id="markdown-toc-513-volume">5.1.3 VOLUME</a></li>
          <li><a href="#514-arg" id="markdown-toc-514-arg">5.1.4 ARG</a></li>
          <li><a href="#515-healthcheck" id="markdown-toc-515-healthcheck">5.1.5 HEALTHCHECK</a></li>
          <li><a href="#516-其他指令" id="markdown-toc-516-其他指令">5.1.6 其他指令</a></li>
        </ul>
      </li>
      <li><a href="#52-最佳实践" id="markdown-toc-52-最佳实践">5.2 最佳实践</a>        <ul>
          <li><a href="#521-缩小镜像构建的context" id="markdown-toc-521-缩小镜像构建的context">5.2.1 缩小镜像构建的Context</a></li>
          <li><a href="#522-使用多阶段构建" id="markdown-toc-522-使用多阶段构建">5.2.2 使用多阶段构建</a></li>
          <li><a href="#523-构建的缓存" id="markdown-toc-523-构建的缓存">5.2.3 构建的缓存</a></li>
          <li><a href="#524-镜像层的创建" id="markdown-toc-524-镜像层的创建">5.2.4 镜像层的创建</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#6-image" id="markdown-toc-6-image">6. Image</a></li>
  <li><a href="#7-docker-machine" id="markdown-toc-7-docker-machine">7. Docker Machine</a></li>
  <li><a href="#8-深入" id="markdown-toc-8-深入">8. 深入</a>    <ul>
      <li><a href="#81-网络" id="markdown-toc-81-网络">8.1 网络</a>        <ul>
          <li><a href="#811-bridge" id="markdown-toc-811-bridge">8.1.1 bridge</a></li>
          <li><a href="#812-其他" id="markdown-toc-812-其他">8.1.2 其他</a></li>
          <li><a href="#813-实践经验" id="markdown-toc-813-实践经验">8.1.3 实践经验</a>            <ul>
              <li><a href="#容器ip" id="markdown-toc-容器ip">容器IP</a></li>
              <li><a href="#容器名" id="markdown-toc-容器名">容器名</a></li>
              <li><a href="#expose-vs-publish" id="markdown-toc-expose-vs-publish">expose vs publish</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#ID_PRINCIPLE_STORAGE" id="markdown-toc-ID_PRINCIPLE_STORAGE">8.2 存储</a>        <ul>
          <li><a href="#821-几种类型的mount" id="markdown-toc-821-几种类型的mount">8.2.1 几种类型的mount</a></li>
          <li><a href="#822-日常使用命令" id="markdown-toc-822-日常使用命令">8.2.2 日常使用命令</a></li>
          <li><a href="#823-volumes" id="markdown-toc-823-volumes">8.2.3 Volumes</a></li>
          <li><a href="#824-bind-mounts" id="markdown-toc-824-bind-mounts">8.2.4 Bind mounts</a></li>
          <li><a href="#825-storage-drivers" id="markdown-toc-825-storage-drivers">8.2.5 Storage drivers</a></li>
        </ul>
      </li>
      <li><a href="#ID_PRINCIPLE_RESOURCE" id="markdown-toc-ID_PRINCIPLE_RESOURCE">8.3 资源限制</a>        <ul>
          <li><a href="#831-linux" id="markdown-toc-831-linux">8.3.1 Linux</a></li>
          <li><a href="#832-docker" id="markdown-toc-832-docker">8.3.2 Docker</a></li>
          <li><a href="#833-其他" id="markdown-toc-833-其他">8.3.3 其他</a></li>
        </ul>
      </li>
      <li><a href="#84-监控--metrics" id="markdown-toc-84-监控--metrics">8.4 监控 &amp; Metrics</a></li>
      <li><a href="#85-安全" id="markdown-toc-85-安全">8.5 安全</a></li>
      <li><a href="#87-其他" id="markdown-toc-87-其他">8.7 其他</a></li>
    </ul>
  </li>
  <li><a href="#9-os镜像选择" id="markdown-toc-9-os镜像选择">9. OS镜像选择</a>    <ul>
      <li><a href="#91-alpine" id="markdown-toc-91-alpine">9.1 Alpine</a>        <ul>
          <li><a href="#dns-issue" id="markdown-toc-dns-issue">DNS issue</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#10-实践" id="markdown-toc-10-实践">10. 实践</a>    <ul>
      <li><a href="#列出所有本机镜像" id="markdown-toc-列出所有本机镜像">列出所有本机镜像</a></li>
      <li><a href="#列出本机所有容器" id="markdown-toc-列出本机所有容器">列出本机所有容器</a></li>
      <li><a href="#列出本机磁盘使用情况" id="markdown-toc-列出本机磁盘使用情况">列出本机磁盘使用情况</a></li>
      <li><a href="#本机空间清理" id="markdown-toc-本机空间清理">本机空间清理</a></li>
      <li><a href="#本机镜像清理" id="markdown-toc-本机镜像清理">本机镜像清理</a></li>
      <li><a href="#本机卷清理" id="markdown-toc-本机卷清理">本机卷清理</a></li>
      <li><a href="#日志驱动及容量设置" id="markdown-toc-日志驱动及容量设置">日志驱动及容量设置</a></li>
      <li><a href="#查看网络内容器列表" id="markdown-toc-查看网络内容器列表">查看网络内容器列表</a></li>
      <li><a href="#查看容器所属网络" id="markdown-toc-查看容器所属网络">查看容器所属网络</a></li>
      <li><a href="#查看容器运行状态" id="markdown-toc-查看容器运行状态">查看容器运行状态</a></li>
    </ul>
  </li>
  <li><a href="#11-其他" id="markdown-toc-11-其他">11. 其他</a>    <ul>
      <li><a href="#111-什么是docker-host" id="markdown-toc-111-什么是docker-host">11.1 什么是docker host</a></li>
      <li><a href="#112-comdockerhyperkit-x00-cpu-consumption-mac" id="markdown-toc-112-comdockerhyperkit-x00-cpu-consumption-mac">11.2 com.docker.hyperkit X00% cpu consumption MAC</a></li>
    </ul>
  </li>
  <li><a href="#资料" id="markdown-toc-资料">资料</a>    <ul>
      <li><a href="#docker官方" id="markdown-toc-docker官方">Docker官方</a></li>
      <li><a href="#docker命令" id="markdown-toc-docker命令">Docker命令</a></li>
      <li><a href="#镜像相关" id="markdown-toc-镜像相关">镜像相关</a></li>
      <li><a href="#其他" id="markdown-toc-其他">其他</a></li>
      <li><a href="#ID_APP_DOCKER_INFO" id="markdown-toc-ID_APP_DOCKER_INFO">docker info</a></li>
    </ul>
  </li>
</ul>

<h1 id="1-前言">1. 前言</h1>
<p>云原生概念风生云起，最近算是非常火热，而其最基本的依仗就在于能将任何程序运行在轻量级Cell上的容器Docker。Docker如果仅只是使用的话，是一点都不难的，但作为一个所有应用程序运行其上的基石，对其的细节了解是非常有必要的。</p>

<p>本文会记录从最基本的Docker基础，到日常的工作操作，到比较深入的原理细节，都会有所涉及。</p>

<p>版本信息如下：</p>
<pre><code>$ docker version
Client: Docker Engine - Community
 Version:           18.09.2
 API version:       1.39
 Go version:        go1.10.8
 Git commit:        6247962
 Built:             Sun Feb 10 04:12:39 2019
 OS/Arch:           darwin/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          18.09.2
  API version:      1.39 (minimum version 1.12)
  Go version:       go1.10.6
  Git commit:       6247962
  Built:            Sun Feb 10 04:13:06 2019
  OS/Arch:          linux/amd64
  Experimental:     false
</code></pre>

<p>此外，<a href="#ID_APP_DOCKER_INFO">docker info</a>比较长，就不贴这里了，放在下面的资料部分。简单看了下应该是不带敏感信息的，这部分应该是做了剔除的。</p>

<h1 id="2-安装">2. 安装</h1>
<p>MAC下的安装比较简单，直接下载Docker官方的桌面版本即可：<a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank">Docker Desktop for Mac</a>。文档在：<a href="https://docs.docker.com/docker-for-mac/" target="_blank">Get started with Docker Desktop for Mac</a>。</p>

<p>此外，为了能使用（下载）一些官方（软件公司）发布镜像文件，你需要注册一个docker hub账号（其实也就是docker官方账号）：<a href="https://hub.docker.com" target="_blank">docker hub</a>。</p>

<h1 id="3-镜像仓库">3. 镜像仓库</h1>
<p>Docker的核心功能点之一就是能将部署这个事情代码化。本来运维的工作中充斥着各种不确定性，版本不兼容、软件包不同、Linux内核不同导致的安装问题，等等。而Docker可以使用Dockerfile将一个镜像的制作（以代码形式）固定下来，保证只要是一份Dockerfile，制作出来的镜像是完全一致的。</p>

<p>此外，只要保证Docker的版本一致，docker镜像的运行状态及结果是可预期的。这就保证了一个软件的研发流程中，只要镜像被制作完成了，后续就可以使用这个镜像文件进行分发了，不再需要每个部署环境都从Dockerfile从头开始制作一份本地的镜像。</p>

<p>而分发这个过程就需要镜像仓库的介入：本地制作镜像 =&gt; 上传镜像到仓库 =&gt; 部署服务器拉取镜像 =&gt; 部署服务器本地运行镜像。</p>

<p>Docker官方有一个开放的<a href="https://hub.docker.com" target="_blank">镜像仓库</a>，一般知名的第三方软件提供者都会将自己软件的镜像文件发布到这个开放的仓库中，方便第三方使用者下载。当然，私有仓库对于大部分软件公司来说都是必须的。</p>

<h2 id="31-创建镜像仓库">3.1 创建镜像仓库</h2>
<p>制作一个私有的镜像仓库非常简单，直接使用docker命令即可，官方文档在：<a href="https://docs.docker.com/registry/" target="_blank">Docker Registry</a>。</p>

<p>运行：</p>
<pre><code>docker run -d -p 5000:5000 --name registry registry:2
</code></pre>

<p>这样就在<code>localhost:5000</code>运行了一个镜像仓库。</p>

<h2 id="32-login">3.2 login</h2>
<p>从镜像仓库获得镜像以及上传镜像都需要有对应的身份认证。使用：</p>

<pre><code>$ docker login --help

Usage:	docker login [OPTIONS] [SERVER]

Log in to a Docker registry

Options:
  -p, --password string   Password
      --password-stdin    Take the password from stdin
  -u, --username string   Username
</code></pre>

<p>即便是从官方镜像仓库获取镜像也是需要认证的，所以一开始需要注册一个账号。如果使用的是Docker Desktop的话，可以从UI界面上进行登录。</p>

<p>如果登录的是私有仓库，<code>[SERVER]</code>这块需要输入私有仓库地址。</p>

<h2 id="33-push--pull">3.3 push &amp; pull</h2>
<p>如果是从私有仓库上进行对应的拉取和推送镜像，需要在镜像名字之前补完仓库地址：</p>

<pre><code>docker push localhost:5000/imagename:major.minor.patch
docker pull localhost:5000/imagename:major.minor.patch
</code></pre>

<h2 id="34-list-tags">3.4 list tags</h2>
<p>docker的命令行工具没有提供查询一个镜像所有tags的命令（ridiculous），可以使用以下方法来查询：</p>

<pre><code># require tool jq
brew update --verbose
brew install jq --verbose

curl -s https://registry.hub.docker.com/v2/repositories/${repo_name}/tags/?page_size=1024 | jq .
# sample repo_name: elastic/filebeat
</code></pre>

<h1 id="4-日常使用">4. 日常使用</h1>
<h2 id="41-docker-images">4.1 docker images</h2>
<p>显示所有镜像（本地）</p>
<pre><code>$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              18.10               b977ae81df17        2 weeks ago         73.9MB
</code></pre>

<h2 id="42-docker-rmi">4.2 docker rmi</h2>
<p>删除镜像，可以同时删除多个，给的名字可以是镜像名也可以是镜像id</p>
<pre><code>$ docker rmi imagename imageid ...
</code></pre>

<h2 id="43-docker-ps--a">4.3 docker ps -a</h2>
<p>可以显示所有的容器（本地），包括不在运行状态的。<code>-a</code>一般来说是必须的，否则无法将停止状态的镜像也列出来。</p>
<pre><code>$ docker ps -a
</code></pre>

<h2 id="44-docker-rm">4.4 docker rm</h2>
<p>删除容器，可以同时删除多个，给的名字可以是容器名也可以是容器id</p>
<pre><code>$ docker rm containername containerid ...
</code></pre>

<h2 id="ID_DOCKER_BUILD">4.5 docker build</h2>
<p>从一个Dockerfile构建一个镜像，一般都会进入到Dockerfile同一层目录进行构建：<code>docker build [OPTIONS] .</code>，这里的<code>.</code>就是Dockerfile的路径。全选项参数可以通过：<code>docker build --help</code>来获得，这里就不贴了。</p>

<p>细节相当多，有需要的可以看下官方文档：<a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank">docker build</a>。</p>

<p>此外，docker build命令与Dockerfile息息相关，部分优化相关内容描述在Dockerfile内，请去此处查看：<a href="#ID_DOCKERFILE">5. Dockerfile</a>。</p>

<h3 id="451-镜像命名及tag">4.5.1 镜像命名及tag</h3>
<p>通过<code>-t</code>在构建的时候对镜像进行命名，并打上标签。一般来说这是必须的，方便后续进行镜像查找和仓库内巨量镜像的维护。</p>
<pre><code>$ docker build -t imagename:major.minor.patch .
</code></pre>

<h3 id="452-指定dockerfile">4.5.2 指定Dockerfile</h3>
<p>通过<code>-f</code>指定镜像文件路径。</p>
<pre><code>$ docker build -f yourrepo/Dockerfile .
</code></pre>

<h3 id="453-指定全局变量">4.5.3 指定全局变量</h3>
<p>在构建镜像的时候为了对内部的应用程序提供一些配置，常用环境变量的方式进行注入，而在镜像构建的时候，可以使用<code>--build-args XXX=...</code>这样的方式进行操作。</p>
<pre><code>$ docker build --build-arg HTTP_PROXY=http://10.20.30.2:1234 --build-arg FTP_PROXY=http://40.50.60.5:4567 .
</code></pre>

<p>如果是裸用Docker的话，这样的操作还算是比较容易理解的，但一般来说大型分布系统肯定还使用了K8S这样的容器管理系统或者还甚至用了类似于Istio这样的服务编排系统，就不需要在制作镜像的时候这么弄了。</p>

<h3 id="454-指定ulimit">4.5.4 指定ulimit</h3>
<p>通过<code>--ulimit</code>来指定该镜像文件在运行时候的ulimit。</p>

<h3 id="455-指定父级cgroup">4.5.5 指定父级cgroup</h3>
<p>通过<code>--cgroup-parent</code>来指定该镜像文件在运行时候的资源限制群组。关于cgroup这个话题，后面会专门起一个章节来深入。详见：<a href="#ID_PRINCIPLE_RESOURCE">8.3 资源限制</a>。</p>

<h3 id="456-添加etchosts">4.5.6 添加/etc/hosts</h3>
<p>通过<code>--add-host=domain.com:10.180.0.1</code>来向/etc/hosts里添加匹配。</p>

<h3 id="457-构建目标环境">4.5.7 构建目标环境</h3>
<p>通过<code>--target</code>来指定构建的目标环境：</p>

<pre><code>FROM debian AS build-env
...

FROM alpine AS production-env
...
</code></pre>

<pre><code>$ docker build -t mybuildimage --target build-env .
</code></pre>

<h3 id="458-其他">4.5.8 其他</h3>
<ul>
  <li><code>--no-cache</code>：在构建镜像的时候不使用cache，在频繁更新某个镜像时很有用，防止cache污染</li>
  <li><code>--ssh</code>：SSH agent socket or keys to expose to the build (only if BuildKit enabled) (format: default|[=|[,]])</li>
</ul>

<h4 id="资源限制相关会在后面的章节深入">资源限制相关（会在后面的章节深入）</h4>
<ul>
  <li><code>--cpu-period</code>：Limit the CPU CFS (Completely Fair Scheduler) period</li>
  <li><code>--cpu-quota</code>：Limit the CPU CFS (Completely Fair Scheduler) quota</li>
  <li><code>--cpu-shares</code>：CPU shares (relative weight)</li>
  <li><code>--cpuset-cpus</code>：CPUs in which to allow execution (0-3, 0,1)</li>
  <li><code>--cpuset-mems</code>：MEMs in which to allow execution (0-3, 0,1)</li>
  <li><code>--memory</code>：Memory limit</li>
  <li><code>--memory-swap</code>：Swap limit equal to memory plus swap: ‘-1’ to enable unlimited swap</li>
</ul>

<p>详见：<a href="#ID_PRINCIPLE_RESOURCE">8.3 资源限制</a>。</p>

<h2 id="46-docker-run">4.6 docker run</h2>
<p>将镜像运行成容器的命令，虽然是一个很简单的命令，但细节相当多，用起来其实还蛮麻烦的。全选项参数可以通过：<code>docker run --help</code>来获得，这里就不贴了。中文的帖子也有，可以看了参考：<a href="https://www.jianshu.com/p/ea4a00c6c21c" target="_blank">Docker run 命令参数及使用</a></p>

<p>细节相当多，有需要的可以看下官方文档：<a href="https://docs.docker.com/engine/reference/run/" target="_blank">docker run</a>。</p>

<p>命令的基本使用格式：</p>

<pre><code>$ docker run [OPTIONS] IMAGE[:TAG\|@DIGEST] [COMMAND] [ARG...]
</code></pre>

<h3 id="461-后台进程">4.6.1 后台进程</h3>
<p>通过<code>-d</code>来让docker run命令运行起来的容器转为后台常驻进程。</p>

<pre><code>$ docker run -d -p 80:80 my_image service nginx start
</code></pre>

<h3 id="462-指定名称">4.6.2 指定名称</h3>
<p>通过<code>--name</code>来让docker run命名运行起来的容器，后续可以使用这个名字来访问这个启动的容器，不再需要<code>docker ps -a</code>查找这个容器的UUID。在使用同一个镜像启动多个容器的时候特别有用。</p>

<pre><code>$ docker run --name myconname -d ubuntu:18.10
</code></pre>

<h3 id="463-网络设置">4.6.3 网络设置</h3>
<p>网络这块相关的配置内容也非常多，细节的内容建议直接阅读官方的文档：<a href="https://docs.docker.com/engine/reference/run/#network-settings" target="_blank">docker run &gt; Network settings</a>。</p>

<p><code>--network=...</code>用来控制网络模式：</p>

<ul>
  <li><code>none</code>：No networking in the container.</li>
  <li><code>bridge (default)</code>：Connect the container to the bridge via veth interfaces.</li>
  <li><code>host</code>：Use the host’s network stack inside the container.</li>
  <li><code>container:&lt;name\|id&gt;</code>：Use the network stack of another container, specified via its name or id.</li>
  <li><code>NETWORK</code>：Connects the container to a user created network (using docker network create command)</li>
</ul>

<h3 id="464-添加etchosts">4.6.4 添加/etc/hosts</h3>
<p>参数同docker build命令，但很奇怪的是docker官方给出的例子这里倒是没有<code>=</code>：</p>

<pre><code>$ docker run -it --add-host domain.com:10.180.0.1 ubuntu cat /etc/hosts
</code></pre>

<h3 id="465-重启策略">4.6.5 重启策略</h3>
<p>通过<code>--restart</code>可以让docker run启动的容器在退出之后按策略重启。官方文档在：<a href="https://docs.docker.com/engine/reference/run/#restart-policies---restart" target="_blank">docker run &gt; Restart policies (–restart)</a>。</p>

<ul>
  <li><code>no</code>：Do not automatically restart the container when it exits. This is the default.</li>
  <li><code>on-failure[:max-retries]</code>：Restart only if the container exits with a non-zero exit status. Optionally, limit the number of restart retries the Docker daemon attempts.</li>
  <li><code>always</code>：Always restart the container regardless of the exit status. When you specify always, the Docker daemon will try to restart the container indefinitely. The container will also always start on daemon startup, regardless of the current state of the container.</li>
  <li><code>unless-stopped</code>：Always restart the container regardless of the exit status, including on daemon startup, except if the container was put into a stopped state before the Docker daemon was stopped.</li>
</ul>

<p>该选项与<code>--rm</code>是冲突的。</p>

<h3 id="466-退出代码-exit-status">4.6.6 退出代码 Exit Status</h3>
<p>接上面的重试策略，<code>on-failure</code>会检查退出代码。官方文档在：<a href="https://docs.docker.com/engine/reference/run/#exit-status" target="_blank">docker run &gt; Exit Status</a>。</p>

<h3 id="467-退出清理">4.6.7 退出清理</h3>
<p>通过<code>--rm</code>可以让docker run启动的容器在退出之后删除所有的留存信息。如果没有加这个参数的话，在容器退出、停止之后使用<code>docker ps -a</code>可以找到刚才启动的容器。这对于测试来说是很麻烦的，每次停止之后还要使用<code>docker rm</code>命令删除。这时候就可以通过<code>--rm</code>来命令容器退出后自动清理：</p>

<pre><code># not cleanup
$ docker run -i -t ubuntu:18.10 ps afx
$ docker ps -a

# cleanup
$ docker run -i -t --rm ubuntu:18.10 ps afx
$ docker ps -a
</code></pre>

<h3 id="468-安全选项">4.6.8 安全选项</h3>
<p>参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#security-configuration" target="_blank">docker run &gt; Security configuration</a>。</p>

<h3 id="469-权限与linux-capabilities">4.6.9 权限与Linux Capabilities</h3>
<p>参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities" target="_blank">docker run &gt; Runtime privilege and Linux capabilities</a>。后续详见：<a href="#ID_PRINCIPLE_RESOURCE">8.3 资源限制</a>。</p>

<h3 id="4610-日志输出">4.6.10 日志输出</h3>
<p>通过<code>--log-driver</code>容器可以指定和docker daemon不同的日志输出设备。参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#logging-drivers---log-driver" target="_blank">Logging drivers (–log-driver)</a>。</p>

<h3 id="4611-覆盖dockerfile设置">4.6.11 覆盖Dockerfile设置</h3>
<p>主要是以下几项：</p>

<ul>
  <li>CMD (Default Command or Options)</li>
  <li>ENTRYPOINT (Default Command to Execute at Runtime)</li>
  <li>EXPOSE (Incoming Ports)</li>
  <li>ENV (Environment Variables)</li>
  <li>HEALTHCHECK</li>
  <li>VOLUME (Shared Filesystems)</li>
  <li>USER</li>
  <li>WORKDIR</li>
</ul>

<p>细节参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#overriding-dockerfile-image-defaults" target="_blank">Overriding Dockerfile image defaults</a>。</p>

<h3 id="4612-其他">4.6.12 其他</h3>
<h4 id="命令测试">命令测试</h4>
<p>使用如下命令可以启动容器之后执行命令进行测试，并在退出之后自动清理刚才生成的容器。</p>

<pre><code>$ docker run --rm -i -t $image_name:$version $command
</code></pre>

<h4 id="隔离与共享">隔离与共享</h4>

<ul>
  <li>–pid</li>
  <li>–uts</li>
  <li>–ipc</li>
</ul>

<p>容器之间拥有自己的PID命名空间，并相互隔离。通过<code>--pid=...</code>可以让容器之间共享进程。具体的例子可以直接阅读官方的文档：<a href="https://docs.docker.com/engine/reference/run/#pid-settings---pid" target="_blank">PID settings (–pid)</a>。</p>

<p>简单的例子可以尝试（看下输出的内容有什么不同）：</p>
<pre><code># without pid
$ docker run -i -t --rm ubuntu:18.10 ps afx
...

# with pid
$ docker run -i -t --rm --pid=host ubuntu:18.10 ps afx
...
</code></pre>

<p><code>--uts</code>和<code>--ipc</code>也是类似的，可以参考官方文档里的：<a href="https://docs.docker.com/engine/reference/run/#uts-settings---uts" target="_blank">UTS settings (–uts)</a>和<a href="https://docs.docker.com/engine/reference/run/#ipc-settings---ipc" target="_blank">IPC settings (–ipc)</a>。中文资料可以看：<a href="https://www.centos.bz/2017/01/docker-run-uts-ipc/" target="_blank">Docker run参考(5) – UTS(–uts)和IPC (–ipc)设置</a>。</p>

<h4 id="资源限制相关会在后面的章节深入-1">资源限制相关（会在后面的章节深入）</h4>
<p>参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#runtime-constraints-on-resources" target="_blank">docker run &gt; Runtime constraints on resources</a>。后续详见：<a href="#ID_PRINCIPLE_RESOURCE">8.3 资源限制</a>。</p>

<h2 id="47-docker-attach">4.7 docker attach</h2>
<h3 id="471-attach">4.7.1 attach</h3>
<p>将本地的输入输出及错误流附到一个运行中的容器上。简单来说可以理解为：进入到容器的命令行中。</p>

<p>如果需要在一个容器启动之后连上去的话，需要容器在启动（<code>docker run</code>）的时候指定：<code>-i -t</code>参数：</p>

<pre><code>$ docker run -i -t -d --rm ubuntu:18.10
</code></pre>

<p>这样就可以在之后使用<code>docker attach</code>命令附到该容器上并打开命令行了：</p>

<pre><code>$ docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS
80172e3d5574        ubuntu:18.10        "/bin/bash"         38 seconds ago      Up 37 seconds

$ docker attach 80172e3d5574
root@80172e3d5574:/#
</code></pre>

<h3 id="472-detach">4.7.2 detach</h3>
<p>新手常犯的一个错误就是使用<code>exit</code>命令退出附上的shell，结果就是非但退出了shell还把容器本身给stop了。正确的做法是在shell里<code>ctrl+p</code>然后<code>ctrl+q</code>，这里切记是先按p的组合键，然后按q的组合键，而不是同时<code>ctrl+p+q</code>。</p>

<pre><code>$ docker attach f269e680ae14
root@f269e680ae14:/# 
# ctrl+p &amp; ctrl+q
root@f269e680ae14:/# read escape sequence
$ 
</code></pre>

<p>资料：</p>

<ul>
  <li><a href="https://stackoverflow.com/a/19689048" target="_blank">How do you attach and detach from Docker’s process?</a></li>
</ul>

<h2 id="48-docker-exec">4.8 docker exec</h2>
<p>在一个已经处于<code>运行中</code>状态的容器里执行一条命令。</p>

<p>一般来说，如果是有连续工作的话，还是会使用<code>docker attach</code>附上去之后再操作。但如果仅只是一两句命令，或自动化的脚本，就需要使用到<code>docker exec</code>了。这里需要注意，exec只能用在running的容器上，如果没有容器且需要执行命令测试的话，也可以使用<code>docker run</code>命令，直接附带上需要执行的命令即可。</p>

<p>也有有趣的用法：</p>
<pre><code>$ docker exec -it e8c541f9fb33 /bin/bash
</code></pre>
<p>这条语句的效果和<code>docker attach</code>是一致的。</p>

<p>在某些不能以<code>/bin/bash</code>作为命令启动的镜像（默认入口已经在Dockerfile里指定了，这种情况还蛮多的，稍微复杂点的镜像一般都会把入口设置掉)，比如说Elasticsearch、nginx，等等。在这种情况下，如果需要attach到这个运行中的镜像，就必须使用exec了：</p>

<pre><code>$ docker exec -it e8c541f9fb33 /bin/sh
</code></pre>

<p>此外，以Alpine镜像为基础的镜像，默认是<code>没有/bin/bash</code>的，这种时候就需要换成<code>/bin/sh</code>。</p>

<h2 id="49-tips">4.9 tips</h2>
<ul>
  <li>做开发的时候可以把镜像构建多包几层，一层层做成镜像存在本地。后面的build可以直接from前面的，节约docker build失败之后的重新测试时间。否则中间一个步骤出错，很多耗时很长的源码编译工作就要从头来一次，太伤</li>
  <li>node.js docker里的npm安装记得要加上<code>--unsafe-perm</code>，具体可以看：<a href="https://github.com/grpc/grpc-node/issues/604" target="_blank">grpc/grpc-node#604</a></li>
</ul>

<h1 id="ID_DOCKERFILE">5. Dockerfile</h1>
<p>Dockerfile是用来进行镜像构建的文本文件，也是docker能将构建整个过程转化为文本固定下来的关键，可以说是docker能如此风靡的核心功能点也不为过。</p>

<p>官方的文档：</p>

<ul>
  <li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank">Dockerfile reference</a></li>
  <li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank">Best practices for writing Dockerfiles</a></li>
</ul>

<p>下面行文不会过于注重Dockerfile如何编写的语法，因为这东西你看看手册和几个例子也就会了。主要还是关注在几个比较麻烦的概念上。</p>

<p>几点零碎的：</p>

<ul>
  <li>Dockerfile里类似<code>COPY</code>、<code>EXPOSE</code>之类的，都被称为指令（instruction），这个单词可以了解下</li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" target="_blank">.dockerignore file</a></li>
  <li>因为在build命令执行之前，当前指定PATH的context会被发送给docker daemon，因此文件夹越小执行越效率</li>
</ul>

<h2 id="51-dockerfile指令">5.1 Dockerfile指令</h2>
<h3 id="ID_DOCKERFILE_RUN">5.1.1 RUN</h3>
<p>官方文档：<a href="https://docs.docker.com/engine/reference/builder/#run" target="_blank">RUN</a>。</p>

<p>运行指令，有两种语法模式：</p>

<ul>
  <li>RUN <command /> (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)</li>
  <li>RUN [“executable”, “param1”, “param2”] (exec form)</li>
</ul>

<p>这里需要注意<code>exec模式</code>并不是在shell里运行的：</p>

<blockquote>
  <p>Note: Unlike the shell form, the exec form does not invoke a command shell. This means that normal shell processing does not happen. For example, RUN [ “echo”, “$HOME” ] will not do variable substitution on $HOME. If you want shell processing then either use the shell form or execute a shell directly, for example: RUN [ “sh”, “-c”, “echo $HOME” ]. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker.</p>
</blockquote>

<p>建议是使用<code>exec模式</code>，细节可以看下面一个小节。</p>

<h3 id="512-cmd--entrypoint">5.1.2 CMD &amp; ENTRYPOINT</h3>
<p>官方文档：</p>

<ul>
  <li><a href="https://docs.docker.com/engine/reference/builder/#run" target="_blank">CMD</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank">ENTRYPOINT</a></li>
</ul>

<p>这两个东西可以放在一起说，因为他们做的事情基本上是类似的。两者都是在容器启动之后执行一个命令，CMD提供的是在镜像启动后会默认执行的一个命令，而ENTRYPOINT则是在镜像启动后提供一个程序入口。</p>

<p>区别在于：</p>

<ul>
  <li>CMD：提供的默认执行命令可以在<code>docker run $imagename $command</code>后面接命令进行覆盖，这样操作的话写在Dockerfile CMD里的命令就不会执行了，被替代了；CMD在一个Dockerfile里只能有一个生效，如果编写了多个则只有最后的那个会被执行</li>
  <li>ENTRYPOINT：提供的是镜像的<code>功能入口</code>，不会被<code>docker run $imagename $command</code>中的命令替换掉，除非指定<code>--entrypoint=...</code>进行替换；当然ENTRYPOINT也只允许有一个</li>
</ul>

<p>一般来说通常的做法是：ENTRYPOINT提供容器运行之后程序入口，而CMD则提供供给给程序入口的参数，方便后续在docker run的时候进行替换。这两者以这样的方式进行协同工作。</p>

<p>官方文档里也有这部分内容：<a href="https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact" target="_blank">Understand how CMD and ENTRYPOINT interact</a>。</p>

<ul>
  <li>Dockerfile should specify at least one of <code>CMD</code> or <code>ENTRYPOINT</code> commands.</li>
  <li><code>ENTRYPOINT</code> should be defined when using the container as an executable.</li>
  <li><code>CMD</code> should be used as a way of defining default arguments for an <code>ENTRYPOINT</code> command or for executing an ad-hoc command in a container.</li>
  <li><code>CMD</code> will be overridden when running the container with alternative arguments.</li>
</ul>

<p>这两个指令和<a href="#ID_DOCKERFILE_RUN">5.2 RUN</a>一样，都有多种模式可以选择，一般来说最常使用的是直接写命令的<code>shell模式</code>以及使用JSON格式编写的<code>exec模式</code>。最佳实践是：在所有的情况下都使用<code>exec模式</code>。原因如下：</p>

<ul>
  <li>shell模式的PID 1进程是<code>/bin/sh</code>，后续的信号不能很好传递到真正执行的命令上</li>
  <li>shell模式依赖<code>/bin/sh</code>，但某些微型镜像不一定有</li>
</ul>

<p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#entrypoint" target="_blank">Best practices for writing Dockerfiles &gt; ENTRYPOINT</a>：</p>
<blockquote>
  <p>Configure app as PID 1</p>

  <p>This script uses the exec Bash command so that the final running application becomes the container’s PID 1. This allows the application to receive any Unix signals sent to the container. For more, see the ENTRYPOINT reference.</p>
</blockquote>

<p>CMD指令还多一种模式：<code>CMD ["param1","param2"] (as default parameters to ENTRYPOINT)</code>，这也是刚才提到的参数提供者角色的做法。</p>

<p>e.g</p>

<pre><code>FROM ubuntu:trusty
ENTRYPOINT ["/bin/ping","-c","3"]
CMD ["localhost"]

$ docker run ping
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.025 ms
...

$ docker run ping docker.io
PING docker.io (162.242.195.84) 56(84) bytes of data.
64 bytes from 162.242.195.84: icmp_seq=1 ttl=61 time=76.7 ms
...
</code></pre>

<p>资料：</p>

<ul>
  <li><a href="https://zhuanlan.zhihu.com/p/30555962" target="_blank">Dockerfile: ENTRYPOINT和CMD的区别</a></li>
  <li><a href="https://medium.freecodecamp.org/docker-entrypoint-cmd-dockerfile-best-practices-abc591c30e21" target="_blank">Docker ENTRYPOINT &amp; CMD: Dockerfile best practices</a></li>
</ul>

<p>有时间的话，官方的ENTRYPOINT文档可以通读一下：<a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank">Dockerfile &gt; ENTRYPOINT</a>，里面信息量不小。</p>

<h3 id="513-volume">5.1.3 VOLUME</h3>
<p>官方文档：<a href="https://docs.docker.com/engine/reference/builder/#volume" target="_blank">VOLUME</a>。</p>

<p>卷加载相关在docker里是一个比较麻烦的概念，这里不作展开，只列出文档里提到的注意点：</p>

<ul>
  <li><code>Changing the volume from within the Dockerfile</code>: If any build steps change the data within the volume after it has been declared, those changes will be discarded.</li>
  <li><code>The host directory is declared at container run-time</code>: The host directory (the mountpoint) is, by its nature, host-dependent. This is to preserve image portability, since a given host directory can’t be guaranteed to be available on all hosts. For this reason, you can’t mount a host directory from within the Dockerfile. The <code>VOLUME</code> instruction does not support specifying a <code>host-dir</code> parameter. You must specify the mountpoint when you create or run the container.</li>
</ul>

<p>更多的深入理解可以查看：<a href="#ID_PRINCIPLE_STORAGE">9.2 存储</a>。</p>

<h3 id="514-arg">5.1.4 ARG</h3>
<p>官方文档：<a href="https://docs.docker.com/engine/reference/builder/#arg" target="_blank">ARG</a>。</p>

<p>除了用户定义的变量之外，docker还有一部分预定义的变量，可以通过<code>docker build --build-arg name=value</code>来加入：<a href="https://docs.docker.com/engine/reference/builder/#predefined-args" target="_blank">Predefined ARGs</a>。</p>

<ul>
  <li>HTTP_PROXY</li>
  <li>http_proxy</li>
  <li>HTTPS_PROXY</li>
  <li>https_proxy</li>
  <li>FTP_PROXY</li>
  <li>ftp_proxy</li>
  <li>NO_PROXY</li>
  <li>no_proxy</li>
</ul>

<h3 id="515-healthcheck">5.1.5 HEALTHCHECK</h3>
<p>官方文档：<a href="https://docs.docker.com/engine/reference/builder/#healthcheck" target="_blank">HEALTHCHECK</a>。</p>

<p>类似于客户端服务器保持连接的心跳检查的概念，这个指令是用来检查当前的容器其提供的服务是否正常的。</p>

<p>用法：<code>HEALTHCHECK [OPTIONS] CMD command</code>。CMD之前的选项有：</p>

<ul>
  <li>–interval=DURATION (default: 30s)</li>
  <li>–timeout=DURATION (default: 30s)</li>
  <li>–start-period=DURATION (default: 0s)</li>
  <li>–retries=N (default: 3)</li>
</ul>

<p>范例，每5分钟检查一次WEB服务器是否正常工作（3秒内能响应请求）：</p>
<pre><code>HEALTHCHECK --interval=5m --timeout=3s \
  CMD curl -f http://localhost/ || exit 1
</code></pre>

<p>退出代码：</p>

<ul>
  <li>0: success - the container is healthy and ready for use</li>
  <li>1: unhealthy - the container is not working correctly</li>
  <li>2: reserved - do not use this exit code</li>
</ul>

<p>同样细节比较多，可以仔细阅读下官方文档：<a href="https://docs.docker.com/engine/reference/builder/#healthcheck" target="_blank">Dockerfile &gt; HEALTHCHECK</a>。</p>

<p>资料：</p>

<ul>
  <li><a href="https://howchoo.com/g/zwjhogrkywe/how-to-add-a-health-check-to-your-docker-container" target="_blank">How to add a health check to your Docker container</a></li>
</ul>

<h3 id="516-其他指令">5.1.6 其他指令</h3>
<p>有相当多的指令在本文中并没有展开，可以查看其官方文档：</p>

<ul>
  <li><a href="https://docs.docker.com/engine/reference/builder/#from" target="_blank">FROM</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#label" target="_blank">LABEL</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#expose" target="_blank">EXPOSE</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#env" target="_blank">ENV</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#add" target="_blank">ADD</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#copy" target="_blank">COPY</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#user" target="_blank">USER</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#workdir" target="_blank">WORKDIR</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#onbuild" target="_blank">ONBUILD</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#stopsignal" target="_blank">STOPSIGNAL</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#shell" target="_blank">SHELL</a></li>
</ul>

<h2 id="52-最佳实践">5.2 最佳实践</h2>
<h3 id="521-缩小镜像构建的context">5.2.1 缩小镜像构建的Context</h3>
<p>官方文档：<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#understand-build-context" target="_blank">Understand build context</a>。</p>

<p>简单理解就是保证运行<code>docker build</code>命令的根工作文件夹里的内容尽量少，最好只保有构建镜像必须的文件，能显著加速镜像构建的速度（减少Context传送需要花费的时间）。</p>

<p>举个例子：</p>

<figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span></span><span class="k">FROM</span><span class="s"> alpine:3.9.2</span>
<span class="k">ENTRYPOINT</span><span class="s"> [&quot;/bin/sh&quot;]</span></code></pre></figure>

<pre><code>$ mkdir ~/Downloads/docker &amp;&amp; cd ~/Downloads/docker
$ docker build -f Dockerfile -t empty_img:0.0.1 .

Sending build context to Docker daemon  2.048kB
Step 1/2 : FROM alpine:3.9.2
 ---&gt; 5cb3aa00f899
Step 2/2 : ENTRYPOINT ["/bin/sh"]
 ---&gt; Running in 6190582d6894
Removing intermediate container 6190582d6894
 ---&gt; bd0e931e4706
Successfully built bd0e931e4706
Successfully tagged empty_img:0.0.1
</code></pre>

<p>然后拷贝点垃圾文件到<code>~/Downloads/docker</code>，再执行一次：</p>

<pre><code>$ docker build -f Dockerfile --no-cache -t dummy_img:0.0.1 .

Sending build context to Docker daemon  630.1MB
Step 1/2 : FROM alpine:3.9.2
 ---&gt; 5cb3aa00f899
Step 2/2 : ENTRYPOINT ["/bin/sh"]
 ---&gt; Running in 0b6ebe8953ca
Removing intermediate container 0b6ebe8953ca
 ---&gt; 681e135d49b6
Successfully built 681e135d49b6
Successfully tagged dummy_img:0.0.1
</code></pre>

<p><code>Sending build context to Docker daemon  630.1MB</code>这一步花了很长时间（因为我拷贝过去的是630MB很零碎的小文件）。如果Context再大点，到百千GB级别的话，那影响更大。</p>

<p>对于构建出来的镜像大小是没有任何影响的：</p>

<pre><code>$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
dummy_img           0.0.1               681e135d49b6        40 seconds ago      5.53MB
empty_img           0.0.1               bd0e931e4706        8 minutes ago       5.53MB
alpine              3.9.2               5cb3aa00f899        3 weeks ago         5.53MB
</code></pre>

<h3 id="522-使用多阶段构建">5.2.2 使用多阶段构建</h3>
<p>官方文档：<a href="https://docs.docker.com/develop/develop-images/multistage-build/" target="_blank">Use multi-stage builds</a>。</p>

<p>一般来说总是希望镜像的体积越小越好，有利于传输也有利于减小容器的资源占用。而在镜像构建的时候，总会有很多中间产物。以go语言来举例，go语言最后编译产生的可执行文件是自包含的，对于外部的类库等都是不作要求的，而在go源码构建成可执行文件的过程中，则会有很多SDK等的环境需求。这就对<code>构建</code>和<code>生产</code>两个环境做了不同的定义及隔离要求。而<code>多阶段构建</code>这个功能，就是为了这种需求而服务的。</p>

<p>简单来说就是在同一个Dockerfile里有<code>多个</code><code>FROM指令</code>，每个FROM指令可以使用<code>as ...</code>这样的语法进行命名，这样的一行语句就定义了一个<code>阶段</code>。后面的阶段可以随意利用之前阶段里产生任何资源。通常的用法就是定义两个FROM即两个阶段，构建阶段和生产阶段。将所有的环境设置等都定义在构建阶段，然后将构建阶段编译产生的二进制文件拷贝到生产环境，这样生产环境就能够做到最小化了。</p>

<p>详细的例子可以直接查看官方文档，里面有一份非常详细的范例，正好就是按go制作的范例。</p>

<h3 id="523-构建的缓存">5.2.3 构建的缓存</h3>
<p>官方文档：<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache" target="_blank">Leverage build cache</a>。</p>

<p>这部分建议通读后理解，因为在<code>docker build</code>的时候，只要不添加<code>--no-cache</code>选项的话，构建就会检查并使用缓存。除非在工作中每次都放弃使用cache（在某些情况下会大大增加构建的时间消耗），否则对于缓存的命中还是有理解的必要。</p>

<h3 id="524-镜像层的创建">5.2.4 镜像层的创建</h3>
<blockquote>
  <p>Only the instructions RUN, COPY, ADD create layers. Other instructions create temporary intermediate images, and do not increase the size of the build.</p>
</blockquote>

<p>因此对于<code>RUN</code>、<code>COPY</code>以及<code>ADD</code>指令的使用需要非常小心，特别是RUN指令，尽量使用<code>&amp;&amp;</code>将其串起来。</p>

<h1 id="6-image">6. Image</h1>
<p>镜像文件的很多细节在之前的<a href="#ID_DOCKER_BUILD">4.5 docker build</a>以及<a href="#ID_DOCKERFILE">5. Dockerfile</a>都有提到了，所以讲到这里其实已经没什么很有价值的内容可以讲了。关于Image，有一篇非常不错的文章，只要过了一遍基本上Image本身就没什么神秘的了，可以看下：<a href="https://cameronlonsdale.com/2018/11/26/whats-in-a-docker-image/" target="_blank">What’s in a Docker image?</a>。</p>

<p>一些额外的资料：</p>

<ul>
  <li><a href="https://stackoverflow.com/questions/31222377/what-are-docker-image-layers" target="_blank">What are Docker image “layers”?</a></li>
  <li><a href="https://forums.docker.com/t/do-number-of-layers-in-an-image-affect-the-runtime-performance/43119" target="_blank">Do number of layers (in an image) affect the runtime performance?</a></li>
  <li><a href="https://medium.com/@jessgreb01/digging-into-docker-layers-c22f948ed612" target="_blank">Digging into Docker layers</a></li>
</ul>

<h1 id="7-docker-machine">7. Docker Machine</h1>
<p>官方文档：<a href="https://docs.docker.com/machine/overview/" target="_blank">Docker Machine Overview</a>。</p>

<p>Docker machine是用来辅助Ops对大批量机器进行docker部署时使用的工具。现如今规模化使用容器一般都会使用类似K8S这样的工具，所以这东西了解下就好。</p>

<p>资料：</p>

<ul>
  <li><a href="https://juejin.im/entry/5b3df2b4f265da0f6e5156de" target="_blank">docker-machine</a></li>
</ul>

<h1 id="8-深入">8. 深入</h1>
<p>上面的文章基本上把docker的命令以及一些日常使用的细节都过了一遍，也包含了类似镜像体积等优化内容。后面就会进入一些docker比较底层的东西了，类似于docker的网络模式、docker的磁盘模式等。</p>

<h2 id="81-网络">8.1 网络</h2>
<p>官方文档：<a href="https://docs.docker.com/network/" target="_blank">docker network overview</a></p>

<p>docker的网络子系统是可插拔式设计，其中可选的有：</p>

<ul>
  <li><code>bridge</code>：默认的网络驱动。如果不指定一个驱动的话，默认就是bridge模式。bridge模式通常应用在独立运行的容器相互之间需要通讯的应用场景</li>
  <li><code>host</code>：移除独立容器和Docker主机之间的网络隔离，并直接使用主机的网络。host模式仅针对高于Docker 17.06版本的swarm services可用</li>
  <li><code>overlay</code>：Overlay模式将多个Docker daemon连接起来，并启用swarm service来互通。你也可以使用overlay模式促进swarm service和独立容器之间的沟通，或是两个分别归属于不同Docker daemon的容器。这个策略简化了容器之间的互通，不再依赖于OS级别的路由</li>
  <li><code>macvlan</code>：Macvlan模式允许将一个MAC地址交付给一个容器，使得这个容器在你的网络中以一个硬件设备的身份出现。Docker daemon通过MAC地址将通讯路由到容器。macvlan模式通常用来处理需要直接连接到物理网络的遗留应用，而不需要路经Docker主机的网络栈</li>
  <li><code>none</code>：将某个容器禁用网络。通常与自定义的网络驱动结合使用。none驱动对swarm service不可用</li>
  <li><code>Third-party network plugins</code>：第三方网络插件，可自由安装使用。可以通过Docker Hub来安装，或通过第三方vendor安装</li>
</ul>

<p>选择建议：</p>

<ul>
  <li><code>User-defined bridge networks</code>：当相同Docker主机内的多个容器需要相互通讯的时候，这是最优解</li>
  <li><code>Host networks</code>：当容器的网络不应该与Docker主机隔离，且容器的其他方面应该与Docker主机隔离的情况下，这是最优解</li>
  <li><code>Overlay networks</code>：当需要运行在不同的Docker主机上的容器相互之间进行通讯，或当多个容器需要使用swarm service进行协同工作的时候，这是最优解</li>
  <li><code>Macvlan networks</code>：当从VM环境迁移到Docker环境或需要让容器看起来像物理主机的时候（每个容器都拥有一个唯一的MAC地址），这是最优解</li>
  <li><code>Third-party network plugins</code>：允许你将Docker整合到特殊的网络栈中</li>
</ul>

<p>通篇过一下之后会发现，基本上常用的场景，只要有bridge驱动就够了。后面会主要看下bridge驱动，其他的可以查看官方文档。</p>

<p>此外，有一篇比较老的文章，用中文举了点例子进行网络模式的说明，可以一读：<a href="http://dockone.io/article/1261" target="_blank">Docker网络模式</a>。</p>

<h3 id="811-bridge">8.1.1 bridge</h3>
<p>如果在创建容器的时候不指定网络设置的话，容器会使用默认的bridge驱动。而如果用户进行自定义bridge设置的话，使用的网络驱动就是稍微有点不同：<code>User-defined bridge networks</code>。这里还是有不少区别的：<a href="https://docs.docker.com/network/bridge/#differences-between-user-defined-bridges-and-the-default-bridge" target="_blank">Differences between user-defined bridges and the default bridge</a>：</p>

<ul>
  <li>User-defined bridges provide better isolation and interoperability between containerized applications.</li>
  <li>User-defined bridges provide automatic DNS resolution between containers.</li>
  <li>Containers can be attached and detached from user-defined networks on the fly.</li>
  <li>Each user-defined network creates a configurable bridge.</li>
  <li>Linked containers on the default bridge network share environment variables.</li>
</ul>

<p>自定义bridge驱动使用：</p>

<pre><code>$ docker network create my-net
$ docker network rm my-net

$ docker create --name my-nginx \
  --network my-net \
  --publish 8080:80 \
  nginx:latest

$ docker network connect my-net my-nginx
$ docker network disconnect my-net my-nginx
</code></pre>

<p>官方文档里写清楚了，默认的bridge驱动已经属于遗留功能，不建议在生产环境上使用。</p>

<blockquote>
  <p>The default bridge network is considered a legacy detail of Docker and is not recommended for production use.</p>
</blockquote>

<p>见文档：<a href="https://docs.docker.com/network/bridge/#use-the-default-bridge-network" target="_blank">Use the default bridge network</a>。</p>

<h3 id="812-其他">8.1.2 其他</h3>
<p>后面几种总的来说应用面都不大，在结合K8S使用的情况下（应该是大部分应用场景），只需要K8S即可。这里都可以略过。</p>

<h3 id="813-实践经验">8.1.3 实践经验</h3>
<p>如果只是照范例抄启动命令的话，一般来说总会有几个知识点理解不是很透彻，这个章节就仔细看下这些知识点。</p>

<h4 id="容器ip">容器IP</h4>
<p>每个容器在启动之后，都有其在设定的<code>--network=xxx</code>下的固定IP地址（e.g 172.17.0.35）。因此不要在让容器上运行的应用程序监听<code>Listener=127.0.0.1:xxx</code>这样的地址，否则其他服务将无法找到该应用。这和在本地运行应用程序是不一样的。</p>

<p>在本地开发和运行应用的时候，实际上所有的应用程序是部署在同一台物理机上的，因此回环地址可以正确找到应用。但使用容器的时候一般一个容器内只会有一个应用程序，会启动不同的几个容器让他们相互之间通讯，这时候回环地址就不会起效果了。</p>

<p>这是一个理解上的盲点，需要注意。</p>

<h4 id="容器名">容器名</h4>
<p>上面举的例子中，如果多个容器之间的应用程序需要相互访问，最好的监听地址配置方法是使用<code>容器名</code>作为监听的<code>host</code>。e.g <code>Listener=node1:xxx</code>。容器只要启动在同一个network下，相互之间是可以通过容器名查找到的。</p>

<h4 id="expose-vs-publish">expose vs publish</h4>
<p>两者之间的区别很简单：</p>

<ul>
  <li>expose仅将端口暴露给同一个network下的其他容器</li>
  <li>publish会将端口暴露给其他不同的网络或docker host</li>
</ul>

<p>如果你的应用全部运行在同一个network下，那么就用expose就够了，如果有多个docker network，相互之间的访问需要publish port。</p>

<p>参见：</p>

<ul>
  <li><a href="https://medium.freecodecamp.org/expose-vs-publish-docker-port-commands-explained-simply-434593dbc9a3" target="_blank">Expose vs publish: Docker port commands explained simply</a></li>
</ul>

<h2 id="ID_PRINCIPLE_STORAGE">8.2 存储</h2>
<p>官方文档：<a href="https://docs.docker.com/storage/" target="_blank">Manage data in Docker</a>。</p>

<p>任何在容器内创建的文件都会存储在容器的可写层内。这意味着：</p>

<ul>
  <li>当容器消失的时候这些数据会丢失，且当其他进程需要共享这些数据的时候很难获取到这些数据</li>
  <li>容器的可写层是和物理主机紧密关联的，很难轻易移动到其他机器上</li>
  <li>向容器的可写层写入数据要求一个存储驱动来管理文件系统。存储驱动是一个洋葱式的文件系统，使用Linux内核。这额外的抽象会降低性能，和直接使用<code>data volumn</code>相比，后者直接向主机的文件系统写入数据</li>
</ul>

<p>Docker提供了选项来让容器在物理主机上存储文件，这样才能保证容器在停止之后文件仍旧存在：</p>

<ul>
  <li>volumes</li>
  <li>bind mounts</li>
  <li>tmpfs mount（仅限Linux）</li>
</ul>

<h3 id="821-几种类型的mount">8.2.1 几种类型的mount</h3>
<ul>
  <li><code>Volumes</code>：会将数据写入到主机磁盘上的<code>Docker指定</code>地点（/var/lib/docker/volumes/ on Linux），且这些文件是由Docker进程进行管理的，其他任何进程都不应该直接修改这些文件。Volumes是在Docker内存储数据的最佳选择</li>
  <li><code>Bind mounts</code>：可将数据写入到主机磁盘上的<code>任何</code>地点，甚至可以是重要的系统文件，或文件夹。非Docker进程及Docker容器都可以在任何时候修改这些文件</li>
  <li><code>tmpfs mounts</code>：仅将数据保存在内存中，并永远不会存储到磁盘上</li>
</ul>

<p>更进一步的各种mount类型细节可以查阅官方文档：<a href="https://docs.docker.com/storage/#more-details-about-mount-types" target="_blank">More details about mount types</a>。这里做一下整理：</p>

<p><strong>Volumns</strong></p>

<ul>
  <li>一个volume可以被多个容器共享</li>
  <li>volume在容器都停止之后不会被删除，除非手动操作：<code>docker volume prune</code></li>
  <li>volume是可命名的，如果没有被命名，则会被自动附加一个唯一串作为名字</li>
  <li>volume还可以加载volume drivers，为其提供更丰富的存储功能</li>
</ul>

<p><strong>Bind mounts</strong></p>

<ul>
  <li>使用bind mounts的时候，一个主机上的文件或文件夹被加载到容器中</li>
  <li>文件或文件夹需要完整路径</li>
  <li>文件或文件夹不需要已经存在</li>
  <li>docker cli命令无法直接操作bind mounts资料</li>
  <li>官方更推荐命名化的volumes，而不是使用bind mounts</li>
</ul>

<p>官方还给了最佳使用范例：</p>

<ul>
  <li><a href="https://docs.docker.com/storage/#good-use-cases-for-volumes" target="_blank">Good use cases for volumes</a></li>
  <li><a href="https://docs.docker.com/storage/#good-use-cases-for-bind-mounts" target="_blank">Good use cases for bind mounts</a></li>
  <li><a href="https://docs.docker.com/storage/#good-use-cases-for-tmpfs-mounts" target="_blank">Good use cases for tmpfs mounts</a></li>
</ul>

<p>几点tips：</p>

<ul>
  <li>如果把一个空的volume（使用docker create创建出来的）绑定到运行中容器的某个已经存在的文件夹上，会导致已经存在文件夹内的资料被拷贝到volume内</li>
  <li>如果把一个bind mount或已经有内容的volume绑定到某个运行中容器的某个已经存在的文件夹上，则容器内重合文件夹内的资料会被屏蔽（不会被删除），volume内的资料则可访问</li>
</ul>

<p>在我看来：</p>

<ul>
  <li>volumes应该是最先选择，如果没有特殊需求的话，类似于web服务器这种无状态可以很快横向扩展的就很适合使用volumes</li>
  <li>bind mounts可以用在<code>其他进程有直接访问文件需求</code>的场景。volumes是docker进程自组织的，对外就是一个block文件，无法看到细节，其实不太友好，在docker之外的进程也需要对文件进行访问的时候就很不方便了，这种场景就需要bind mounts</li>
</ul>

<h3 id="822-日常使用命令">8.2.2 日常使用命令</h3>
<pre><code>$ docker volume create my-vol
$ docker volume ls
$ docker volume inspect my-vol
$ docker volume rm my-vol # delete volume
$ docker volume prune # delete all
</code></pre>

<h3 id="823-volumes">8.2.3 Volumes</h3>
<p>官方文档：<a href="https://docs.docker.com/storage/volumes/" target="_blank">Use volumes</a>。</p>

<p>优势：</p>

<ul>
  <li>Volumes are easier to back up or migrate than bind mounts.</li>
  <li>You can manage volumes using Docker CLI commands or the Docker API.</li>
  <li>Volumes work on both Linux and Windows containers.</li>
  <li>Volumes can be more safely shared among multiple containers.</li>
  <li>Volume drivers let you store volumes on remote hosts or cloud providers, to encrypt the contents of volumes, or to add other functionality.</li>
  <li>New volumes can have their content pre-populated by a container.</li>
</ul>

<p>可以使用<code>--volume</code>或<code>--mount</code>来指定容器运行时需要mount的卷，使用上有点些微的不同：</p>

<pre><code>$ docker run --volume \
    $volume_name:$path_mounted_in_container:$option1,$option2,...

$ docker run --mount \
    type=volume,source|src=$volume_name,destination|dst|target=$path_mounted_in_container,readonly,volume-opt=$key1=$val1,volume-opt=$key2=$val2,...
</code></pre>

<p>几点不常用但可能用得到的点：</p>

<ul>
  <li><a href="https://docs.docker.com/storage/volumes/#use-a-volume-driver" target="_blank">Use a volume driver</a></li>
  <li><a href="https://docs.docker.com/storage/volumes/#backup-restore-or-migrate-data-volumes" target="_blank">Backup, restore, or migrate data volumes</a></li>
</ul>

<h3 id="824-bind-mounts">8.2.4 Bind mounts</h3>
<p>官方文档：<a href="https://docs.docker.com/storage/bind-mounts/" target="_blank">Use bind mounts</a>。</p>

<p>可以使用<code>--volume</code>或<code>--mount</code>来指定容器运行时需要mount的卷，使用上有点些微的不同：</p>

<pre><code>$ docker run --volume \
    $path_on_host_tobe_bound:$path_mounted_in_container:$option1,$option2,...

$ docker run --mount \
    type=bind,source|src=$path_on_host_tobe_bound,destination|dst|target=$path_mounted_in_container,readonly,bind-propagation=rprivate|private|rshared|shared|rslave|slave
</code></pre>

<p>对bind mounts来说<code>--volume</code>和<code>--mount</code>在使用上是有区别的：</p>

<ul>
  <li><code>--volume</code>：指定的主机位置不存在的话，会主动创建出来（总是创建成文件夹）</li>
  <li><code>--mount</code>：指定的主机位置不存在的话，不会主动创建，而是报错</li>
</ul>

<p>举个简单的例子：</p>

<pre><code>$ cd /Users/XXX &amp;&amp; mkdir ./docker &amp;&amp; cd ./docker &amp;&amp; touch ./dummy.txt &amp;&amp; echo dummy &gt; ./dummy.txt
$ docker run -it -d --rm -v /Users/XXX/Downloads/docker/:/dirinc --name bind_mount_test ubuntu:18.10
$ docker attach 8d11c4aad023

root@8d11c4aad023:/# ll /dirinc
...
-rw-r--r-- 1 root root    8 Apr  3 02:23 dummy.txt
root@8d11c4aad023:/# echo changed &gt; /dirinc/dummy.txt

$ cat /Users/XXX/docker/dummy.txt
changed
</code></pre>

<p>几点不常用但可能用得到的点：</p>

<ul>
  <li><a href="https://docs.docker.com/storage/bind-mounts/#configure-bind-propagation" target="_blank">Configure bind propagation</a></li>
  <li><a href="https://docs.docker.com/storage/bind-mounts/#configure-the-selinux-label" target="_blank">Configure the selinux label</a></li>
</ul>

<h3 id="825-storage-drivers">8.2.5 Storage drivers</h3>
<p>官方文档：<a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/" target="_blank">Docker storage drivers</a>。</p>

<p>这部分里会讲到的<code>storage drivers</code>和之前的volumes是不同的东西，所谓的<code>storage drivers</code>是指docker从镜像生成容器之后，在容器的最上面创建出来的那一层可写入层里，使用的文件处理策略（驱动）。</p>

<p>这部分不会太过展开，主要是因为：</p>

<ul>
  <li>会在容器的可写层里大量产生数据的应用场景一般不会存在，如果存在那一般也是有问题的</li>
  <li>在真的需要容器对存储设备进行大量写入操作的情况，需要考虑是否使用volumes，而不是直接在容器的可写入层里进行写操作（两者在性能上也有差距）</li>
</ul>

<p>因此实际上这块的实用性并不高。后面主要以认识<code>storage drivers</code>为主。</p>

<p>Docker支持的storage drivers：</p>

<ul>
  <li><code>overlay2</code>：首选的驱动，对现行的所有Linux发行版本可用，且无需额外的配置</li>
  <li><code>aufs</code>：对 Docker 18.06 及更老旧的版本来说是首选驱动，或 Ubuntu 14.04 kernel 3.13 不支持 overlay2 的环境</li>
  <li><code>devicemapper</code>：受到支持，但在生产环境需要<code>direct-lvm</code>，是因为<code>loopback-lvm</code>虽然无需配置，但性能不是很好</li>
  <li>The <code>btrfs</code> and <code>zfs</code> storage drivers are used if they are the backing filesystem (the filesystem of the host on which Docker is installed). These filesystems allow for advanced options, such as creating “snapshots”, but require more maintenance and setup. Each of these relies on the backing filesystem being configured correctly.</li>
  <li>The <code>vfs</code> storage driver is intended for testing purposes, and for situations where no copy-on-write filesystem can be used. Performance of this storage driver is poor, and is not generally recommended for production use.</li>
</ul>

<p>要查看各Linux发行版本支持的驱动，可以查看：<a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/#supported-storage-drivers-per-linux-distribution" target="_blank">Supported storage drivers per Linux distribution</a>。</p>

<p>要查看各文件系统支持的驱动，可以查看：<a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/#supported-backing-filesystems" target="_blank">Supported backing filesystems</a>。</p>

<p>后面还有很多各种驱动的细节，这里就不展开了，给出一些资料：</p>

<ul>
  <li><a href="https://docs.docker.com/storage/storagedriver/aufs-driver/" target="_blank">Use the AUFS storage driver</a></li>
  <li><a href="https://docs.docker.com/storage/storagedriver/btrfs-driver/" target="_blank">Use the BTRFS storage driver</a></li>
  <li><a href="https://docs.docker.com/storage/storagedriver/device-mapper-driver/" target="_blank">Use the Device Mapper storage driver</a></li>
  <li><a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank">Use the OverlayFS storage driver</a></li>
  <li><a href="https://docs.docker.com/storage/storagedriver/zfs-driver/" target="_blank">Use the ZFS storage driver</a></li>
  <li><a href="https://docs.docker.com/storage/storagedriver/vfs-driver/" target="_blank">Use the VFS storage driver</a></li>
  <li><a href="https://coolshell.cn/articles/17061.html" target="_blank">DOCKER基础技术：AUFS</a></li>
  <li><a href="https://coolshell.cn/articles/17200.html" target="_blank">DOCKER基础技术：DEVICEMAPPER</a></li>
</ul>

<h2 id="ID_PRINCIPLE_RESOURCE">8.3 资源限制</h2>
<p>这块的话题有点大，本质上来说，Docker的资源限制利用的还是Linux本身的机制。即便撇开Docker，这些知识点也是值得一看的，但鉴于主题，这里就不多展开了。后续这个章节的主要目标是将Docker的一些限制手段以及后面的Linux原理相关的思路整理出来，并附上资料，不会过于深入。</p>

<p>实际上在真实场景使用的时候一般也会使用类似K8S这样的系统来进行集群管理，不太会直接在Docker这一层工具上对资源限制这块过多设置。</p>

<h3 id="831-linux">8.3.1 Linux</h3>
<p>Linux中的namespace、cgroup、capabilities等核心概念，可以看下面几篇：</p>

<ul>
  <li><a href="https://coolshell.cn/articles/17010.html" target="_blank">DOCKER基础技术：LINUX NAMESPACE（上）</a></li>
  <li><a href="https://coolshell.cn/articles/17029.html" target="_blank">DOCKER基础技术：LINUX NAMESPACE（下）</a></li>
  <li><a href="https://coolshell.cn/articles/17049.html" target="_blank">DOCKER基础技术：LINUX CGROUP</a></li>
  <li><a href="https://rk700.github.io/2016/10/26/linux-capabilities/" target="_blank">Linux的capabilities机制</a></li>
</ul>

<h3 id="832-docker">8.3.2 Docker</h3>
<p>Docker官方对于资源限制也有不小的篇幅进行解说，在使用上有需要的时候可以查看：</p>

<ul>
  <li><a href="https://docs.docker.com/engine/reference/run/#runtime-constraints-on-resources" target="_blank">docker run &gt; Runtime constraints on resources</a></li>
  <li><a href="https://docs.docker.com/config/containers/resource_constraints/" target="_blank">Limit a container’s resources</a></li>
</ul>

<h3 id="833-其他">8.3.3 其他</h3>
<p>其他资料：</p>

<ul>
  <li><a href="http://cizixs.com/2017/08/25/linux-cgroup/" target="_blank">docker 容器基础技术：linux cgroup 简介</a></li>
  <li><a href="https://infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank">Docker 背后的内核知识——cgroups 资源限制</a></li>
  <li><a href="https://medium.com/@asishrs/docker-limit-resource-utilization-using-cgroup-parent-72a646651f9d" target="_blank">Docker limit resource utilization using cgroup-parent</a></li>
  <li><a href="https://medium.com/@kasunmaduraeng/docker-namespace-and-cgroups-dece27c209c7" target="_blank">Docker Namespace and Cgroups</a></li>
  <li><a href="https://my.oschina.net/HardySimpson/blog/868186" target="_blank">cgroup, docker,和kubernetes</a></li>
  <li><a href="https://www.cnblogs.com/sammyliu/p/5886833.html" target="_blank">理解Docker（4）：Docker 容器使用 cgroups 限制资源使用</a></li>
</ul>

<h2 id="84-监控--metrics">8.4 监控 &amp; Metrics</h2>
<p>这块和上面的内容类似也比较鸡肋，一般来说不会直接裸用Docker，如果有K8S之类的，那监控也不会从Docker来了。所以这里就给点资料即可，有需要的可以深入下官方文档：</p>

<ul>
  <li><a href="https://docs.docker.com/config/containers/runmetrics/" target="_blank">Runtime metrics</a>
    <ul>
      <li><code>docker stats</code>是类似top的工具，可以对整体运行的容器有一个overall的把握</li>
      <li>docker对于性能指标的监控仍旧依赖于Linux的cgroup</li>
      <li><a href="https://docs.docker.com/config/containers/runmetrics/#metrics-from-cgroups-memory-cpu-block-io" target="_blank">Metrics from cgroups: memory, CPU, block I/O</a></li>
      <li><a href="https://docs.docker.com/config/containers/runmetrics/#cpu-metrics-cpuacctstat" target="_blank">CPU metrics: cpuacct.stat</a></li>
      <li><a href="https://docs.docker.com/config/containers/runmetrics/#network-metrics" target="_blank">Network metrics</a></li>
    </ul>
  </li>
  <li><a href="https://docs.docker.com/config/thirdparty/prometheus/" target="_blank">Collect Docker metrics with Prometheus</a></li>
</ul>

<h2 id="85-安全">8.5 安全</h2>
<p>官方文档：<a href="https://docs.docker.com/engine/security/security/" target="_blank">Docker security</a>。</p>

<p>老话重提，里面的知识点仍旧是上面提到过的Linux cgroup、capabilities等几个知识点。</p>

<p>此外，用户管理也是一个需要关注的点，Docker默认的用户是root，在某些情况下使用者有必要进行更换。参见：<a href="https://stackoverflow.com/questions/30052019/docker-creates-files-as-root-in-mounted-volume" target="_blank">Docker creates files as root in mounted volume [duplicate]</a>。</p>

<h2 id="87-其他">8.7 其他</h2>
<ul>
  <li>停止容器：<a href="https://www.ctl.io/developers/blog/post/gracefully-stopping-docker-containers/" target="_blank">Gracefully Stopping Docker Containers</a></li>
  <li><a href="https://coolshell.cn/articles/18654.html" target="_blank">记一次KUBERNETES/DOCKER网络排障</a></li>
</ul>

<h1 id="9-os镜像选择">9. OS镜像选择</h1>
<h2 id="91-alpine">9.1 Alpine</h2>
<p>技术过硬的话，Alpine应该说是制作生产环境产品镜像的首选了，毕竟体积摆在那边，只有几兆的基本镜像可真的没几个好选的。</p>

<ul>
  <li><a href="https://github.com/gliderlabs/docker-alpine" target="_blank">gliderlabs/docker-alpine</a>：官方项目</li>
  <li><a href="https://hub.docker.com/_/alpine" target="_blank">docker hub &gt; alpine</a>：官方镜像</li>
</ul>

<p>一些资料：</p>

<ul>
  <li><a href="https://github.com/gliderlabs/docker-alpine#why" target="_blank">gliderlabs/docker-alpine#Why?</a>：官方安利，主要的主张就是体积小+软件安装包全面</li>
  <li><a href="https://wiki.alpinelinux.org/wiki/Comparison_with_other_distros" target="_blank">Comparison with other distros</a>：一篇比较的wiki，不过这篇更倾向于使用上的比较，指导意义不大</li>
  <li><a href="https://nickjanetakis.com/blog/benchmarking-debian-vs-alpine-as-a-base-docker-image" target="_blank">Benchmarking Debian vs Alpine as a Base Docker Image</a>：这篇比较硬核，从具体的benchmark上进行了比较，非常值得一读</li>
  <li><a href="https://thenewstack.io/alpine-linux-heart-docker/" target="_blank">Meet Alpine Linux, Docker’s Distribution of Choice for Containers</a>：这是一篇安利文，讲的点比较全面，可以一读</li>
</ul>

<h3 id="dns-issue">DNS issue</h3>
<p>DNS问题算是Alpine被诟病得比较多的一点，可以看一个issue：<a href="https://github.com/gliderlabs/docker-alpine/issues/255" target="_blank">DNS Issue #255</a>。官方在github的文档上也给了说明，可以看下：<a href="https://github.com/gliderlabs/docker-alpine/blob/master/docs/caveats.md#dns" target="_blank">caveats.md » DNS</a>，当然具体是否有这个情况以及如何解决，就要看实践了。</p>

<h1 id="10-实践">10. 实践</h1>
<h2 id="列出所有本机镜像">列出所有本机镜像</h2>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span>$ docker images</code></pre></figure>

<h2 id="列出本机所有容器">列出本机所有容器</h2>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span>$ docker ps -a</code></pre></figure>

<h2 id="列出本机磁盘使用情况">列出本机磁盘使用情况</h2>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span>$ docker system df -v</code></pre></figure>

<h2 id="本机空间清理">本机空间清理</h2>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span>$ docker system prune</code></pre></figure>

<p>几个概念：</p>

<ul>
  <li>已使用镜像（used image）： 指所有已被容器（包括已停止的）关联的镜像。即 docker ps -a 看到的所有容器使用的镜像</li>
  <li>未引用镜像（unreferenced image）：没有被分配或使用在容器中的镜像，但它有 Tag 信息</li>
  <li>悬空镜像（dangling image）：未配置任何 Tag （也就无法被引用）的镜像，所以悬空。这通常是由于镜像 build 的时候没有指定 -t 参数配置 Tag 导致的</li>
  <li>挂起的卷（dangling Volume)：类似的，dangling=true 的 Volume 表示没有被任何容器引用的卷</li>
</ul>

<p>docker system prune 自动清理说明：</p>

<p>该指令默认会清除所有如下资源：</p>

<ul>
  <li>已停止的容器（container）</li>
  <li>未被任何容器所使用的卷（volume）</li>
  <li>未被任何容器所关联的网络（network）</li>
  <li>所有悬空镜像（image）</li>
  <li>该指令默认只会清除悬空镜像，未被使用的镜像不会被删除</li>
  <li>添加 -a 或 –all 参数后，可以一并清除所有未使用的镜像和悬空镜像</li>
  <li>可以添加 -f 或 –force 参数用以忽略相关告警确认信息</li>
  <li>指令结尾处会显示总计清理释放的空间大小</li>
</ul>

<p>参见：</p>

<ul>
  <li><a href="https://zhuanlan.zhihu.com/p/31820191" target="_blank">Docker 空间使用分析与清理</a></li>
</ul>

<h2 id="本机镜像清理">本机镜像清理</h2>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span><span class="c1"># 删除所有悬空镜像，但不会删除未使用镜像：</span>
$ docker rmi <span class="k">$(</span>docker images -f <span class="s2">&quot;dangling=true&quot;</span> -q<span class="k">)</span>

<span class="c1"># 删除所有未使用镜像和悬空镜像。</span>
<span class="c1"># 【说明】：轮询到还在被使用的镜像时，会有类似&quot;image is being used by xxx container&quot;的告警信息，所以相关镜像不会被删除，忽略即可。</span>
$ docker rmi <span class="k">$(</span>docker images -q<span class="k">)</span></code></pre></figure>

<h2 id="本机卷清理">本机卷清理</h2>
<p>如果通过 docker system df 分析，是卷占用了过高空间。则可以根据业务情况，评估相关卷的使用情况。对于未被任何容器调用的卷（-v 结果信息中，”LINKS” 显示为 0），可以使用如下指令手工清理：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span><span class="c1"># 删除所有未被任何容器关联引用的卷：</span>
$ docker volume rm <span class="k">$(</span>docker volume ls -f <span class="s2">&quot;dangling=true&quot;</span> -q<span class="k">)</span>

<span class="c1"># 也可以直接使用如下指令，删除所有未被任何容器关联引用的卷（但建议使用上面的方式）</span>
<span class="c1"># 【说明】轮询到还在使用的卷时，会有类似&quot;volume is in use&quot;的告警信息，所以相关卷不会被删除，忽略即可。</span>
$ docker volume rm <span class="k">$(</span>docker volume ls -q<span class="k">)</span></code></pre></figure>

<h2 id="日志驱动及容量设置">日志驱动及容量设置</h2>
<p>见过好几个日志文件膨胀到把主机磁盘吃光的情况，所以这方面还是要小心处理。</p>

<p>官方文档：</p>

<ul>
  <li><a href="https://docs.docker.com/config/containers/logging/configure/" target="_blank">Configure logging drivers</a></li>
  <li><a href="https://docs.docker.com/config/containers/logging/json-file/" target="_blank">JSON File logging driver</a></li>
</ul>

<p>在docker run命令中修改日志输出driver，以及限定最大日志空间占用：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span>$ docker run <span class="se">\</span>
      --log-driver json-file --log-opt max-size<span class="o">=</span>10m <span class="se">\</span>
      alpine <span class="nb">echo</span> hello world</code></pre></figure>

<p>更多的可以查看官方文档。</p>

<h2 id="查看网络内容器列表">查看网络内容器列表</h2>
<p>注意下面的例子中双花括号的转译符需要自行去除：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span><span class="c1"># 只获取名字</span>
$ docker network inspect -f <span class="s1">&#39;\{\{ range $key, $value := .Containers \}\}\{\{ printf &quot;%s\n&quot; $value.Name \}\}\{\{ end \}\}&#39;</span> <span class="si">${</span><span class="p">网络名</span><span class="si">}</span>

<span class="c1"># 观察打印出来的结构中的 Containers 部分，可以获得更详细的信息</span>
$ docker network inspect <span class="si">${</span><span class="p">网络名</span><span class="si">}</span></code></pre></figure>

<h2 id="查看容器所属网络">查看容器所属网络</h2>
<p>注意下面的例子中双花括号的转译符需要自行去除：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span><span class="c1"># 只获取名字</span>
$ docker inspect -f <span class="s1">&#39;\{\{ range $key, $value := .NetworkSettings.Networks \}\}\{\{ printf &quot;%s\n&quot; $key \}\}\{\{ end \}\}&#39;</span> <span class="si">${</span><span class="p">容器名</span><span class="si">}</span>

<span class="c1"># 观察打印出来的结构中的 Networks 部分，可以获得更详细的信息</span>
$ docker inspect <span class="si">${</span><span class="p">容器名</span><span class="si">}</span></code></pre></figure>

<h2 id="查看容器运行状态">查看容器运行状态</h2>
<p>注意下面的例子中双花括号的转译符需要自行去除：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span>$ docker stats <span class="c1"># 默认一直刷新，类似top命令</span>
$ docker stats --no-stream <span class="c1"># 不刷新，只获取一次</span>
$ docker stats --no-stream <span class="si">${</span><span class="p">容器名</span><span class="si">}</span> <span class="c1"># 获取指定的容器状态</span>
$ docker stats --format <span class="s2">&quot;table \{\{.Name\}\}\t\{\{.CPUPerc\}\}\t\{\{.MemUsage\}\}&quot;</span> <span class="c1"># 格式化输出</span>
<span class="c1"># JSON格式输出</span>
$ docker stats --no-stream --format <span class="se">\</span>
      <span class="s2">&quot;{\&quot;container\&quot;:\&quot;\{\{ .Container \}\}\&quot;,\&quot;memory\&quot;:{\&quot;raw\&quot;:\&quot;\{\{ .MemUsage \}\}\&quot;,\&quot;percent\&quot;:\&quot;\{\{ .MemPerc \}\}\&quot;},\&quot;cpu\&quot;:\&quot;\{\{ .CPUPerc \}\}\&quot;}&quot;</span></code></pre></figure>

<ul>
  <li>.Container：根据用户指定的名称显示容器的名称或 ID</li>
  <li>.Name：容器名称</li>
  <li>.ID：容器 ID</li>
  <li>.CPUPerc：CPU 使用率</li>
  <li>.MemUsage：内存使用量</li>
  <li>.NetIO：网络 I/O</li>
  <li>.BlockIO：磁盘 I/O</li>
  <li>.MemPerc：内存使用率</li>
  <li>.PIDs：PID 号</li>
</ul>

<p>参见：</p>

<ul>
  <li><a href="https://www.cnblogs.com/sparkdev/p/7821376.html" target="_blank">查看 docker 容器使用的资源</a></li>
</ul>

<h1 id="11-其他">11. 其他</h1>
<h2 id="111-什么是docker-host">11.1 什么是docker host</h2>
<p>在很多docker的文档里都提到了<code>docker host</code>这个概念。至于什么是docker host，可以参见链接：<a href="https://forums.docker.com/t/clarify-what-is-the-host/29640/2" target="_blank">Clarify what is the host</a>。</p>

<blockquote>
  <p>I think you pretty much found out the answer by yourself. In that diagram you mention a ‘docker host’ is any machine that is running the Docker daemon. This means that you’re either running Docker natively in your operating system, or a virtual machine that has Docker installed.</p>

  <p>Docker machine is basically the second option. When you do a docker-machine create it creates a new virtual machine with Docker already installed. This means that to access any containers running on this machine you’ll have to use the IP address of the virtual machine. Also, to give Docker access to a file you’ll either have to copy it to the VM that’s running Docker, or share a directory between your OS and the VM that’s running Docker.</p>
</blockquote>

<h2 id="112-comdockerhyperkit-x00-cpu-consumption-mac">11.2 com.docker.hyperkit X00% cpu consumption MAC</h2>
<p>在MAC上使用docker，如果放一些有真实负载的container，一般都会遇到这个问题（甚至是没什么负载，只是搭建环境都会）。</p>

<p>官方论坛有一个issue：<a href="https://github.com/docker/for-mac/issues/1759#issuecomment-481742599" target="_blank">High CPU Utilization of Hyperkit in Mac #1759</a>，到现在还是<code>open状态</code>，且看起来解决遥遥无期。</p>

<p>issue中似乎有用的只有改大max open file选项这条意见，具体操作可以参见：<a href="https://wilsonmar.github.io/maximum-limits/" target="_blank">Maximum limits (macOS etc.)</a>。</p>

<p>不确定是否一定能起效果，应该是对部分情况有效的。但对我来说貌似是没用，我的ulimit已经是：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span>$ launchctl limit maxfiles
<span class="c1"># maxfiles    65536          65536</span></code></pre></figure>

<h1 id="资料">资料</h1>
<h2 id="docker官方">Docker官方</h2>
<ul>
  <li><a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank">Docker Desktop for Mac</a></li>
  <li><a href="https://docs.docker.com/docker-for-mac/" target="_blank">Get started with Docker Desktop for Mac</a></li>
  <li><a href="https://hub.docker.com" target="_blank">docker hub</a></li>
  <li><a href="https://docs.docker.com/registry/" target="_blank">Docker Registry</a></li>
  <li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank">Best practices for writing Dockerfiles</a></li>
</ul>

<h2 id="docker命令">Docker命令</h2>
<ul>
  <li><a href="https://www.jianshu.com/p/ea4a00c6c21c" target="_blank">Docker run 命令参数及使用</a></li>
  <li><a href="https://www.centos.bz/2017/01/docker-run-uts-ipc/" target="_blank">Docker run参考(5) – UTS(–uts)和IPC (–ipc)设置</a></li>
  <li><a href="https://stackoverflow.com/a/19689048" target="_blank">How do you attach and detach from Docker’s process?</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/30555962" target="_blank">Dockerfile: ENTRYPOINT和CMD的区别</a></li>
  <li><a href="https://medium.freecodecamp.org/docker-entrypoint-cmd-dockerfile-best-practices-abc591c30e21" target="_blank">Docker ENTRYPOINT &amp; CMD: Dockerfile best practices</a></li>
  <li><a href="https://howchoo.com/g/zwjhogrkywe/how-to-add-a-health-check-to-your-docker-container" target="_blank">How to add a health check to your Docker container</a></li>
  <li><a href="https://medium.freecodecamp.org/expose-vs-publish-docker-port-commands-explained-simply-434593dbc9a3" target="_blank">Expose vs publish: Docker port commands explained simply</a></li>
</ul>

<h2 id="镜像相关">镜像相关</h2>
<ul>
  <li><a href="https://github.com/gliderlabs/docker-alpine" target="_blank">gliderlabs/docker-alpine</a></li>
  <li><a href="https://hub.docker.com/_/alpine" target="_blank">docker hub &gt; alpine</a></li>
  <li><a href="https://github.com/gliderlabs/docker-alpine#why" target="_blank">gliderlabs/docker-alpine#Why?</a></li>
  <li><a href="https://wiki.alpinelinux.org/wiki/Comparison_with_other_distros" target="_blank">Comparison with other distros</a></li>
  <li><a href="https://nickjanetakis.com/blog/benchmarking-debian-vs-alpine-as-a-base-docker-image" target="_blank">Benchmarking Debian vs Alpine as a Base Docker Image</a></li>
  <li><a href="https://thenewstack.io/alpine-linux-heart-docker/" target="_blank">Meet Alpine Linux, Docker’s Distribution of Choice for Containers</a></li>
  <li><a href="https://github.com/gliderlabs/docker-alpine/issues/255" target="_blank">DNS Issue #255</a></li>
  <li><a href="https://github.com/gliderlabs/docker-alpine/blob/master/docs/caveats.md#dns" target="_blank">caveats.md » DNS</a></li>
  <li><a href="https://cameronlonsdale.com/2018/11/26/whats-in-a-docker-image/" target="_blank">What’s in a Docker image?</a>。</li>
  <li><a href="https://stackoverflow.com/questions/31222377/what-are-docker-image-layers" target="_blank">What are Docker image “layers”?</a></li>
  <li><a href="https://forums.docker.com/t/do-number-of-layers-in-an-image-affect-the-runtime-performance/43119" target="_blank">Do number of layers (in an image) affect the runtime performance?</a></li>
  <li><a href="https://medium.com/@jessgreb01/digging-into-docker-layers-c22f948ed612" target="_blank">Digging into Docker layers</a></li>
</ul>

<h2 id="其他">其他</h2>
<ul>
  <li><a href="https://forums.docker.com/t/clarify-what-is-the-host/29640/2" target="_blank">Clarify what is the host</a></li>
  <li><a href="https://github.com/grpc/grpc-node/issues/604" target="_blank">grpc/grpc-node#604</a></li>
  <li><a href="https://juejin.im/entry/5b3df2b4f265da0f6e5156de" target="_blank">docker-machine</a></li>
  <li><a href="http://dockone.io/article/1261" target="_blank">Docker网络模式</a></li>
  <li><a href="https://coolshell.cn/articles/17061.html" target="_blank">DOCKER基础技术：AUFS</a></li>
  <li><a href="https://coolshell.cn/articles/17200.html" target="_blank">DOCKER基础技术：DEVICEMAPPER</a></li>
  <li><a href="https://coolshell.cn/articles/17010.html" target="_blank">DOCKER基础技术：LINUX NAMESPACE（上）</a></li>
  <li><a href="https://coolshell.cn/articles/17029.html" target="_blank">DOCKER基础技术：LINUX NAMESPACE（下）</a></li>
  <li><a href="https://coolshell.cn/articles/17049.html" target="_blank">DOCKER基础技术：LINUX CGROUP</a></li>
  <li><a href="https://rk700.github.io/2016/10/26/linux-capabilities/" target="_blank">Linux的capabilities机制</a></li>
  <li><a href="http://cizixs.com/2017/08/25/linux-cgroup/" target="_blank">docker 容器基础技术：linux cgroup 简介</a></li>
  <li><a href="https://infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank">Docker 背后的内核知识——cgroups 资源限制</a></li>
  <li><a href="https://medium.com/@asishrs/docker-limit-resource-utilization-using-cgroup-parent-72a646651f9d" target="_blank">Docker limit resource utilization using cgroup-parent</a></li>
  <li><a href="https://medium.com/@kasunmaduraeng/docker-namespace-and-cgroups-dece27c209c7" target="_blank">Docker Namespace and Cgroups</a></li>
  <li><a href="https://my.oschina.net/HardySimpson/blog/868186" target="_blank">cgroup, docker,和kubernetes</a></li>
  <li><a href="https://www.cnblogs.com/sammyliu/p/5886833.html" target="_blank">理解Docker（4）：Docker 容器使用 cgroups 限制资源使用</a></li>
  <li><a href="https://www.ctl.io/developers/blog/post/gracefully-stopping-docker-containers/" target="_blank">Gracefully Stopping Docker Containers</a></li>
  <li><a href="https://coolshell.cn/articles/18654.html" target="_blank">记一次KUBERNETES/DOCKER网络排障</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/31820191" target="_blank">Docker 空间使用分析与清理</a></li>
  <li><a href="https://www.cnblogs.com/sparkdev/p/7821376.html" target="_blank">查看 docker 容器使用的资源</a></li>
</ul>

<h2 id="ID_APP_DOCKER_INFO">docker info</h2>
<pre><code>docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 1
Server Version: 18.09.2
Storage Driver: overlay2
 Backing Filesystem: extfs
 Supports d_type: true
 Native Overlay Diff: true
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: bridge host macvlan null overlay
 Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Init Binary: docker-init
containerd version: 9754871865f7fe2f4e74d43e2fc7ccd237edcbce
runc version: 09c8266bf2fcf9519a651b04ae54c967b9ab86ec
init version: fec3683
Security Options:
 seccomp
  Profile: default
Kernel Version: 4.9.125-linuxkit
Operating System: Docker for Mac
OSType: linux
Architecture: x86_64
CPUs: 4
Total Memory: 1.952GiB
Name: linuxkit-025000000001
ID: CNVU:5KZS:A2M7:WY5W:NUEW:KPW3:WXOA:IH2Q:EBAN:LP7C:3EQR:36U4
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): true
 File Descriptors: 24
 Goroutines: 50
 System Time: 2019-03-27T06:19:11.1044801Z
 EventsListeners: 2
HTTP Proxy: gateway.docker.internal:3128
HTTPS Proxy: gateway.docker.internal:3129
Registry: https://index.docker.io/v1/
Labels:
Experimental: false
Insecure Registries:
 127.0.0.0/8
Live Restore Enabled: false
Product License: Community Engine
</code></pre>

<blockquote>
  <p>EOF</p>
</blockquote>

              </div>
              
              <div id="disqus_thread">
                <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
              </div>
              
            </div>
          </div>
        </div>
        <div class="col-md-4 hidden-xs">
          <div class="sidebar ">
  <h2>Recent Posts</h2>
  <ul>
    
    <li><a href="/2019/05/memcached-note/">Memcached Notes</a></li>
    
    <li><a href="/2019/05/golang-pipeline/">Golang Pipeline</a></li>
    
    <li><a href="/2019/05/envoy-note/">Envoy Notes</a></li>
    
    <li><a href="/2019/05/grpc-note/">gRPC Notes</a></li>
    
    <li><a href="/2019/04/kafka-note/">Kafka Notes</a></li>
    
  </ul>
</div>

<div class="sidebar">
  <h2>Categories</h2>
  <ul>
    
      <li><a href="/category/Linux">Linux</a></li>
    
      <li><a href="/category/Stress & Scaling">Stress & Scaling</a></li>
    
      <li><a href="/category/PHP">PHP</a></li>
    
      <li><a href="/category/IDE">IDE</a></li>
    
      <li><a href="/category/Wordpress">Wordpress</a></li>
    
      <li><a href="/category/SEO">SEO</a></li>
    
      <li><a href="/category/Version Control">Version Control</a></li>
    
      <li><a href="/category/HTML & CSS">HTML & CSS</a></li>
    
      <li><a href="/category/Trash">Trash</a></li>
    
      <li><a href="/category/Apache">Apache</a></li>
    
      <li><a href="/category/Memcache">Memcache</a></li>
    
      <li><a href="/category/Net Services">Net Services</a></li>
    
      <li><a href="/category/Java">Java</a></li>
    
      <li><a href="/category/MicroBlog">MicroBlog</a></li>
    
      <li><a href="/category/JavaScript">JavaScript</a></li>
    
      <li><a href="/category/DB">DB</a></li>
    
      <li><a href="/category/Something">Something</a></li>
    
      <li><a href="/category/Methodology & Thinking">Methodology & Thinking</a></li>
    
      <li><a href="/category/Redis">Redis</a></li>
    
      <li><a href="/category/Flash">Flash</a></li>
    
      <li><a href="/category/Thinking">Thinking</a></li>
    
      <li><a href="/category/Platform">Platform</a></li>
    
      <li><a href="/category/C _ C++">C / C++</a></li>
    
      <li><a href="/category/Dart">Dart</a></li>
    
      <li><a href="/category/Mobile">Mobile</a></li>
    
      <li><a href="/category/Video">Video</a></li>
    
      <li><a href="/category/Blog">Blog</a></li>
    
      <li><a href="/category/Politics">Politics</a></li>
    
      <li><a href="/category/V8Blog">V8Blog</a></li>
    
      <li><a href="/category/Docker">Docker</a></li>
    
      <li><a href="/category/Golang">Golang</a></li>
    
      <li><a href="/category/Career">Career</a></li>
    
      <li><a href="/category/Prometheus">Prometheus</a></li>
    
      <li><a href="/category/Grafana">Grafana</a></li>
    
      <li><a href="/category/Logging">Logging</a></li>
    
      <li><a href="/category/Jaeger">Jaeger</a></li>
    
      <li><a href="/category/Elasticsearch">Elasticsearch</a></li>
    
      <li><a href="/category/MessageQueue">MessageQueue</a></li>
    
      <li><a href="/category/Kafka">Kafka</a></li>
    
      <li><a href="/category/gRPC">gRPC</a></li>
    
      <li><a href="/category/Envoy">Envoy</a></li>
    
  </ul>
</div>

        </div>
      </div>
    </div>
    
<!-- Add Disqus comments. -->
<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = "xenojoshua"; // required: replace example with your forum shortname
  var disqus_identifier = "/2019/01/docker-note/";

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


  </div>
      <footer class="footer-distributed">
      <div class="container">
        <div class="footer">
          <p>Jonathan Dai &copy; 2019</p>
          <h6>Theme by <a href="https://github.com/streetturtle/jekyll-clean-dark" target="_blank">Pavel Makhov</a></h6>
          <h6>Follow me</h6>

<ul class="social-media">

  
    <li>
      <a title="agreatfool on Github" href="https://github.com/agreatfool" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    </li>
  

  

  

  

  

  
    <li>
      <a title="feed.xml RSS" href="https://xenojoshua.com/feed.xml" target="_blank"><i class="fa fa-rss fa-2x"></i></a>
    </li>
  

</ul>

        </div>
      </div>
    </footer>
  </body>
</html>

</div>
