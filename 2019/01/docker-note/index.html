<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Docker Notes | Xenojoshua</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://xenojoshua.com/js/jquery.min.js"></script>
  <script src="https://xenojoshua.com/js/bootstrap.min.js"></script>
  <script src="https://xenojoshua.com/js/header.js"></script>
  <script src="https://xenojoshua.com/js/toc.js"></script>
  <link href="https://xenojoshua.com//2019/01/docker-note/" rel="canonical" />
  <link href="https://xenojoshua.com/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://xenojoshua.com/css/theme.css" rel="stylesheet">
  <link href="https://xenojoshua.com/css/syntax.css" rel="stylesheet">
  <link href="https://xenojoshua.com/css/font-awesome/css/font-awesome.min.css" rel="stylesheet">
  <link href="https://xenojoshua.com/favicon.ico?" type="image/x-icon" rel="shortcut icon">
  <style>
    /* Enhance table style */
    table {
      border: 2px solid #4F7849;
      background-color: #EEEEEE;
      width: 100%;
      text-align: center;
      border-collapse: collapse;
    }
    table td, table.comicGreen th {
      border: 1px solid #4F7849;
      padding: 3px 5px;
    }
    table tbody td {
      font-size: 14px;
      color: #4F7849;
    }
    table tr:nth-child(even) {
      background: #CEE0CC;
    }
    table thead {
      background: #4F7849;
      border-bottom: 1px solid #444444;
    }
    table thead th {
      font-size: 16px;
      font-weight: bold;
      color: #FFFFFF;
      text-align: center;
      border-left: 2px solid #D0E4F5;
      padding: 3px 5px;
    }
    table thead th:first-child {
      border-left: none;
    }
    table tfoot td {
      font-size: 21px;
    }

    /* Enhance pre style */
    pre {
      color: #FFFFFF;
      background-color: #000000;
      border-color: #000000;
    }

    /* Keep gist style clean */
    .gist table tr:nth-child(even) {
      background: #FFFFFF;
    }
    .gist td, th {
      border: none;
    }
  </style>
</head>

<body>

  
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-11349149-4']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


  

 <script type="text/javascript">
   var host = "xenojoshua.com";
   if ((host == window.location.host) && (window.location.protocol != "https:"))
     window.location.protocol = "https";
 </script>
 <script type="text/javascript">
  WebFontConfig = {
    google: {
      families: ['Ubuntu::latin']
    }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="https://xenojoshua.com/">Xenojoshua</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="https://xenojoshua.com/">/home</a></li>
          <li><a href="https://xenojoshua.com/archive/">/archive</a></li>
          <li><a href="https://xenojoshua.com/categories/">/categories</a></li>
          <li><a href="https://xenojoshua.com/tags/">/tags</a></li>
          <li><a href="https://xenojoshua.com/feed.xml" target="_blank">/rss</a></li>
          <li><a href="https://xenojoshua.com/about/">/about</a></li>
        </ul>
      </div>
    </div>
  </nav>


<div class="wrapper">
  <div class="content">
    <div class="container container-center">
      <div class="row">
        <div class="col-md-8">
          <div class="article">
            <div class="well">
              <h1><a href="https://xenojoshua.com/2019/01/docker-note/">Docker Notes</a></h1>
              <div class="post-meta">
                <div class="post-time">
                  <i class="fa fa-calendar"></i>
                  <time>17 Jan 2019</time>
                </div>
                <ul>
                  
                    <li><a href="https://xenojoshua.com/tag/Docker">Docker</a></li>
                  
                    <li><a href="https://xenojoshua.com/tag/Keynote">Keynote</a></li>
                  
                </ul>
              </div>
              <div class="post-content">
                <h4>Table of Contents</h4>
<ul id="markdown-toc">
  <li><a href="#1-前言" id="markdown-toc-1-前言">1. 前言</a></li>
  <li><a href="#2-安装" id="markdown-toc-2-安装">2. 安装</a></li>
  <li><a href="#3-镜像仓库" id="markdown-toc-3-镜像仓库">3. 镜像仓库</a>    <ul>
      <li><a href="#31-创建镜像仓库" id="markdown-toc-31-创建镜像仓库">3.1 创建镜像仓库</a></li>
      <li><a href="#32-login" id="markdown-toc-32-login">3.2 login</a></li>
      <li><a href="#33-push--pull" id="markdown-toc-33-push--pull">3.3 push &amp; pull</a></li>
    </ul>
  </li>
  <li><a href="#4-日常使用" id="markdown-toc-4-日常使用">4. 日常使用</a>    <ul>
      <li><a href="#41-docker-images" id="markdown-toc-41-docker-images">4.1 docker images</a></li>
      <li><a href="#42-docker-rmi" id="markdown-toc-42-docker-rmi">4.2 docker rmi</a></li>
      <li><a href="#43-docker-ps--a" id="markdown-toc-43-docker-ps--a">4.3 docker ps -a</a></li>
      <li><a href="#44-docker-rm" id="markdown-toc-44-docker-rm">4.4 docker rm</a></li>
      <li><a href="#45-docker-build" id="markdown-toc-45-docker-build">4.5 docker build</a>        <ul>
          <li><a href="#451-镜像命名及tag" id="markdown-toc-451-镜像命名及tag">4.5.1 镜像命名及tag</a></li>
          <li><a href="#452-指定dockerfile" id="markdown-toc-452-指定dockerfile">4.5.2 指定Dockerfile</a></li>
          <li><a href="#453-指定全局变量" id="markdown-toc-453-指定全局变量">4.5.3 指定全局变量</a></li>
          <li><a href="#454-指定ulimit" id="markdown-toc-454-指定ulimit">4.5.4 指定ulimit</a></li>
          <li><a href="#455-指定父级cgroup" id="markdown-toc-455-指定父级cgroup">4.5.5 指定父级cgroup</a></li>
          <li><a href="#456-添加etchosts" id="markdown-toc-456-添加etchosts">4.5.6 添加/etc/hosts</a></li>
          <li><a href="#457-构建目标环境" id="markdown-toc-457-构建目标环境">4.5.7 构建目标环境</a></li>
          <li><a href="#458-其他" id="markdown-toc-458-其他">4.5.8 其他</a>            <ul>
              <li><a href="#资源限制相关会在后面的章节深入" id="markdown-toc-资源限制相关会在后面的章节深入">资源限制相关（会在后面的章节深入）</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#46-docker-run" id="markdown-toc-46-docker-run">4.6 docker run</a>        <ul>
          <li><a href="#461-后台进程" id="markdown-toc-461-后台进程">4.6.1 后台进程</a></li>
          <li><a href="#462-指定名称" id="markdown-toc-462-指定名称">4.6.2 指定名称</a></li>
          <li><a href="#463-网络设置" id="markdown-toc-463-网络设置">4.6.3 网络设置</a></li>
          <li><a href="#464-添加etchosts" id="markdown-toc-464-添加etchosts">4.6.4 添加/etc/hosts</a></li>
          <li><a href="#465-重启策略" id="markdown-toc-465-重启策略">4.6.5 重启策略</a></li>
          <li><a href="#466-退出代码-exit-status" id="markdown-toc-466-退出代码-exit-status">4.6.6 退出代码 Exit Status</a></li>
          <li><a href="#467-退出清理" id="markdown-toc-467-退出清理">4.6.7 退出清理</a></li>
          <li><a href="#468-安全选项" id="markdown-toc-468-安全选项">4.6.8 安全选项</a></li>
          <li><a href="#469-权限与linux-capabilities" id="markdown-toc-469-权限与linux-capabilities">4.6.9 权限与Linux Capabilities</a></li>
          <li><a href="#4610-日志输出" id="markdown-toc-4610-日志输出">4.6.10 日志输出</a></li>
          <li><a href="#4611-覆盖dockerfile设置" id="markdown-toc-4611-覆盖dockerfile设置">4.6.11 覆盖Dockerfile设置</a></li>
          <li><a href="#4612-其他" id="markdown-toc-4612-其他">4.6.12 其他</a>            <ul>
              <li><a href="#命令测试" id="markdown-toc-命令测试">命令测试</a></li>
              <li><a href="#隔离与共享" id="markdown-toc-隔离与共享">隔离与共享</a></li>
              <li><a href="#资源限制相关会在后面的章节深入-1" id="markdown-toc-资源限制相关会在后面的章节深入-1">资源限制相关（会在后面的章节深入）</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#47-docker-attach" id="markdown-toc-47-docker-attach">4.7 docker attach</a>        <ul>
          <li><a href="#471-attach" id="markdown-toc-471-attach">4.7.1 attach</a></li>
          <li><a href="#472-detach" id="markdown-toc-472-detach">4.7.2 detach</a></li>
        </ul>
      </li>
      <li><a href="#48-docker-exec" id="markdown-toc-48-docker-exec">4.8 docker exec</a></li>
      <li><a href="#49-tips" id="markdown-toc-49-tips">4.9 tips</a></li>
    </ul>
  </li>
  <li><a href="#5-dockerfile" id="markdown-toc-5-dockerfile">5. Dockerfile</a>    <ul>
      <li><a href="#ID_DOCKERFILE_RUN" id="markdown-toc-ID_DOCKERFILE_RUN">5.1 RUN</a></li>
      <li><a href="#52-cmd--entrypoint" id="markdown-toc-52-cmd--entrypoint">5.2 CMD &amp; ENTRYPOINT</a></li>
      <li><a href="#53-volume" id="markdown-toc-53-volume">5.3 VOLUME</a></li>
      <li><a href="#54-arg" id="markdown-toc-54-arg">5.4 ARG</a></li>
      <li><a href="#55-healthcheck" id="markdown-toc-55-healthcheck">5.5 HEALTHCHECK</a></li>
      <li><a href="#56-其他指令" id="markdown-toc-56-其他指令">5.6 其他指令</a></li>
    </ul>
  </li>
  <li><a href="#6-image" id="markdown-toc-6-image">6. Image</a></li>
  <li><a href="#7-multi-stage-builds" id="markdown-toc-7-multi-stage-builds">7. Multi Stage builds</a></li>
  <li><a href="#8-docker-machine" id="markdown-toc-8-docker-machine">8. Docker Machine</a></li>
  <li><a href="#9-原理" id="markdown-toc-9-原理">9. 原理</a>    <ul>
      <li><a href="#91-网络" id="markdown-toc-91-网络">9.1 网络</a></li>
      <li><a href="#ID_PRINCIPLE_STORAGE" id="markdown-toc-ID_PRINCIPLE_STORAGE">9.2 存储</a></li>
      <li><a href="#ID_PRINCIPLE_RESOURCE" id="markdown-toc-ID_PRINCIPLE_RESOURCE">9.3 资源限制</a></li>
      <li><a href="#94-监控--metrics" id="markdown-toc-94-监控--metrics">9.4 监控 &amp; Metrics</a></li>
      <li><a href="#95-安全" id="markdown-toc-95-安全">9.5 安全</a></li>
      <li><a href="#96-docker-inspect" id="markdown-toc-96-docker-inspect">9.6 docker inspect</a></li>
      <li><a href="#97-其他" id="markdown-toc-97-其他">9.7 其他</a>        <ul>
          <li><a href="#停止容器" id="markdown-toc-停止容器">停止容器</a></li>
          <li><a href="#记一次kubernetesdocker网络排障" id="markdown-toc-记一次kubernetesdocker网络排障">记一次KUBERNETES/DOCKER网络排障</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#10-os镜像选择" id="markdown-toc-10-os镜像选择">10. OS镜像选择</a>    <ul>
      <li><a href="#101-alpine" id="markdown-toc-101-alpine">10.1 Alpine</a>        <ul>
          <li><a href="#dns-issue" id="markdown-toc-dns-issue">DNS issue</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#11-其他" id="markdown-toc-11-其他">11. 其他</a>    <ul>
      <li><a href="#111-什么是docker-host" id="markdown-toc-111-什么是docker-host">11.1 什么是docker host</a></li>
    </ul>
  </li>
  <li><a href="#资料" id="markdown-toc-资料">资料</a>    <ul>
      <li><a href="#docker官方" id="markdown-toc-docker官方">Docker官方</a></li>
      <li><a href="#docker命令" id="markdown-toc-docker命令">Docker命令</a></li>
      <li><a href="#镜像相关" id="markdown-toc-镜像相关">镜像相关</a></li>
      <li><a href="#其他" id="markdown-toc-其他">其他</a></li>
      <li><a href="#ID_APP_DOCKER_INFO" id="markdown-toc-ID_APP_DOCKER_INFO">docker info</a></li>
    </ul>
  </li>
</ul>

<h1 id="1-前言">1. 前言</h1>
<p>云原生概念风生云起，最近算是非常火热，而其最基本的依仗就在于能将任何程序运行在轻量级Cell上的容器Docker。Docker如果仅只是使用的话，是一点都不难的，但作为一个所有应用程序运行其上的基石，对其的细节了解是非常有必要的。</p>

<p>本文会记录从最基本的Docker基础，到日常的工作操作，到比较深入的原理细节，都会有所涉及。</p>

<p>版本信息如下：</p>
<pre><code>$ docker version
Client: Docker Engine - Community
 Version:           18.09.2
 API version:       1.39
 Go version:        go1.10.8
 Git commit:        6247962
 Built:             Sun Feb 10 04:12:39 2019
 OS/Arch:           darwin/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          18.09.2
  API version:      1.39 (minimum version 1.12)
  Go version:       go1.10.6
  Git commit:       6247962
  Built:            Sun Feb 10 04:13:06 2019
  OS/Arch:          linux/amd64
  Experimental:     false
</code></pre>

<p>此外，<a href="#ID_APP_DOCKER_INFO">docker info</a>比较长，就不贴这里了，放在下面的资料部分。简单看了下应该是不带敏感信息的，这部分应该是做了剔除的。</p>

<h1 id="2-安装">2. 安装</h1>
<p>MAC下的安装比较简单，直接下载Docker官方的桌面版本即可：<a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank">Docker Desktop for Mac</a>。文档在：<a href="https://docs.docker.com/docker-for-mac/" target="_blank">Get started with Docker Desktop for Mac</a>。</p>

<p>此外，为了能使用（下载）一些官方（软件公司）发布镜像文件，你需要注册一个docker hub账号（其实也就是docker官方账号）：<a href="https://hub.docker.com" target="_blank">docker hub</a>。</p>

<h1 id="3-镜像仓库">3. 镜像仓库</h1>
<p>Docker的核心功能点之一就是能将部署这个事情代码化。本来运维的工作中充斥着各种不确定性，版本不兼容、软件包不同、Linux内核不同导致的安装问题，等等。而Docker可以使用Dockerfile将一个镜像的制作（以代码形式）固定下来，保证只要是一份Dockerfile，制作出来的镜像是完全一致的。</p>

<p>此外，只要保证Docker的版本一致，docker镜像的运行状态及结果是可预期的。这就保证了一个软件的研发流程中，只要镜像被制作完成了，后续就可以使用这个镜像文件进行分发了，不再需要每个部署环境都从Dockerfile从头开始制作一份本地的镜像。</p>

<p>而分发这个过程就需要镜像仓库的介入：本地制作镜像 =&gt; 上传镜像到仓库 =&gt; 部署服务器拉取镜像 =&gt; 部署服务器本地运行镜像。</p>

<p>Docker官方有一个开放的<a href="https://hub.docker.com" target="_blank">镜像仓库</a>，一般知名的第三方软件提供者都会将自己软件的镜像文件发布到这个开放的仓库中，方便第三方使用者下载。当然，私有仓库对于大部分软件公司来说都是必须的。</p>

<h2 id="31-创建镜像仓库">3.1 创建镜像仓库</h2>
<p>制作一个私有的镜像仓库非常简单，直接使用docker命令即可，官方文档在：<a href="https://docs.docker.com/registry/" target="_blank">Docker Registry</a>。</p>

<p>运行：</p>
<pre><code>docker run -d -p 5000:5000 --name registry registry:2
</code></pre>

<p>这样就在<code>localhost:5000</code>运行了一个镜像仓库。</p>

<h2 id="32-login">3.2 login</h2>
<p>从镜像仓库获得镜像以及上传镜像都需要有对应的身份认证。使用：</p>

<pre><code>$ docker login --help

Usage:	docker login [OPTIONS] [SERVER]

Log in to a Docker registry

Options:
  -p, --password string   Password
      --password-stdin    Take the password from stdin
  -u, --username string   Username
</code></pre>

<p>即便是从官方镜像仓库获取镜像也是需要认证的，所以一开始需要注册一个账号。如果使用的是Docker Desktop的话，可以从UI界面上进行登录。</p>

<p>如果登录的是私有仓库，<code>[SERVER]</code>这块需要输入私有仓库地址。</p>

<h2 id="33-push--pull">3.3 push &amp; pull</h2>
<p>如果是从私有仓库上进行对应的拉取和推送镜像，需要在镜像名字之前补完仓库地址：</p>

<pre><code>docker push localhost:5000/imagename:major.minor.patch
docker pull localhost:5000/imagename:major.minor.patch
</code></pre>

<h1 id="4-日常使用">4. 日常使用</h1>
<h2 id="41-docker-images">4.1 docker images</h2>
<p>显示所有镜像（本地）</p>
<pre><code>$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              18.10               b977ae81df17        2 weeks ago         73.9MB
</code></pre>

<h2 id="42-docker-rmi">4.2 docker rmi</h2>
<p>删除镜像，可以同时删除多个，给的名字可以是镜像名也可以是镜像id</p>
<pre><code>$ docker rmi imagename imageid ...
</code></pre>

<h2 id="43-docker-ps--a">4.3 docker ps -a</h2>
<p>可以显示所有的容器（本地），包括不在运行状态的。<code>-a</code>一般来说是必须的，否则无法将停止状态的镜像也列出来。</p>
<pre><code>$ docker ps -a
</code></pre>

<h2 id="44-docker-rm">4.4 docker rm</h2>
<p>删除容器，可以同时删除多个，给的名字可以是容器名也可以是容器id</p>
<pre><code>$ docker rm containername containerid ...
</code></pre>

<h2 id="45-docker-build">4.5 docker build</h2>
<p>从一个Dockerfile构建一个镜像，一般都会进入到Dockerfile同一层目录进行构建：<code>docker build [OPTIONS] .</code>，这里的<code>.</code>就是Dockerfile的路径。全选项参数可以通过：<code>docker build --help</code>来获得，这里就不贴了。</p>

<p>细节相当多，有需要的可以看下官方文档：<a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank">docker build</a>。</p>

<h3 id="451-镜像命名及tag">4.5.1 镜像命名及tag</h3>
<p>通过<code>-t</code>在构建的时候对镜像进行命名，并打上标签。一般来说这是必须的，方便后续进行镜像查找和仓库内巨量镜像的维护。</p>
<pre><code>$ docker build -t imagename:major.minor.patch .
</code></pre>

<h3 id="452-指定dockerfile">4.5.2 指定Dockerfile</h3>
<p>通过<code>-f</code>指定镜像文件路径。</p>
<pre><code>$ docker build -f yourrepo/Dockerfile .
</code></pre>

<h3 id="453-指定全局变量">4.5.3 指定全局变量</h3>
<p>在构建镜像的时候为了对内部的应用程序提供一些配置，常用环境变量的方式进行注入，而在镜像构建的时候，可以使用<code>--build-args XXX=...</code>这样的方式进行操作。</p>
<pre><code>$ docker build --build-arg HTTP_PROXY=http://10.20.30.2:1234 --build-arg FTP_PROXY=http://40.50.60.5:4567 .
</code></pre>

<p>如果是裸用Docker的话，这样的操作还算是比较容易理解的，但一般来说大型分布系统肯定还使用了K8S这样的容器管理系统或者还甚至用了类似于Istio这样的服务编排系统，就不需要在制作镜像的时候这么弄了。</p>

<h3 id="454-指定ulimit">4.5.4 指定ulimit</h3>
<p>通过<code>--ulimit</code>来指定该镜像文件在运行时候的ulimit。</p>

<h3 id="455-指定父级cgroup">4.5.5 指定父级cgroup</h3>
<p>通过<code>--cgroup-parent</code>来指定该镜像文件在运行时候的资源限制群组。关于cgroup这个话题，后面会专门起一个章节来深入。详见：<a href="#ID_PRINCIPLE_RESOURCE">8.3 资源限制</a>。</p>

<h3 id="456-添加etchosts">4.5.6 添加/etc/hosts</h3>
<p>通过<code>--add-host=domain.com:10.180.0.1</code>来向/etc/hosts里添加匹配。</p>

<h3 id="457-构建目标环境">4.5.7 构建目标环境</h3>
<p>通过<code>--target</code>来指定构建的目标环境：</p>

<pre><code>FROM debian AS build-env
...

FROM alpine AS production-env
...
</code></pre>

<pre><code>$ docker build -t mybuildimage --target build-env .
</code></pre>

<h3 id="458-其他">4.5.8 其他</h3>
<ul>
  <li><code>--no-cache</code>：在构建镜像的时候不使用cache，在频繁更新某个镜像时很有用，防止cache污染</li>
  <li><code>--ssh</code>：SSH agent socket or keys to expose to the build (only if BuildKit enabled) (format: default|[=|[,]])</li>
</ul>

<h4 id="资源限制相关会在后面的章节深入">资源限制相关（会在后面的章节深入）</h4>
<ul>
  <li><code>--cpu-period</code>：Limit the CPU CFS (Completely Fair Scheduler) period</li>
  <li><code>--cpu-quota</code>：Limit the CPU CFS (Completely Fair Scheduler) quota</li>
  <li><code>--cpu-shares</code>：CPU shares (relative weight)</li>
  <li><code>--cpuset-cpus</code>：CPUs in which to allow execution (0-3, 0,1)</li>
  <li><code>--cpuset-mems</code>：MEMs in which to allow execution (0-3, 0,1)</li>
  <li><code>--memory</code>：Memory limit</li>
  <li><code>--memory-swap</code>：Swap limit equal to memory plus swap: ‘-1’ to enable unlimited swap</li>
</ul>

<p>详见：<a href="#ID_PRINCIPLE_RESOURCE">8.3 资源限制</a>。</p>

<h2 id="46-docker-run">4.6 docker run</h2>
<p>将镜像运行成容器的命令，虽然是一个很简单的命令，但细节相当多，用起来其实还蛮麻烦的。全选项参数可以通过：<code>docker run --help</code>来获得，这里就不贴了。中文的帖子也有，可以看了参考：<a href="https://www.jianshu.com/p/ea4a00c6c21c" target="_blank">Docker run 命令参数及使用</a></p>

<p>细节相当多，有需要的可以看下官方文档：<a href="https://docs.docker.com/engine/reference/run/" target="_blank">docker run</a>。</p>

<p>命令的基本使用格式：</p>

<pre><code>$ docker run [OPTIONS] IMAGE[:TAG\|@DIGEST] [COMMAND] [ARG...]
</code></pre>

<h3 id="461-后台进程">4.6.1 后台进程</h3>
<p>通过<code>-d</code>来让docker run命令运行起来的容器转为后台常驻进程。</p>

<pre><code>$ docker run -d -p 80:80 my_image service nginx start
</code></pre>

<h3 id="462-指定名称">4.6.2 指定名称</h3>
<p>通过<code>--name</code>来让docker run命名运行起来的容器，后续可以使用这个名字来访问这个启动的容器，不再需要<code>docker ps -a</code>查找这个容器的UUID。在使用同一个镜像启动多个容器的时候特别有用。</p>

<pre><code>$ docker run --name myconname -d ubuntu:18.10
</code></pre>

<h3 id="463-网络设置">4.6.3 网络设置</h3>
<p>网络这块相关的配置内容也非常多，细节的内容建议直接阅读官方的文档：<a href="https://docs.docker.com/engine/reference/run/#network-settings" target="_blank">docker run &gt; Network settings</a>。</p>

<p><code>--network=...</code>用来控制网络模式：</p>

<ul>
  <li><code>none</code>：No networking in the container.</li>
  <li><code>bridge (default)</code>：Connect the container to the bridge via veth interfaces.</li>
  <li><code>host</code>：Use the host’s network stack inside the container.</li>
  <li><code>container:&lt;name\|id&gt;</code>：Use the network stack of another container, specified via its name or id.</li>
  <li><code>NETWORK</code>：Connects the container to a user created network (using docker network create command)</li>
</ul>

<h3 id="464-添加etchosts">4.6.4 添加/etc/hosts</h3>
<p>参数同docker build命令，但很奇怪的是docker官方给出的例子这里倒是没有<code>=</code>：</p>

<pre><code>$ docker run -it --add-host domain.com:10.180.0.1 ubuntu cat /etc/hosts
</code></pre>

<h3 id="465-重启策略">4.6.5 重启策略</h3>
<p>通过<code>--restart</code>可以让docker run启动的容器在退出之后按策略重启。官方文档在：<a href="https://docs.docker.com/engine/reference/run/#restart-policies---restart" target="_blank">docker run &gt; Restart policies (–restart)</a>。</p>

<ul>
  <li><code>no</code>：Do not automatically restart the container when it exits. This is the default.</li>
  <li><code>on-failure[:max-retries]</code>：Restart only if the container exits with a non-zero exit status. Optionally, limit the number of restart retries the Docker daemon attempts.</li>
  <li><code>always</code>：Always restart the container regardless of the exit status. When you specify always, the Docker daemon will try to restart the container indefinitely. The container will also always start on daemon startup, regardless of the current state of the container.</li>
  <li><code>unless-stopped</code>：Always restart the container regardless of the exit status, including on daemon startup, except if the container was put into a stopped state before the Docker daemon was stopped.</li>
</ul>

<p>该选项与<code>--rm</code>是冲突的。</p>

<h3 id="466-退出代码-exit-status">4.6.6 退出代码 Exit Status</h3>
<p>接上面的重试策略，<code>on-failure</code>会检查退出代码。官方文档在：<a href="https://docs.docker.com/engine/reference/run/#exit-status" target="_blank">docker run &gt; Exit Status</a>。</p>

<h3 id="467-退出清理">4.6.7 退出清理</h3>
<p>通过<code>--rm</code>可以让docker run启动的容器在退出之后删除所有的留存信息。如果没有加这个参数的话，在容器退出、停止之后使用<code>docker ps -a</code>可以找到刚才启动的容器。这对于测试来说是很麻烦的，每次停止之后还要使用<code>docker rm</code>命令删除。这时候就可以通过<code>--rm</code>来命令容器退出后自动清理：</p>

<pre><code># not cleanup
$ docker run -i -t ubuntu:18.10 ps afx
$ docker ps -a

# cleanup
$ docker run -i -t --rm ubuntu:18.10 ps afx
$ docker ps -a
</code></pre>

<h3 id="468-安全选项">4.6.8 安全选项</h3>
<p>参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#security-configuration" target="_blank">docker run &gt; Security configuration</a>。</p>

<h3 id="469-权限与linux-capabilities">4.6.9 权限与Linux Capabilities</h3>
<p>参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities" target="_blank">docker run &gt; Runtime privilege and Linux capabilities</a>。后续详见：<a href="#ID_PRINCIPLE_RESOURCE">8.3 资源限制</a>。</p>

<h3 id="4610-日志输出">4.6.10 日志输出</h3>
<p>通过<code>--log-driver</code>容器可以指定和docker daemon不同的日志输出设备。参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#logging-drivers---log-driver" target="_blank">Logging drivers (–log-driver)</a>。</p>

<h3 id="4611-覆盖dockerfile设置">4.6.11 覆盖Dockerfile设置</h3>
<p>主要是以下几项：</p>

<ul>
  <li>CMD (Default Command or Options)</li>
  <li>ENTRYPOINT (Default Command to Execute at Runtime)</li>
  <li>EXPOSE (Incoming Ports)</li>
  <li>ENV (Environment Variables)</li>
  <li>HEALTHCHECK</li>
  <li>VOLUME (Shared Filesystems)</li>
  <li>USER</li>
  <li>WORKDIR</li>
</ul>

<p>细节参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#overriding-dockerfile-image-defaults" target="_blank">Overriding Dockerfile image defaults</a>。</p>

<h3 id="4612-其他">4.6.12 其他</h3>
<h4 id="命令测试">命令测试</h4>
<p>使用如下命令可以启动容器之后执行命令进行测试，并在退出之后自动清理刚才生成的容器。</p>

<pre><code>$ docker run --rm -i -t $image_name:$version $command
</code></pre>

<h4 id="隔离与共享">隔离与共享</h4>

<ul>
  <li>–pid</li>
  <li>–uts</li>
  <li>–ipc</li>
</ul>

<p>容器之间拥有自己的PID命名空间，并相互隔离。通过<code>--pid=...</code>可以让容器之间共享进程。具体的例子可以直接阅读官方的文档：<a href="https://docs.docker.com/engine/reference/run/#pid-settings---pid" target="_blank">PID settings (–pid)</a>。</p>

<p>简单的例子可以尝试（看下输出的内容有什么不同）：</p>
<pre><code># without pid
$ docker run -i -t --rm ubuntu:18.10 ps afx
...

# with pid
$ docker run -i -t --rm --pid=host ubuntu:18.10 ps afx
...
</code></pre>

<p><code>--uts</code>和<code>--ipc</code>也是类似的，可以参考官方文档里的：<a href="https://docs.docker.com/engine/reference/run/#uts-settings---uts" target="_blank">UTS settings (–uts)</a>和<a href="https://docs.docker.com/engine/reference/run/#ipc-settings---ipc" target="_blank">IPC settings (–ipc)</a>。中文资料可以看：<a href="https://www.centos.bz/2017/01/docker-run-uts-ipc/" target="_blank">Docker run参考(5) – UTS(–uts)和IPC (–ipc)设置</a>。</p>

<h4 id="资源限制相关会在后面的章节深入-1">资源限制相关（会在后面的章节深入）</h4>
<p>参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#runtime-constraints-on-resources" target="_blank">docker run &gt; Runtime constraints on resources</a>。后续详见：<a href="#ID_PRINCIPLE_RESOURCE">8.3 资源限制</a>。</p>

<h2 id="47-docker-attach">4.7 docker attach</h2>
<h3 id="471-attach">4.7.1 attach</h3>
<p>将本地的输入输出及错误流附到一个运行中的容器上。简单来说可以理解为：进入到容器的命令行中。</p>

<p>如果需要在一个容器启动之后连上去的话，需要容器在启动（<code>docker run</code>）的时候指定：<code>-i -t</code>参数：</p>

<pre><code>$ docker run -i -t -d --rm ubuntu:18.10
</code></pre>

<p>这样就可以在之后使用<code>docker attach</code>命令附到该容器上并打开命令行了：</p>

<pre><code>$ docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS
80172e3d5574        ubuntu:18.10        "/bin/bash"         38 seconds ago      Up 37 seconds

$ docker attach 80172e3d5574
root@80172e3d5574:/#
</code></pre>

<h3 id="472-detach">4.7.2 detach</h3>
<p>新手常犯的一个错误就是使用<code>exit</code>命令退出附上的shell，结果就是非但退出了shell还把容器本身给stop了。正确的做法是在shell里<code>ctrl+p</code>然后<code>ctrl+q</code>，这里切记是先按p的组合键，然后按q的组合键，而不是同时<code>ctrl+p+q</code>。</p>

<pre><code>$ docker attach f269e680ae14
root@f269e680ae14:/# 
# ctrl+p &amp; ctrl+q
root@f269e680ae14:/# read escape sequence
$ 
</code></pre>

<p>资料：</p>

<ul>
  <li><a href="https://stackoverflow.com/a/19689048" target="_blank">How do you attach and detach from Docker’s process?</a></li>
</ul>

<h2 id="48-docker-exec">4.8 docker exec</h2>
<p>在一个已经处于<code>运行中</code>状态的容器里执行一条命令。</p>

<p>一般来说，如果是有连续工作的话，还是会使用<code>docker attach</code>附上去之后再操作。但如果仅只是一两句命令，或自动化的脚本，就需要使用到<code>docker exec</code>了。这里需要注意，exec只能用在running的容器上，如果没有容器且需要执行命令测试的话，也可以使用<code>docker run</code>命令，直接附带上需要执行的命令即可。</p>

<p>也有有趣的用法：</p>
<pre><code>docker exec -it e8c541f9fb33 /bin/bash
</code></pre>
<p>这条语句的效果和<code>docker attach</code>是一致的。</p>

<h2 id="49-tips">4.9 tips</h2>
<ul>
  <li>做开发的时候可以把镜像构建多包几层，一层层做成镜像存在本地。后面的build可以直接from前面的，节约docker build失败之后的重新测试时间。否则中间一个步骤出错，很多耗时很长的源码编译工作就要从头来一次，太伤</li>
  <li>node.js docker里的npm安装记得要加上<code>--unsafe-perm</code>，具体可以看：<a href="https://github.com/grpc/grpc-node/issues/604" target="_blank">grpc/grpc-node#604</a></li>
</ul>

<h1 id="5-dockerfile">5. Dockerfile</h1>
<p>Dockerfile是用来进行镜像构建的文本文件，也是docker能将构建整个过程转化为文本固定下来的关键，可以说是docker能如此风靡的核心功能点也不为过。</p>

<p>官方的文档：</p>

<ul>
  <li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank">Dockerfile reference</a></li>
  <li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank">Best practices for writing Dockerfiles</a></li>
</ul>

<p>下面行文不会过于注重Dockerfile如何编写的语法，因为这东西你看看手册和几个例子也就会了。主要还是关注在几个比较麻烦的概念上。</p>

<p>几点零碎的：</p>

<ul>
  <li>Dockerfile里类似<code>COPY</code>、<code>EXPOSE</code>之类的，都被称为指令（instruction），这个单词可以了解下</li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" target="_blank">.dockerignore file</a></li>
  <li>因为在build命令执行之前，当前指定PATH的context会被发送给docker daemon，因此文件夹越小执行越效率</li>
</ul>

<h2 id="ID_DOCKERFILE_RUN">5.1 RUN</h2>
<p>官方文档：<a href="https://docs.docker.com/engine/reference/builder/#run" target="_blank">RUN</a>。</p>

<p>运行指令，有两种语法模式：</p>

<ul>
  <li>RUN <command /> (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)</li>
  <li>RUN [“executable”, “param1”, “param2”] (exec form)</li>
</ul>

<p>这里需要注意<code>exec模式</code>并不是在shell里运行的：</p>

<blockquote>
  <p>Note: Unlike the shell form, the exec form does not invoke a command shell. This means that normal shell processing does not happen. For example, RUN [ “echo”, “$HOME” ] will not do variable substitution on $HOME. If you want shell processing then either use the shell form or execute a shell directly, for example: RUN [ “sh”, “-c”, “echo $HOME” ]. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker.</p>
</blockquote>

<p>建议是使用<code>exec模式</code>，细节可以看下面一个小节。</p>

<h2 id="52-cmd--entrypoint">5.2 CMD &amp; ENTRYPOINT</h2>
<p>官方文档：</p>

<ul>
  <li><a href="https://docs.docker.com/engine/reference/builder/#run" target="_blank">CMD</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank">ENTRYPOINT</a></li>
</ul>

<p>这两个东西可以放在一起说，因为他们做的事情基本上是类似的。两者都是在容器启动之后执行一个命令，CMD提供的是在镜像启动后会默认执行的一个命令，而ENTRYPOINT则是在镜像启动后提供一个程序入口。</p>

<p>区别在于：</p>

<ul>
  <li>CMD：提供的默认执行命令可以在<code>docker run $imagename $command</code>后面接命令进行覆盖，这样操作的话写在Dockerfile CMD里的命令就不会执行了，被替代了；CMD在一个Dockerfile里只能有一个生效，如果编写了多个则只有最后的那个会被执行</li>
  <li>ENTRYPOINT：提供的是镜像的<code>功能入口</code>，不会被<code>docker run $imagename $command</code>中的命令替换掉，除非指定<code>--entrypoint=...</code>进行替换；当然ENTRYPOINT也只允许有一个</li>
</ul>

<p>一般来说通常的做法是：ENTRYPOINT提供容器运行之后程序入口，而CMD则提供供给给程序入口的参数，方便后续在docker run的时候进行替换。这两者以这样的方式进行协同工作。</p>

<p>官方文档里也有这部分内容：<a href="https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact" target="_blank">Understand how CMD and ENTRYPOINT interact</a>。</p>

<ul>
  <li>Dockerfile should specify at least one of <code>CMD</code> or <code>ENTRYPOINT</code> commands.</li>
  <li><code>ENTRYPOINT</code> should be defined when using the container as an executable.</li>
  <li><code>CMD</code> should be used as a way of defining default arguments for an <code>ENTRYPOINT</code> command or for executing an ad-hoc command in a container.</li>
  <li><code>CMD</code> will be overridden when running the container with alternative arguments.</li>
</ul>

<p>这两个指令和<a href="#ID_DOCKERFILE_RUN">5.2 RUN</a>一样，都有多种模式可以选择，一般来说最常使用的是直接写命令的<code>shell模式</code>以及使用JSON格式编写的<code>exec模式</code>。最佳实践是：在所有的情况下都使用<code>exec模式</code>。原因如下：</p>

<ul>
  <li>shell模式的PID 1进程是<code>/bin/sh</code>，后续的信号不能很好传递到真正执行的命令上</li>
  <li>shell模式依赖<code>/bin/sh</code>，但某些微型镜像不一定有</li>
</ul>

<p>CMD指令还多一种模式：<code>CMD ["param1","param2"] (as default parameters to ENTRYPOINT)</code>，这也是刚才提到的参数提供者角色的做法。</p>

<p>e.g</p>

<pre><code>FROM ubuntu:trusty
ENTRYPOINT ["/bin/ping","-c","3"]
CMD ["localhost"]

$ docker run ping
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.025 ms
...

$ docker run ping docker.io
PING docker.io (162.242.195.84) 56(84) bytes of data.
64 bytes from 162.242.195.84: icmp_seq=1 ttl=61 time=76.7 ms
...
</code></pre>

<p>资料：</p>

<ul>
  <li><a href="https://zhuanlan.zhihu.com/p/30555962" target="_blank">Dockerfile: ENTRYPOINT和CMD的区别</a></li>
  <li><a href="https://medium.freecodecamp.org/docker-entrypoint-cmd-dockerfile-best-practices-abc591c30e21" target="_blank">Docker ENTRYPOINT &amp; CMD: Dockerfile best practices</a></li>
</ul>

<p>有时间的话，官方的ENTRYPOINT文档可以通读一下：<a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank">Dockerfile &gt; ENTRYPOINT</a>，里面信息量不小。</p>

<h2 id="53-volume">5.3 VOLUME</h2>
<p>官方文档：<a href="https://docs.docker.com/engine/reference/builder/#volume" target="_blank">VOLUME</a>。</p>

<p>卷加载相关在docker里是一个比较麻烦的概念，这里不作展开，只列出文档里提到的注意点：</p>

<ul>
  <li><code>Changing the volume from within the Dockerfile</code>: If any build steps change the data within the volume after it has been declared, those changes will be discarded.</li>
  <li><code>The host directory is declared at container run-time</code>: The host directory (the mountpoint) is, by its nature, host-dependent. This is to preserve image portability, since a given host directory can’t be guaranteed to be available on all hosts. For this reason, you can’t mount a host directory from within the Dockerfile. The <code>VOLUME</code> instruction does not support specifying a <code>host-dir</code> parameter. You must specify the mountpoint when you create or run the container.</li>
</ul>

<p>更多的深入理解可以查看：<a href="#ID_PRINCIPLE_STORAGE">9.2 存储</a>。</p>

<h2 id="54-arg">5.4 ARG</h2>
<p>官方文档：<a href="https://docs.docker.com/engine/reference/builder/#arg" target="_blank">ARG</a>。</p>

<p>除了用户定义的变量之外，docker还有一部分预定义的变量，可以通过<code>docker build --build-arg name=value</code>来加入：<a href="https://docs.docker.com/engine/reference/builder/#predefined-args" target="_blank">Predefined ARGs</a>。</p>

<ul>
  <li>HTTP_PROXY</li>
  <li>http_proxy</li>
  <li>HTTPS_PROXY</li>
  <li>https_proxy</li>
  <li>FTP_PROXY</li>
  <li>ftp_proxy</li>
  <li>NO_PROXY</li>
  <li>no_proxy</li>
</ul>

<h2 id="55-healthcheck">5.5 HEALTHCHECK</h2>
<p>官方文档：<a href="https://docs.docker.com/engine/reference/builder/#healthcheck" target="_blank">HEALTHCHECK</a>。</p>

<p>类似于客户端服务器保持连接的心跳检查的概念，这个指令是用来检查当前的容器其提供的服务是否正常的。</p>

<p>用法：<code>HEALTHCHECK [OPTIONS] CMD command</code>。CMD之前的选项有：</p>

<ul>
  <li>–interval=DURATION (default: 30s)</li>
  <li>–timeout=DURATION (default: 30s)</li>
  <li>–start-period=DURATION (default: 0s)</li>
  <li>–retries=N (default: 3)</li>
</ul>

<p>范例，每5分钟检查一次WEB服务器是否正常工作（3秒内能响应请求）：</p>
<pre><code>HEALTHCHECK --interval=5m --timeout=3s \\
  CMD curl -f http://localhost/ \|\| exit 1
</code></pre>

<p>退出代码：</p>

<ul>
  <li>0: success - the container is healthy and ready for use</li>
  <li>1: unhealthy - the container is not working correctly</li>
  <li>2: reserved - do not use this exit code</li>
</ul>

<p>同样细节比较多，可以仔细阅读下官方文档：<a href="https://docs.docker.com/engine/reference/builder/#healthcheck" target="_blank">Dockerfile &gt; HEALTHCHECK</a>。</p>

<p>资料：</p>

<ul>
  <li><a href="https://howchoo.com/g/zwjhogrkywe/how-to-add-a-health-check-to-your-docker-container" target="_blank">How to add a health check to your Docker container</a></li>
</ul>

<h2 id="56-其他指令">5.6 其他指令</h2>
<p>有相当多的指令在本文中并没有展开，可以查看其官方文档：</p>

<ul>
  <li><a href="https://docs.docker.com/engine/reference/builder/#from" target="_blank">FROM</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#label" target="_blank">LABEL</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#expose" target="_blank">EXPOSE</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#env" target="_blank">ENV</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#add" target="_blank">ADD</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#copy" target="_blank">COPY</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#user" target="_blank">USER</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#workdir" target="_blank">WORKDIR</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#onbuild" target="_blank">ONBUILD</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#stopsignal" target="_blank">STOPSIGNAL</a></li>
  <li><a href="https://docs.docker.com/engine/reference/builder/#shell" target="_blank">SHELL</a></li>
</ul>

<h1 id="6-image">6. Image</h1>
<p>// TODO
<a href="https://cameronlonsdale.com/2018/11/26/whats-in-a-docker-image/" target="_blank">What’s in a Docker image?</a>
<a href="https://stackoverflow.com/questions/31222377/what-are-docker-image-layers" target="_blank">What are Docker image “layers”?</a>
<a href="https://forums.docker.com/t/do-number-of-layers-in-an-image-affect-the-runtime-performance/43119" target="_blank">Do number of layers (in an image) affect the runtime performance?</a>
<a href="https://medium.com/@jessgreb01/digging-into-docker-layers-c22f948ed612" target="_blank">Digging into Docker layers</a></p>

<h1 id="7-multi-stage-builds">7. Multi Stage builds</h1>
<p>// TODO
将多个docker镜像组装成一个：<a href="https://docs.docker.com/develop/develop-images/multistage-build/" target="_blank">Use multi-stage builds</a></p>

<h1 id="8-docker-machine">8. Docker Machine</h1>
<p>// TODO
<a href="https://juejin.im/entry/5b3df2b4f265da0f6e5156de" target="_blank">docker-machine</a></p>

<h1 id="9-原理">9. 原理</h1>
<p>// TODO
<a href="https://docs.docker.com/engine/docker-overview/" target="_blank">docker overview</a></p>

<h2 id="91-网络">9.1 网络</h2>
<p>// TODO
<a href="https://docs.docker.com/network/" target="_blank">docker network overview</a>
<a href="http://dockone.io/article/1261" target="_blank">Docker网络模式 2016-05-02</a></p>

<h2 id="ID_PRINCIPLE_STORAGE">9.2 存储</h2>
<p>// TODO
<a href="https://docs.docker.com/storage/" target="_blank">docker storage</a>
<a href="https://docs.docker.com/storage/volumes/" target="_blank">Use volumes</a>
<a href="https://stackoverflow.com/questions/40163036/difference-between-volume-declaration-in-dockerfile-and-v-as-docker-run-paramet" target="_blank">Difference between VOLUME declaration in Dockerfile and -v as docker run parameter</a>
<a href="https://docs.docker.com/storage/storagedriver/aufs-driver/" target="_blank">Use the AUFS storage driver</a>
<a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank">Use the OverlayFS storage driver</a>
<a href="https://docs.docker.com/storage/storagedriver/device-mapper-driver/" target="_blank">Use the Device Mapper storage driver</a>
<a href="https://coolshell.cn/articles/17061.html" target="_blank">DOCKER基础技术：AUFS</a>
<a href="https://coolshell.cn/articles/17200.html" target="_blank">DOCKER基础技术：DEVICEMAPPER</a>
<a href="https://container-solutions.com/understanding-volumes-docker/" target="_blank">Understanding Volumes in Docker</a></p>

<h2 id="ID_PRINCIPLE_RESOURCE">9.3 资源限制</h2>
<p>// TODO
<a href="https://docs.docker.com/engine/reference/run/#runtime-constraints-on-resources" target="_blank">docker run &gt; Runtime constraints on resources</a>
<a href="https://docs.docker.com/config/containers/resource_constraints/" target="_blank">Limit a container’s resources</a>
<a href="http://cizixs.com/2017/08/25/linux-cgroup/" target="_blank">docker 容器基础技术：linux cgroup 简介</a>
<a href="https://infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank">Docker 背后的内核知识——cgroups 资源限制</a>
<a href="https://medium.com/@asishrs/docker-limit-resource-utilization-using-cgroup-parent-72a646651f9d" target="_blank">Docker limit resource utilization using cgroup-parent</a>
<a href="https://medium.com/@kasunmaduraeng/docker-namespace-and-cgroups-dece27c209c7" target="_blank">Docker Namespace and Cgroups</a>
<a href="https://my.oschina.net/HardySimpson/blog/868186" target="_blank">cgroup, docker,和kubernetes</a>
<a href="https://www.cnblogs.com/sammyliu/p/5886833.html" target="_blank">理解Docker（4）：Docker 容器使用 cgroups 限制资源使用</a>
<a href="https://coolshell.cn/articles/17010.html" target="_blank">DOCKER基础技术：LINUX NAMESPACE（上）</a>
<a href="https://coolshell.cn/articles/17029.html" target="_blank">DOCKER基础技术：LINUX NAMESPACE（下）</a>
<a href="https://coolshell.cn/articles/17049.html" target="_blank">DOCKER基础技术：LINUX CGROUP</a>
<a href="https://rk700.github.io/2016/10/26/linux-capabilities/" target="_blank">Linux的capabilities机制</a></p>

<h2 id="94-监控--metrics">9.4 监控 &amp; Metrics</h2>
<p>// TODO
<a href="https://docs.docker.com/config/containers/runmetrics/" target="_blank">Runtime metrics</a></p>

<h2 id="95-安全">9.5 安全</h2>
<p>// TODO
<a href="https://docs.docker.com/engine/security/security/" target="_blank">Docker security</a></p>

<h2 id="96-docker-inspect">9.6 docker inspect</h2>
<p>// TODO</p>

<h2 id="97-其他">9.7 其他</h2>
<h3 id="停止容器">停止容器</h3>
<p><a href="https://www.ctl.io/developers/blog/post/gracefully-stopping-docker-containers/" target="_blank">Gracefully Stopping Docker Containers</a>
// TODO</p>
<h3 id="记一次kubernetesdocker网络排障">记一次KUBERNETES/DOCKER网络排障</h3>
<p>// TODO
<a href="https://coolshell.cn/articles/18654.html" target="_blank">记一次KUBERNETES/DOCKER网络排障</a></p>

<h1 id="10-os镜像选择">10. OS镜像选择</h1>
<h2 id="101-alpine">10.1 Alpine</h2>
<p>技术过硬的话，Alpine应该说是制作生产环境产品镜像的首选了，毕竟体积摆在那边，只有几兆的基本镜像可真的没几个好选的。</p>

<ul>
  <li><a href="https://github.com/gliderlabs/docker-alpine" target="_blank">gliderlabs/docker-alpine</a>：官方项目</li>
  <li><a href="https://hub.docker.com/_/alpine" target="_blank">docker hub &gt; alpine</a>：官方镜像</li>
</ul>

<p>一些资料：</p>

<ul>
  <li><a href="https://github.com/gliderlabs/docker-alpine#why" target="_blank">gliderlabs/docker-alpine#Why?</a>：官方安利，主要的主张就是体积小+软件安装包全面</li>
  <li><a href="https://wiki.alpinelinux.org/wiki/Comparison_with_other_distros" target="_blank">Comparison with other distros</a>：一篇比较的wiki，不过这篇更倾向于使用上的比较，指导意义不大</li>
  <li><a href="https://nickjanetakis.com/blog/benchmarking-debian-vs-alpine-as-a-base-docker-image" target="_blank">Benchmarking Debian vs Alpine as a Base Docker Image</a>：这篇比较硬核，从具体的benchmark上进行了比较，非常值得一读</li>
  <li><a href="https://thenewstack.io/alpine-linux-heart-docker/" target="_blank">Meet Alpine Linux, Docker’s Distribution of Choice for Containers</a>：这是一篇安利文，讲的点比较全面，可以一读</li>
</ul>

<h3 id="dns-issue">DNS issue</h3>
<p>DNS问题算是Alpine被诟病得比较多的一点，可以看一个issue：<a href="https://github.com/gliderlabs/docker-alpine/issues/255" target="_blank">DNS Issue #255</a>。官方在github的文档上也给了说明，可以看下：<a href="https://github.com/gliderlabs/docker-alpine/blob/master/docs/caveats.md#dns" target="_blank">caveats.md » DNS</a>，当然具体是否有这个情况以及如何解决，就要看实践了。</p>

<h1 id="11-其他">11. 其他</h1>
<h2 id="111-什么是docker-host">11.1 什么是docker host</h2>
<p>在很多docker的文档里都提到了<code>docker host</code>这个概念。至于什么是docker host，可以参见链接：<a href="https://forums.docker.com/t/clarify-what-is-the-host/29640/2" target="_blank">Clarify what is the host</a>。</p>

<blockquote>
  <p>I think you pretty much found out the answer by yourself. In that diagram you mention a ‘docker host’ is any machine that is running the Docker daemon. This means that you’re either running Docker natively in your operating system, or a virtual machine that has Docker installed.</p>

  <p>Docker machine is basically the second option. When you do a docker-machine create it creates a new virtual machine with Docker already installed. This means that to access any containers running on this machine you’ll have to use the IP address of the virtual machine. Also, to give Docker access to a file you’ll either have to copy it to the VM that’s running Docker, or share a directory between your OS and the VM that’s running Docker.</p>
</blockquote>

<h1 id="资料">资料</h1>
<h2 id="docker官方">Docker官方</h2>
<ul>
  <li><a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank">Docker Desktop for Mac</a></li>
  <li><a href="https://docs.docker.com/docker-for-mac/" target="_blank">Get started with Docker Desktop for Mac</a></li>
  <li><a href="https://hub.docker.com" target="_blank">docker hub</a></li>
  <li><a href="https://docs.docker.com/registry/" target="_blank">Docker Registry</a></li>
  <li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank">Best practices for writing Dockerfiles</a></li>
</ul>

<h2 id="docker命令">Docker命令</h2>
<ul>
  <li><a href="https://www.jianshu.com/p/ea4a00c6c21c" target="_blank">Docker run 命令参数及使用</a></li>
  <li><a href="https://www.centos.bz/2017/01/docker-run-uts-ipc/" target="_blank">Docker run参考(5) – UTS(–uts)和IPC (–ipc)设置</a></li>
  <li><a href="https://stackoverflow.com/a/19689048" target="_blank">How do you attach and detach from Docker’s process?</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/30555962" target="_blank">Dockerfile: ENTRYPOINT和CMD的区别</a></li>
  <li><a href="https://medium.freecodecamp.org/docker-entrypoint-cmd-dockerfile-best-practices-abc591c30e21" target="_blank">Docker ENTRYPOINT &amp; CMD: Dockerfile best practices</a></li>
  <li><a href="https://howchoo.com/g/zwjhogrkywe/how-to-add-a-health-check-to-your-docker-container" target="_blank">How to add a health check to your Docker container</a></li>
</ul>

<h2 id="镜像相关">镜像相关</h2>
<ul>
  <li><a href="https://github.com/gliderlabs/docker-alpine" target="_blank">gliderlabs/docker-alpine</a></li>
  <li><a href="https://hub.docker.com/_/alpine" target="_blank">docker hub &gt; alpine</a></li>
  <li><a href="https://github.com/gliderlabs/docker-alpine#why" target="_blank">gliderlabs/docker-alpine#Why?</a></li>
  <li><a href="https://wiki.alpinelinux.org/wiki/Comparison_with_other_distros" target="_blank">Comparison with other distros</a></li>
  <li><a href="https://nickjanetakis.com/blog/benchmarking-debian-vs-alpine-as-a-base-docker-image" target="_blank">Benchmarking Debian vs Alpine as a Base Docker Image</a></li>
  <li><a href="https://thenewstack.io/alpine-linux-heart-docker/" target="_blank">Meet Alpine Linux, Docker’s Distribution of Choice for Containers</a></li>
  <li><a href="https://github.com/gliderlabs/docker-alpine/issues/255" target="_blank">DNS Issue #255</a></li>
  <li><a href="https://github.com/gliderlabs/docker-alpine/blob/master/docs/caveats.md#dns" target="_blank">caveats.md » DNS</a></li>
</ul>

<h2 id="其他">其他</h2>
<ul>
  <li><a href="https://forums.docker.com/t/clarify-what-is-the-host/29640/2" target="_blank">Clarify what is the host</a></li>
  <li><a href="https://github.com/grpc/grpc-node/issues/604" target="_blank">grpc/grpc-node#604</a></li>
</ul>

<h2 id="ID_APP_DOCKER_INFO">docker info</h2>
<pre><code>docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 1
Server Version: 18.09.2
Storage Driver: overlay2
 Backing Filesystem: extfs
 Supports d_type: true
 Native Overlay Diff: true
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: bridge host macvlan null overlay
 Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Init Binary: docker-init
containerd version: 9754871865f7fe2f4e74d43e2fc7ccd237edcbce
runc version: 09c8266bf2fcf9519a651b04ae54c967b9ab86ec
init version: fec3683
Security Options:
 seccomp
  Profile: default
Kernel Version: 4.9.125-linuxkit
Operating System: Docker for Mac
OSType: linux
Architecture: x86_64
CPUs: 4
Total Memory: 1.952GiB
Name: linuxkit-025000000001
ID: CNVU:5KZS:A2M7:WY5W:NUEW:KPW3:WXOA:IH2Q:EBAN:LP7C:3EQR:36U4
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): true
 File Descriptors: 24
 Goroutines: 50
 System Time: 2019-03-27T06:19:11.1044801Z
 EventsListeners: 2
HTTP Proxy: gateway.docker.internal:3128
HTTPS Proxy: gateway.docker.internal:3129
Registry: https://index.docker.io/v1/
Labels:
Experimental: false
Insecure Registries:
 127.0.0.0/8
Live Restore Enabled: false
Product License: Community Engine
</code></pre>

<blockquote>
  <p>EOF</p>
</blockquote>

              </div>
              
              <div id="disqus_thread">
                <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
              </div>
              
            </div>
          </div>
        </div>
        <div class="col-md-4 hidden-xs">
          <div class="sidebar ">
  <h2>Recent Posts</h2>
  <ul>
    
    <li><a href="/2019/03/golang-debug/">Golang Debug</a></li>
    
    <li><a href="/2019/03/golang-goroutine/">Golang Goroutine</a></li>
    
    <li><a href="/2019/03/golang-cpu/">Golang CPU</a></li>
    
    <li><a href="/2019/03/golang-memory/">Golang Memory</a></li>
    
    <li><a href="/2019/03/golang-modules/">Golang Modules</a></li>
    
  </ul>
</div>

<div class="sidebar">
  <h2>Categories</h2>
  <ul>
    
      <li><a href="/category/Linux">Linux</a></li>
    
      <li><a href="/category/Stress & Scaling">Stress & Scaling</a></li>
    
      <li><a href="/category/PHP">PHP</a></li>
    
      <li><a href="/category/IDE">IDE</a></li>
    
      <li><a href="/category/Wordpress">Wordpress</a></li>
    
      <li><a href="/category/SEO">SEO</a></li>
    
      <li><a href="/category/Version Control">Version Control</a></li>
    
      <li><a href="/category/HTML & CSS">HTML & CSS</a></li>
    
      <li><a href="/category/Trash">Trash</a></li>
    
      <li><a href="/category/Apache">Apache</a></li>
    
      <li><a href="/category/Memcache">Memcache</a></li>
    
      <li><a href="/category/Net Services">Net Services</a></li>
    
      <li><a href="/category/Java">Java</a></li>
    
      <li><a href="/category/MicroBlog">MicroBlog</a></li>
    
      <li><a href="/category/JavaScript">JavaScript</a></li>
    
      <li><a href="/category/DB">DB</a></li>
    
      <li><a href="/category/Something">Something</a></li>
    
      <li><a href="/category/Methodology & Thinking">Methodology & Thinking</a></li>
    
      <li><a href="/category/Redis">Redis</a></li>
    
      <li><a href="/category/Flash">Flash</a></li>
    
      <li><a href="/category/Thinking">Thinking</a></li>
    
      <li><a href="/category/Platform">Platform</a></li>
    
      <li><a href="/category/C _ C++">C / C++</a></li>
    
      <li><a href="/category/Dart">Dart</a></li>
    
      <li><a href="/category/Mobile">Mobile</a></li>
    
      <li><a href="/category/Video">Video</a></li>
    
      <li><a href="/category/Blog">Blog</a></li>
    
      <li><a href="/category/Politics">Politics</a></li>
    
      <li><a href="/category/V8Blog">V8Blog</a></li>
    
      <li><a href="/category/Docker">Docker</a></li>
    
      <li><a href="/category/Golang">Golang</a></li>
    
  </ul>
</div>

        </div>
      </div>
    </div>
    
<!-- Add Disqus comments. -->
<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = "xenojoshua"; // required: replace example with your forum shortname
  var disqus_identifier = "/2019/01/docker-note/";

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


  </div>
      <footer class="footer-distributed">
      <div class="container">
        <div class="footer">
          <p>Jonathan Dai &copy; 2018</p>
          <h6>Theme by <a href="https://github.com/streetturtle/jekyll-clean-dark" target="_blank">Pavel Makhov</a></h6>
          <h6>Follow me</h6>

<ul class="social-media">

  
    <li>
      <a title="agreatfool on Github" href="https://github.com/agreatfool" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    </li>
  

  

  

  

  

  
    <li>
      <a title="feed.xml RSS" href="https://xenojoshua.com/feed.xml" target="_blank"><i class="fa fa-rss fa-2x"></i></a>
    </li>
  

</ul>

        </div>
      </div>
    </footer>
  </body>
</html>

</div>
