<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Golang Basic | Xenojoshua</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://xenojoshua.com/js/jquery.min.js"></script>
  <script src="https://xenojoshua.com/js/bootstrap.min.js"></script>
  <script src="https://xenojoshua.com/js/header.js"></script>
  <script src="https://xenojoshua.com/js/toc.js"></script>
  <link href="https://xenojoshua.com//2019/03/golang-basic/" rel="canonical" />
  <link href="https://xenojoshua.com/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://xenojoshua.com/css/theme.css" rel="stylesheet">
  <link href="https://xenojoshua.com/css/syntax.css" rel="stylesheet">
  <link href="https://xenojoshua.com/css/font-awesome/css/font-awesome.min.css" rel="stylesheet">
  <link href="https://xenojoshua.com/favicon.ico?" type="image/x-icon" rel="shortcut icon">
  <style>
    /* Enhance table style */
    table {
      border: 2px solid #4F7849;
      background-color: #EEEEEE;
      width: 100%;
      text-align: center;
      border-collapse: collapse;
    }
    table td, table.comicGreen th {
      border: 1px solid #4F7849;
      padding: 3px 5px;
    }
    table tbody td {
      font-size: 14px;
      color: #4F7849;
    }
    table tr:nth-child(even) {
      background: #CEE0CC;
    }
    table thead {
      background: #4F7849;
      border-bottom: 1px solid #444444;
    }
    table thead th {
      font-size: 16px;
      font-weight: bold;
      color: #FFFFFF;
      text-align: center;
      border-left: 2px solid #D0E4F5;
      padding: 3px 5px;
    }
    table thead th:first-child {
      border-left: none;
    }
    table tfoot td {
      font-size: 21px;
    }

    /* Enhance pre style */
    pre {
      color: #FFFFFF;
      background-color: #000000;
      border-color: #000000;
    }

    /* Image bg color white while dark background */
    img {
      background-color: #FFFFFF;
    }

    /* Keep gist style clean */
    .gist table tr:nth-child(even) {
      background: #FFFFFF;
    }
    .gist td, th {
      border: none;
    }
  </style>
</head>

<body>

  
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-11349149-4']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


  

 <script type="text/javascript">
   var host = "xenojoshua.com";
   if ((host == window.location.host) && (window.location.protocol != "https:"))
     window.location.protocol = "https";
 </script>
 <script type="text/javascript">
  WebFontConfig = {
    google: {
      families: ['Ubuntu::latin']
    }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="https://xenojoshua.com/">Xenojoshua</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="https://xenojoshua.com/">/home</a></li>
          <li><a href="https://xenojoshua.com/archive/">/archive</a></li>
          <li><a href="https://xenojoshua.com/categories/">/categories</a></li>
          <li><a href="https://xenojoshua.com/tags/">/tags</a></li>
          <li><a href="https://xenojoshua.com/feed.xml" target="_blank">/rss</a></li>
          <li><a href="https://xenojoshua.com/about/">/about</a></li>
        </ul>
      </div>
    </div>
  </nav>


<div class="wrapper">
  <div class="content">
    <div class="container container-center">
      <div class="row">
        <div class="col-md-8">
          <div class="article">
            <div class="well">
              <h1><a href="https://xenojoshua.com/2019/03/golang-basic/">Golang Basic</a></h1>
              <div class="post-meta">
                <div class="post-time">
                  <i class="fa fa-calendar"></i>
                  <time>04 Mar 2019</time>
                </div>
                <ul>
                  
                    <li><a href="https://xenojoshua.com/tag/Golang">Golang</a></li>
                  
                </ul>
              </div>
              <div class="post-content">
                <h4>Table of Contents</h4>
<ul id="markdown-toc">
  <li><a href="#1-前言" id="markdown-toc-1-前言">1. 前言</a></li>
  <li><a href="#2-语言基础" id="markdown-toc-2-语言基础">2. 语言基础</a>    <ul>
      <li><a href="#21-代码模块-module" id="markdown-toc-21-代码模块-module">2.1 代码模块 module</a>        <ul>
          <li><a href="#internal" id="markdown-toc-internal">internal</a></li>
        </ul>
      </li>
      <li><a href="#22-变量-variable" id="markdown-toc-22-变量-variable">2.2 变量 variable</a>        <ul>
          <li><a href="#程序实体" id="markdown-toc-程序实体">程序实体</a></li>
          <li><a href="#基本类型" id="markdown-toc-基本类型">基本类型</a></li>
          <li><a href="#引用类型" id="markdown-toc-引用类型">引用类型</a></li>
          <li><a href="#值传递--引用传递" id="markdown-toc-值传递--引用传递">值传递 &amp; 引用传递</a></li>
          <li><a href="#变量申明" id="markdown-toc-变量申明">变量申明</a></li>
          <li><a href="#变量初始化--new--make" id="markdown-toc-变量初始化--new--make">变量初始化 &amp; new &amp; make</a></li>
          <li><a href="#表达式类型" id="markdown-toc-表达式类型">表达式类型</a></li>
          <li><a href="#类型别名--再定义" id="markdown-toc-类型别名--再定义">类型别名 &amp; 再定义</a></li>
          <li><a href="#数组--切片" id="markdown-toc-数组--切片">数组 &amp; 切片</a></li>
          <li><a href="#map" id="markdown-toc-map">map</a></li>
          <li><a href="#显示类型转换" id="markdown-toc-显示类型转换">显示类型转换</a></li>
          <li><a href="#类型断言" id="markdown-toc-类型断言">类型断言</a></li>
          <li><a href="#打印类型" id="markdown-toc-打印类型">打印类型</a></li>
        </ul>
      </li>
      <li><a href="#23-循环--判断" id="markdown-toc-23-循环--判断">2.3 循环 &amp; 判断</a>        <ul>
          <li><a href="#if" id="markdown-toc-if">if</a></li>
          <li><a href="#for" id="markdown-toc-for">for</a></li>
          <li><a href="#switch" id="markdown-toc-switch">switch</a></li>
          <li><a href="#range" id="markdown-toc-range">range</a></li>
        </ul>
      </li>
      <li><a href="#ID_CHANNEL" id="markdown-toc-ID_CHANNEL">2.4 通道 / 信道 channel</a>        <ul>
          <li><a href="#通道缓存" id="markdown-toc-通道缓存">通道缓存</a></li>
          <li><a href="#顺序" id="markdown-toc-顺序">顺序</a></li>
          <li><a href="#内存" id="markdown-toc-内存">内存</a></li>
          <li><a href="#阻塞" id="markdown-toc-阻塞">阻塞</a></li>
          <li><a href="#select" id="markdown-toc-select">select</a></li>
          <li><a href="#关闭" id="markdown-toc-关闭">关闭</a></li>
        </ul>
      </li>
      <li><a href="#25-函数-func" id="markdown-toc-25-函数-func">2.5 函数 func</a>        <ul>
          <li><a href="#参数" id="markdown-toc-参数">参数</a></li>
          <li><a href="#官方闭包tutorial" id="markdown-toc-官方闭包tutorial">官方闭包tutorial</a></li>
        </ul>
      </li>
      <li><a href="#26-类型-struct" id="markdown-toc-26-类型-struct">2.6 类型 struct</a>        <ul>
          <li><a href="#字符串转换函数" id="markdown-toc-字符串转换函数">字符串转换函数</a></li>
          <li><a href="#嵌入字段--匿名字段" id="markdown-toc-嵌入字段--匿名字段">嵌入字段 / 匿名字段</a></li>
          <li><a href="#嵌入字段与继承区别" id="markdown-toc-嵌入字段与继承区别">嵌入字段与继承区别</a></li>
          <li><a href="#接收者类型" id="markdown-toc-接收者类型">接收者类型</a></li>
          <li><a href="#struct类型值" id="markdown-toc-struct类型值">struct{}类型值</a></li>
        </ul>
      </li>
      <li><a href="#27-接口-interface" id="markdown-toc-27-接口-interface">2.7 接口 interface</a></li>
      <li><a href="#28-指针-pointer" id="markdown-toc-28-指针-pointer">2.8 指针 pointer</a>        <ul>
          <li><a href="#操作符" id="markdown-toc-操作符">操作符</a></li>
          <li><a href="#可否寻址" id="markdown-toc-可否寻址">可否寻址</a></li>
          <li><a href="#打印指针方法" id="markdown-toc-打印指针方法">打印指针方法</a></li>
        </ul>
      </li>
      <li><a href="#29-go程-goroutine" id="markdown-toc-29-go程-goroutine">2.9 Go程 goroutine</a></li>
      <li><a href="#210-错误-error" id="markdown-toc-210-错误-error">2.10 错误 error</a>        <ul>
          <li><a href="#错误判断" id="markdown-toc-错误判断">错误判断</a></li>
          <li><a href="#panic" id="markdown-toc-panic">panic</a></li>
          <li><a href="#defer" id="markdown-toc-defer">defer</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#3-工具使用" id="markdown-toc-3-工具使用">3. 工具使用</a>    <ul>
      <li><a href="#31-go-build" id="markdown-toc-31-go-build">3.1 go build</a></li>
      <li><a href="#32-go-install" id="markdown-toc-32-go-install">3.2 go install</a></li>
      <li><a href="#33-go-get" id="markdown-toc-33-go-get">3.3 go get</a></li>
      <li><a href="#34-go-clean" id="markdown-toc-34-go-clean">3.4 go clean</a></li>
      <li><a href="#35-go-doc--godoc" id="markdown-toc-35-go-doc--godoc">3.5 go doc &amp; godoc</a></li>
      <li><a href="#36-go-run" id="markdown-toc-36-go-run">3.6 go run</a></li>
      <li><a href="#37-go-test" id="markdown-toc-37-go-test">3.7 go test</a></li>
      <li><a href="#38-go-list" id="markdown-toc-38-go-list">3.8 go list</a></li>
      <li><a href="#39-go-fmt--gofmt" id="markdown-toc-39-go-fmt--gofmt">3.9 go fmt &amp; gofmt</a></li>
      <li><a href="#310-go-fix--go-tool-fix" id="markdown-toc-310-go-fix--go-tool-fix">3.10 go fix &amp; go tool fix</a></li>
      <li><a href="#311-go-vet--go-tool-vet" id="markdown-toc-311-go-vet--go-tool-vet">3.11 go vet &amp; go tool vet</a></li>
      <li><a href="#312-go-tool-pprof" id="markdown-toc-312-go-tool-pprof">3.12 go tool pprof</a></li>
      <li><a href="#313-go-tool-cgo" id="markdown-toc-313-go-tool-cgo">3.13 go tool cgo</a></li>
      <li><a href="#314-go-env" id="markdown-toc-314-go-env">3.14 go env</a></li>
    </ul>
  </li>
  <li><a href="#4-进阶概念" id="markdown-toc-4-进阶概念">4. 进阶概念</a>    <ul>
      <li><a href="#41-函数内联" id="markdown-toc-41-函数内联">4.1 函数内联</a></li>
    </ul>
  </li>
</ul>

<h1 id="1-前言">1. 前言</h1>
<p>本文是Go语言系列文章<a href="/2019/02/golang-note/" target="_blank">Golang Notes</a>的其中一篇，完整的文章列表请去总章查看。</p>

<p>本篇主要着眼于阐述一些Go语言中的基础知识点。当然，语法本身涉及的不会太多，看<a href="https://tour.golang.org/" target="_blank">官方的tutorial</a>就好，Go语言本身就以语法不复杂著称。</p>

<p>这里要介绍下极客时间上的专题：<a href="https://time.geekbang.org/column/112" target="_blank">Go语言核心36讲</a>  <br />
随书附带的代码：<a href="https://github.com/hyper0x/Golang_Puzzlers" target="_blank">hyper0x/Golang_Puzzlers</a>  <br />
总的来说讲的内容不算很深，一看作者的专业功底就很好，用词和语言都非常专业和规范，和看一些大部头的技术书感觉很类似。优点在于讲解内容不是很深，适合新手使用。缺点在于部分章节的安排不是很好，前后关系以及一些对于新手来说需要介绍的内容过渡不够，此外，范例和文章的契合度不够，作者在很多情况下都是给了个github库的链接，让读者自己去匹配着看，体验不够好。</p>

<p>此外，还有一个以范例来进行Go语言基础编码指导的站点：<a href="https://gobyexample.com/" target="_blank">Go by Example</a>，可以利用。</p>

<h1 id="2-语言基础">2. 语言基础</h1>
<h2 id="21-代码模块-module">2.1 代码模块 module</h2>

<p>名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。小写，包私有；大写，公开。</p>

<h3 id="internal">internal</h3>
<p>路径和包名为internal的是模块私有的代码，无法被外部引用。  <br />
具体规则是，internal代码包中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用。当然，引用前需要先导入这个internal包。对于其他代码包，导入该internal包都是非法的，无法通过编译。</p>

<h2 id="22-变量-variable">2.2 变量 variable</h2>

<h3 id="程序实体">程序实体</h3>
<p>Go 语言中的<code>程序实体</code>包括：</p>

<ul>
  <li>变量</li>
  <li>常量</li>
  <li>函数</li>
  <li>结构体</li>
  <li>接口</li>
</ul>

<h3 id="基本类型">基本类型</h3>

<blockquote>
  <p>bool</p>

  <p>string</p>

  <p>int  int8  int16  int32  int64  <br />
uint uint8 uint16 uint32 uint64 uintptr  <br />
byte // uint8 的别名</p>

  <p>rune // int32 的别名  <br />
     // 表示一个 Unicode 码点</p>

  <p>float32 float64</p>

  <p>complex64 complex128</p>
</blockquote>

<p>因为是强类型语言，且Go里面的类型转换都必须要显示进行，因此有的时候处理起来比较麻烦。这方面，比较常见的问题是字符串和数字类型之间的转换：</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="c1">// string =&gt; int</span>
<span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>

<span class="c1">// string =&gt; int64</span>
<span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">ParseInt</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

<span class="c1">// int =&gt; string</span>
<span class="kt">string</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>

<span class="c1">// int64 =&gt; string</span>
<span class="kt">string</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatInt</span><span class="p">(</span><span class="kt">int64</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span></code></pre></figure>

<h3 id="引用类型">引用类型</h3>

<ul>
  <li>slice</li>
  <li>map</li>
  <li>channel</li>
</ul>

<p>它们本身就是对某种类型指针的封装：slice封装的指针是一个数组，所以传递的时候直接传递其本身就够了，一般来说不需要取址（&amp;）</p>

<h3 id="值传递--引用传递">值传递 &amp; 引用传递</h3>
<p>Go 语言里不存在像 Java 等编程语言中令人困惑的“传值或传引用”问题。在 Go 语言中，我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了。如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。从传递成本的角度讲，引用类型的值往往要比值类型的值低很多。</p>

<h3 id="变量申明">变量申明</h3>
<p>Go 语言在声明变量时，自动对变量对应的内存区域进行初始化操作。每个变量会初始化其类型的默认值，例如：</p>

<ul>
  <li>整型和浮点型变量的默认值为 0。</li>
  <li>字符串变量的默认值为空字符串。</li>
  <li>布尔型变量默认为 bool。</li>
  <li>切片、函数、指针变量的默认为 nil。</li>
</ul>

<p>所以看到某个被申明的变量直接被拿来使用的时候千万不要惊奇，并不是一定要进行初始化才可以使用。</p>

<h3 id="变量初始化--new--make">变量初始化 &amp; new &amp; make</h3>
<p><a href="https://golang.org/doc/faq#stack_or_heap" target="_blank">How do I know whether a variable is allocated on the heap or the stack?</a></p>

<p><a href="https://www.flysnow.org/2017/10/23/go-new-vs-make.html">Go语言中new和make的区别</a></p>

<ul>
  <li>两者都是内存的分配（堆内存）</li>
  <li>初始值：
    <ul>
      <li><code>make</code>只用于slice、map以及channel的初始化（非零值）</li>
      <li><code>new</code>用于类型（struct）的内存分配，并且内存置为零</li>
    </ul>
  </li>
  <li>返回值：
    <ul>
      <li><code>make</code>返回的还是这三个引用类型本身：<code>func make(t Type, size ...IntegerType) Type</code></li>
      <li><code>new</code>返回的是指向类型的指针：<code>func new(Type) *Type</code></li>
    </ul>
  </li>
</ul>

<h3 id="表达式类型">表达式类型</h3>
<p>你可以认为，表达式类型就是对表达式进行求值后得到结果的类型。</p>

<p><code>[]string</code>是一个类型字面量。所谓类型字面量，就是用来表示数据类型本身的若干个字符。</p>

<h3 id="类型别名--再定义">类型别名 &amp; 再定义</h3>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">MyString</span> <span class="p">=</span> <span class="kt">string</span> <span class="c1">// 这条声明语句表示，MyString是string类型的别名类型。    </span>
<span class="kd">type</span> <span class="nx">MyString2</span> <span class="kt">string</span> <span class="c1">// 注意，这里没有等号。这里的MyString2是一个新的类型，不同于其他任何类型。这种方式也可以被叫做对类型的再定义。</span></code></pre></figure>

<h3 id="数组--切片">数组 &amp; 切片</h3>
<p>数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。Go 语言的切片类型属于引用类型，同属引用类型的还有字典类型、通道类型、函数类型等；而 Go 语言的数组类型则属于值类型，同属值类型的有基础数据类型以及结构体类型。（引用类型主要就这几种，不多的）</p>

<p>Go 语言里的切片长度和容量。长度指当前切片中的真实元素有多少个，容量指切片申请的内存容量是多少。</p>

<p><code>[...]int{1, 2, 3, 4, 5, 6}</code> 用三个点代替了长度申明，这句语句执行的结果仍旧是一个数组，而不是切片。</p>

<p>从数组生成切片时，上界含，下界不含：</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">=</span> <span class="nx">primes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span></code></pre></figure>

<p>1号位包含，4号位不含</p>

<h3 id="map">map</h3>
<p>判断map中键是否存在：</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="nx">elem</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
<span class="c1">// OR    </span>
<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span></code></pre></figure>

<h3 id="显示类型转换">显示类型转换</h3>
<p>表达式 T(v) 将值 v 转换为类型 T。  <br />
所有的类型转换必须是显示的。</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="nx">f</span> <span class="o">:=</span> <span class="nb">float32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></code></pre></figure>

<h3 id="类型断言">类型断言</h3>
<p>类型断言表达式的语法形式是x.(T)。其中的x代表要被判断类型的值。这个值当下的类型必须是接口类型的，不过具体是哪个接口类型其实是无所谓的。  <br />
<code>value, ok := interface{}(container).([]string)</code>  <br />
一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）。</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span>  <span class="kd">interface</span><span class="p">{}(</span><span class="mi">1</span><span class="p">).(</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;TypeOK:&quot;</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span>
<span class="c1">// OR</span>
<span class="kd">var</span> <span class="nx">i</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="s">&quot;hello&quot;</span>
<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
<span class="c1">// OR</span>
<span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// return Type</span></code></pre></figure>

<p>这个ok还是必要的，否则在类型不匹配的时候会发生panic</p>

<p>根据不同类型进行不同行为</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="nx">m_type</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">i</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
		<span class="c1">//...</span>
	<span class="k">case</span> <span class="kt">int</span><span class="p">:</span>
		<span class="c1">//...</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span></code></pre></figure>

<h3 id="打印类型">打印类型</h3>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;The type of pet is %T.\n&quot;</span><span class="p">,</span> <span class="nx">pet</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;The type of pet is %s.\n&quot;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">pet</span><span class="p">).</span><span class="nx">String</span><span class="p">())</span></code></pre></figure>

<h2 id="23-循环--判断">2.3 循环 &amp; 判断</h2>

<h3 id="if">if</h3>
<p>if 在判断之前可以添加一句简单的语句进行执行</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="k">if</span> <span class="nx">v</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">n</span><span class="p">);</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="nx">lim</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span></code></pre></figure>

<h3 id="for">for</h3>
<p>没有初始化语句和后置语句的 for 就是其他语言中的 while，这种情况下可以删除前后的分号</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="k">for</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">1000</span> <span class="p">{</span>
<span class="c1">//...</span>
<span class="p">}</span></code></pre></figure>

<h3 id="switch">switch</h3>
<p>switch 只会执行符合的条件，不会一路 fallthrough 下去  <br />
switch 还可以不带上判断条件，这样使用就等于if-else-else…</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="k">switch</span> <span class="p">{</span>
<span class="k">case</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Hour</span><span class="p">()</span> <span class="p">&lt;</span> <span class="mi">12</span><span class="p">:</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Good morning!&quot;</span><span class="p">)</span>
<span class="k">case</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Hour</span><span class="p">()</span> <span class="p">&lt;</span> <span class="mi">17</span><span class="p">:</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Good afternoon.&quot;</span><span class="p">)</span>
<span class="k">default</span><span class="p">:</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Good evening.&quot;</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<h3 id="range">range</h3>
<ol>
  <li>range表达式只会在for语句开始执行时被求值一次，无论后边会有多少次迭代；</li>
  <li>range表达式的求值结果会被复制，也就是说，被迭代的对象是range表达式结果值的副本而不是原值。</li>
</ol>

<h2 id="ID_CHANNEL">2.4 通道 / 信道 channel</h2>

<h3 id="通道缓存">通道缓存</h3>
<p>通道，make函数除了必须接收这样的类型字面量作为参数，还可以接收一个int类型的参数。后者是可选的，用于表示该通道的容量。所谓通道的容量，就是指通道最多可以缓存多少个元素值。</p>

<h3 id="顺序">顺序</h3>
<p>一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。</p>

<p>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。在同一时刻，Go 语言的运行时系统（以下简称运行时系统）只会执行对同一个通道的任意个发送操作中的某一个。直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。</p>

<h3 id="内存">内存</h3>
<p>元素值从外界进入通道时会被<code>复制</code>。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。另一方面，元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，第一步是生成正在通道中的这个元素值的副本，并准备给到接收方，第二步是删除在通道中的这个元素值。</p>

<h3 id="阻塞">阻塞</h3>
<p>发送操作和接收操作中对元素值的处理都是不可分割的。例如，发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分的情况。</p>

<p>发送操作在完全完成之前会被<code>阻塞</code>。接收操作也是如此。</p>

<p>针对<code>缓冲通道</code>的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。</p>

<p>对于<code>非缓冲通道</code>，情况要简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递。并且，数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。相比之下，缓冲通道则在用异步的方式传递数据。</p>

<h3 id="select">select</h3>
<p>select语句只能与通道联用，它一般由若干个分支组成。每次执行这种语句的时候，一般只有一个分支中的代码会被运行。仅当select语句中的所有case表达式都被求值完毕后，它才会开始选择候选分支。</p>

<h3 id="关闭">关闭</h3>
<p>只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。
信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 range 循环。</p>

<h2 id="25-函数-func">2.5 函数 func</h2>

<h3 id="参数">参数</h3>
<p>传入函数的参数值：数组是值类型，所以每一次复制都会拷贝它，以及它的所有元素值。对于引用类型，比如：切片、字典、通道，像上面那样复制它们的值，只会拷贝它们本身而已，并不会拷贝它们引用的底层数据。也就是说，这时只是浅表复制，而不是深层复制。</p>

<h3 id="官方闭包tutorial">官方闭包tutorial</h3>
<p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被“绑定”在了这些变量上。</p>

<p>例如，函数 adder 返回一个闭包。每个闭包都被绑定在其各自的 sum 变量上。</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="nx">adder</span><span class="p">()</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">x</span>
		<span class="k">return</span> <span class="nx">sum</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">pos</span><span class="p">,</span> <span class="nx">neg</span> <span class="o">:=</span> <span class="nx">adder</span><span class="p">(),</span> <span class="nx">adder</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span>
			<span class="nx">pos</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span>
			<span class="nx">neg</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="nx">i</span><span class="p">),</span>
		<span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h2 id="26-类型-struct">2.6 类型 struct</h2>

<h3 id="字符串转换函数">字符串转换函数</h3>
<p>在 Go 语言中，我们可以通过为一个类型编写名为String的方法，来自定义该类型的字符串表示形式。这个String方法不需要任何参数声明，但需要有一个string类型的结果声明。</p>

<h3 id="嵌入字段--匿名字段">嵌入字段 / 匿名字段</h3>
<p>Go 语言规范规定，如果一个字段的声明中只有字段的类型名而没有字段的名称，那么它就是一个嵌入字段，也可以被称为匿名字段。我们可以通过此类型变量的名称后跟“.”，再后跟嵌入字段类型的方式引用到该字段。也就是说，嵌入字段的类型既是类型也是名称。</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">Animal</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">scientificName</span> <span class="kt">string</span> <span class="c1">// 学名。</span>
    <span class="nx">AnimalCategory</span>    <span class="c1">// 动物基本分类。</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">Animal</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%s (category: %s)&quot;</span><span class="p">,</span>
		<span class="nx">a</span><span class="p">.</span><span class="nx">scientificName</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">AnimalCategory</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>当匿名字段是一个struct的时候，那么这个struct所拥有的全部字段都被隐式地引入了当前定义的这个struct。（有点继承的意思，应该更类似于Mixin）</p>

<p>如果被嵌入的类型中有和嵌入者重名的方法，则被嵌入这的方法会覆盖掉嵌入者的方法。（这个可以理解为重载）</p>

<h3 id="嵌入字段与继承区别">嵌入字段与继承区别</h3>
<p><a href="https://golang.org/doc/faq#inheritance">Why is there no type inheritance?</a>  <br />
简单来说，面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过侵入的方式来实现的。而Go语言类型之间的组合采用的是非声明的方式，我们不需要显式地声明某个类型实现了某个接口，或者一个类型继承了另一个类型。同时，类型组合也是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合。</p>

<h3 id="接收者类型">接收者类型</h3>
<p>类型的接收者类型：</p>

<ul>
  <li><code>func (cat *Cat) SetName(name string)</code> 指针类型</li>
  <li><code>func (cat Cat) SetName(name string)</code> 值类型</li>
</ul>

<p>区别：</p>

<ul>
  <li>值方法里获得到的是一个值拷贝，修改不会反应到原值</li>
  <li>一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。但是，Go 语言会适时地为我们进行自动地转译，使得我们在这样的值上也能调用到它的指针方法。</li>
</ul>

<h3 id="struct类型值">struct{}类型值</h3>
<p>struct{}类型值的表示法只有一个，即：struct{}{}。并且，它占用的内存空间是0字节。确切地说，这个值在整个 Go 程序中永远都只会存在一份。虽然我们可以无数次地使用这个值字面量，但是用到的却都是同一个值。</p>

<h2 id="27-接口-interface">2.7 接口 interface</h2>

<ul>
  <li>动态值：赋予的值可以被叫做它的实际值（也称动态值）</li>
  <li>动态类型：赋予值的类型可以被叫做这个变量的实际类型（也称动态类型）</li>
  <li>静态类型：接口的定义类型</li>
</ul>

<p>接口类型间的嵌入也被称为接口的组合。只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译。接口的组合根本不可能导致“屏蔽”现象的出现。</p>

<p>接口值可以看做包含值和具体类型的元组：  <br />
<code>(value, type)</code></p>

<p>接口值保存了一个具体底层类型的具体值：</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">I</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">M</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">F</span> <span class="kt">float64</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">F</span><span class="p">)</span> <span class="nx">M</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">describe</span><span class="p">(</span><span class="nx">i</span> <span class="nx">I</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;(%v, %T)\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">i</span> <span class="nx">I</span> <span class="p">=</span> <span class="nx">F</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span><span class="p">)</span>
<span class="nx">describe</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="c1">// (3.141592653589793, main.F)</span></code></pre></figure>

<h2 id="28-指针-pointer">2.8 指针 pointer</h2>

<h3 id="操作符">操作符</h3>
<ul>
  <li><code>*</code>表示的是取值操作，传过来的是一个指针，通过在前面附带<code>*</code>，就获得了这个指针所指向的值。</li>
  <li><code>&amp;</code>表示的是寻址操作，传过来的是一个值，通过在前面附带<code>&amp;</code>，就获得了指向这个值的指针。</li>
</ul>

<h3 id="可否寻址">可否寻址</h3>
<p>下列表中的值都是不可寻址的：</p>

<ul>
  <li>常量的值。</li>
  <li>基本类型值的字面量。</li>
  <li>算术操作的结果值。</li>
  <li>对各种字面量的索引表达式和切片表达式的结果值。不过有一个例外，对切片字面量的索引结果值却是可寻址的。</li>
  <li>对字符串变量的索引表达式和切片表达式的结果值。</li>
  <li>对字典变量的索引表达式的结果值。</li>
  <li>函数字面量和方法字面量，以及对它们的调用表达式的结果值。</li>
  <li>结构体字面量的字段值，也就是对结构体字面量的选择表达式的结果值。</li>
  <li>类型转换表达式的结果值。</li>
  <li>类型断言表达式的结果值。</li>
  <li>接收表达式的结果值。</li>
</ul>

<p>共性：</p>

<ol>
  <li><code>不可变的</code>值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。</li>
  <li>绝大多数被视为<code>临时结果</code>的值都是不可寻址的。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。</li>
  <li>若拿到某值的指针可能会破坏程序的一致性，那么就是<code>不安全的</code>，该值就不可寻址。由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。</li>
</ol>

<h3 id="打印指针方法">打印指针方法</h3>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%p\n&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span></code></pre></figure>

<h2 id="29-go程-goroutine">2.9 Go程 goroutine</h2>
<p>在sync/atomic包中声明了很多用于原子操作的函数。可以用在协程竞争的时候的线程安全。</p>

<p>e.g</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="nx">atomic</span><span class="p">.</span><span class="nx">AddUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></code></pre></figure>

<h2 id="210-错误-error">2.10 错误 error</h2>

<h3 id="错误判断">错误判断</h3>
<p>对于具体错误的判断，Go 语言中都有哪些惯用法？</p>

<ol>
  <li>对于类型在已知范围内的一系列错误值，一般使用类型断言表达式或类型switch语句来判断；</li>
  <li>对于已有相应变量且类型相同的一系列错误值，一般直接使用判等操作来判断；</li>
  <li>对于没有相应变量且类型未知的一系列错误值，只能使用其错误信息的字符串表示形式来做判断。</li>
</ol>

<h3 id="panic">panic</h3>
<p>从 panic 被引发到程序终止运行的大致过程：建立panic，并从运行的代码开始按调用栈逐层返回，最终返回运行时系统，打印信息，程序崩溃。</p>

<p>error返回可以被忽略，因此一般应用在”不致命”的场景。内建函数panic可用于引发 panic，一般用在”致命”错误的场景。</p>

<h3 id="defer">defer</h3>
<p>defer是先进后出（FILO）的，相当于一个栈，需要注意：</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;first defer&quot;</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;defer in for [%d]\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;last defer&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// last defer</span>
<span class="c1">// defer in for [2]</span>
<span class="c1">// defer in for [1]</span>
<span class="c1">// defer in for [0]</span>
<span class="c1">// first defer</span></code></pre></figure>

<h1 id="3-工具使用">3. 工具使用</h1>
<p>Go语言官方附带了不少很好用的命令行工具，除了以go命令为开头的<code>go xxx</code>的命令之外，还有：</p>

<ul>
  <li>cgo: Cgo enables the creation of Go packages that call C code.</li>
  <li>cover: Cover is a program for creating and analyzing the coverage profiles generated by “go test -coverprofile”.</li>
  <li>fix: Fix finds Go programs that use old features of the language and libraries and rewrites them to use newer ones.</li>
  <li>fmt: Fmt formats Go packages, it is also available as an independent gofmt command with more general options.</li>
  <li>godoc: Godoc extracts and generates documentation for Go packages.</li>
  <li>vet: Vet examines Go source code and reports suspicious constructs, such as Printf calls whose arguments do not align with the format string.</li>
</ul>

<p>Go命令行工具官方文档入口：<a href="https://golang.org/doc/cmd" target="_blank">Command Documentation</a></p>

<p>此外，这里还引用了不少<a href="https://github.com/hyper0x/go_command_tutorial" target="_blank">hyper0x/go_command_tutorial</a>这个文档库的内容，有兴趣的可以直接读一读。不过这库里的解释和范例都是以Go语言1.4-1.5版本为基准的，算是特别老旧了，只能说参考下。主要还是要看英语的官方手册。</p>

<p>下文并不会穷举官方手册中所有的Go命令行工具，仅列举部分常用的。</p>

<h2 id="31-go-build">3.1 go build</h2>
<p>功能：编译指定的源码文件或代码包以及它们的依赖包  <br />
手册：<a href="https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies" target="_blank">Compile packages and dependencies</a>  <br />
中文：<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.1.md" target="_blank">go build</a></p>

<h2 id="32-go-install">3.2 go install</h2>
<p>功能：编译并安装指定的代码包及它们的依赖包  <br />
手册：<a href="https://golang.org/cmd/go/#hdr-Compile_and_install_packages_and_dependencies" target="_blank">Compile and install packages and dependencies</a>  <br />
中文：<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.2.md" target="_blank">go install</a></p>

<h2 id="33-go-get">3.3 go get</h2>
<p>功能：从互联网上下载或更新指定的代码包及其依赖包  <br />
手册：<a href="https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies" target="_blank">Download and install packages and dependencies</a>  <br />
中文：<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.3.md" target="_blank">go get</a></p>

<h2 id="34-go-clean">3.4 go clean</h2>
<p>功能：删除掉执行其它命令时产生的一些文件和目录  <br />
手册：<a href="https://golang.org/cmd/go/#hdr-Remove_object_files_and_cached_files" target="_blank">Remove object files and cached files</a>  <br />
中文：<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.4.md" target="_blank">go clean</a></p>

<h2 id="35-go-doc--godoc">3.5 go doc &amp; godoc</h2>
<p>功能：展示指定代码包的文档  <br />
手册：<a href="https://golang.org/cmd/go/#hdr-Show_documentation_for_package_or_symbol" target="_blank">Show documentation for package or symbol</a>  <br />
中文：<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.5.md" target="_blank">go doc与godoc</a></p>

<h2 id="36-go-run">3.6 go run</h2>
<p>功能：运行命令源码文件  <br />
手册：<a href="https://golang.org/cmd/go/#hdr-Compile_and_run_Go_program" target="_blank">Compile and run Go program</a>  <br />
中文：<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.6.md" target="_blank">go run</a></p>

<h2 id="37-go-test">3.7 go test</h2>
<p>功能：对Go语言编写的程序进行测试  <br />
手册：<a href="https://golang.org/cmd/go/#hdr-Test_packages" target="_blank">Test packages</a>  <br />
中文：<a href="" target="_blank">go test</a></p>

<h2 id="38-go-list">3.8 go list</h2>
<p>功能：列出指定的代码包的信息  <br />
手册：<a href="https://golang.org/cmd/go/#hdr-List_packages_or_modules" target="_blank">List packages or modules</a>  <br />
中文：<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.8.md" target="_blank">go list</a></p>

<h2 id="39-go-fmt--gofmt">3.9 go fmt &amp; gofmt</h2>
<p>功能：按Go语言代码规范格式化指定代码包中的所有Go语言源码文件  <br />
手册：<a href="https://golang.org/cmd/go/#hdr-Gofmt__reformat__package_sources" target="_blank">Gofmt (reformat) package sources</a>  <br />
中文：<a href="" target="_blank">go fmt与gofmt</a></p>

<h2 id="310-go-fix--go-tool-fix">3.10 go fix &amp; go tool fix</h2>
<p>功能：把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码  <br />
手册：<a href="https://golang.org/cmd/go/#hdr-Update_packages_to_use_new_APIs" target="_blank">Update packages to use new APIs</a>  <br />
中文：<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.10.md" target="_blank">go fix与go tool fix</a></p>

<h2 id="311-go-vet--go-tool-vet">3.11 go vet &amp; go tool vet</h2>
<p>功能：检查Go语言源码中静态错误  <br />
手册：<a href="https://golang.org/cmd/go/#hdr-Report_likely_mistakes_in_packages" target="_blank">Report likely mistakes in packages</a>  <br />
中文：<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.11.md" target="_blank">go vet与go tool vet</a></p>

<h2 id="312-go-tool-pprof">3.12 go tool pprof</h2>
<p>功能：分析go应用程序，给出profile文件  <br />
手册：这个工具没有官方文档，讨论相关可以见：<a href="https://www.reddit.com/r/golang/comments/8neprv/theres_no_pprof_documentation/" target="_blank">There’s *no* pprof documentation?</a>，官方倒是有个pprof包的文档<a href="https://golang.org/pkg/net/http/pprof/" target="_blank">Package pprof</a>   <br />
google手册：<a href="https://github.com/google/pprof/tree/master/doc" target="_blank">google/pprof</a>   <br />
中文：<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.12.md" target="_blank">go tool pprof</a></p>

<p>如果有订阅<code>Go语言核心36讲</code>的话：</p>

<ul>
  <li><a href="https://time.geekbang.org/column/article/69812" target="_blank">48 | 程序性能分析基础（上）</a></li>
  <li><a href="https://time.geekbang.org/column/article/70805" target="_blank">49 | 程序性能分析基础（下）</a></li>
</ul>

<h2 id="313-go-tool-cgo">3.13 go tool cgo</h2>
<p>功能：创建能够调用C语言代码的Go语言源码文件  <br />
手册：<a href="https://golang.org/cmd/go/#hdr-Calling_between_Go_and_C" target="_blank">Calling between Go and C</a>  <br />
中文：<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.13.md" target="_blank">go tool cgo</a></p>

<h2 id="314-go-env">3.14 go env</h2>
<p>功能：打印Go语言的环境信息  <br />
手册：<a href="https://golang.org/cmd/go/#hdr-Print_Go_environment_information" target="_blank">Print Go environment information</a>  <br />
中文：<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.14.md" target="_blank">go env</a></p>

<h1 id="4-进阶概念">4. 进阶概念</h1>
<h2 id="41-函数内联">4.1 函数内联</h2>
<p>比较细节的解释可以参考：<a href="https://zhuanlan.zhihu.com/p/28347225" target="_blank">剖析使Go语言高效的5个特性(2/5): 函数调用不是免费的</a>。此外，可以看下官方的wiki：<a href="https://github.com/golang/go/wiki/CompilerOptimizations#function-inlining" target="_blank">Function Inlining</a>来了解官方对于内联的要求。</p>

<blockquote>
  <p>EOF</p>
</blockquote>

              </div>
              
              <div id="disqus_thread">
                <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
              </div>
              
            </div>
          </div>
        </div>
        <div class="col-md-4 hidden-xs">
          <div class="sidebar ">
  <h2>Recent Posts</h2>
  <ul>
    
    <li><a href="/2019/05/golang-pipeline/">Golang Pipeline</a></li>
    
    <li><a href="/2019/05/envoy-note/">Envoy Notes</a></li>
    
    <li><a href="/2019/05/grpc-note/">gRPC Notes</a></li>
    
    <li><a href="/2019/04/kafka-note/">Kafka Notes</a></li>
    
    <li><a href="/2019/04/message-queue-design/">消息队列设计精要 - 美团点评技术团队</a></li>
    
  </ul>
</div>

<div class="sidebar">
  <h2>Categories</h2>
  <ul>
    
      <li><a href="/category/Linux">Linux</a></li>
    
      <li><a href="/category/Stress & Scaling">Stress & Scaling</a></li>
    
      <li><a href="/category/PHP">PHP</a></li>
    
      <li><a href="/category/IDE">IDE</a></li>
    
      <li><a href="/category/Wordpress">Wordpress</a></li>
    
      <li><a href="/category/SEO">SEO</a></li>
    
      <li><a href="/category/Version Control">Version Control</a></li>
    
      <li><a href="/category/HTML & CSS">HTML & CSS</a></li>
    
      <li><a href="/category/Trash">Trash</a></li>
    
      <li><a href="/category/Apache">Apache</a></li>
    
      <li><a href="/category/Memcache">Memcache</a></li>
    
      <li><a href="/category/Net Services">Net Services</a></li>
    
      <li><a href="/category/Java">Java</a></li>
    
      <li><a href="/category/MicroBlog">MicroBlog</a></li>
    
      <li><a href="/category/JavaScript">JavaScript</a></li>
    
      <li><a href="/category/DB">DB</a></li>
    
      <li><a href="/category/Something">Something</a></li>
    
      <li><a href="/category/Methodology & Thinking">Methodology & Thinking</a></li>
    
      <li><a href="/category/Redis">Redis</a></li>
    
      <li><a href="/category/Flash">Flash</a></li>
    
      <li><a href="/category/Thinking">Thinking</a></li>
    
      <li><a href="/category/Platform">Platform</a></li>
    
      <li><a href="/category/C _ C++">C / C++</a></li>
    
      <li><a href="/category/Dart">Dart</a></li>
    
      <li><a href="/category/Mobile">Mobile</a></li>
    
      <li><a href="/category/Video">Video</a></li>
    
      <li><a href="/category/Blog">Blog</a></li>
    
      <li><a href="/category/Politics">Politics</a></li>
    
      <li><a href="/category/V8Blog">V8Blog</a></li>
    
      <li><a href="/category/Docker">Docker</a></li>
    
      <li><a href="/category/Golang">Golang</a></li>
    
      <li><a href="/category/Career">Career</a></li>
    
      <li><a href="/category/Prometheus">Prometheus</a></li>
    
      <li><a href="/category/Grafana">Grafana</a></li>
    
      <li><a href="/category/Logging">Logging</a></li>
    
      <li><a href="/category/Jaeger">Jaeger</a></li>
    
      <li><a href="/category/Elasticsearch">Elasticsearch</a></li>
    
      <li><a href="/category/MessageQueue">MessageQueue</a></li>
    
      <li><a href="/category/Kafka">Kafka</a></li>
    
      <li><a href="/category/gRPC">gRPC</a></li>
    
      <li><a href="/category/Envoy">Envoy</a></li>
    
  </ul>
</div>

        </div>
      </div>
    </div>
    
<!-- Add Disqus comments. -->
<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = "xenojoshua"; // required: replace example with your forum shortname
  var disqus_identifier = "/2019/03/golang-basic/";

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


  </div>
      <footer class="footer-distributed">
      <div class="container">
        <div class="footer">
          <p>Jonathan Dai &copy; 2019</p>
          <h6>Theme by <a href="https://github.com/streetturtle/jekyll-clean-dark" target="_blank">Pavel Makhov</a></h6>
          <h6>Follow me</h6>

<ul class="social-media">

  
    <li>
      <a title="agreatfool on Github" href="https://github.com/agreatfool" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    </li>
  

  

  

  

  

  
    <li>
      <a title="feed.xml RSS" href="https://xenojoshua.com/feed.xml" target="_blank"><i class="fa fa-rss fa-2x"></i></a>
    </li>
  

</ul>

        </div>
      </div>
    </footer>
  </body>
</html>

</div>
