{
    "componentChunkName": "component---src-templates-post-template-post-template-tsx",
    "path": "/posts/2018/02/node-memory-monitor",
    "result": {"data":{"markdownRemark":{"id":"eb41c8e1-5d29-57a9-bbbd-ad936c1d3b16","html":"<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1-%E5%89%8D%E8%A8%80\">1. 前言</a></li>\n<li><a href=\"#2-%E5%86%85%E5%AD%98metrics-api\">2. 内存Metrics API</a>\n<ul>\n<li><a href=\"#21-processmemoryusage\">2.1 process.memoryUsage</a></li>\n<li><a href=\"#22-requirev8getheapstatistics\">2.2 require(“v8”).getHeapStatistics</a></li>\n<li><a href=\"#23-requirev8getheapspacestatistics\">2.3 require(“v8”).getHeapSpaceStatistics</a></li>\n<li><a href=\"#24-top--ps\">2.4 top &#x26; ps</a></li>\n</ul>\n</li>\n<li><a href=\"#3-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2--chrome-dev-tool\">3. 内存泄露 &#x26; Chrome Dev Tool</a>\n<ul>\n<li><a href=\"#31-%E8%8C%83%E4%BE%8B\">3.1 范例</a></li>\n<li><a href=\"#32-%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98\">3.2 查找问题</a></li>\n</ul>\n</li>\n<li><a href=\"#4-%E6%A0%B8%E5%BF%83%E5%86%85%E5%AD%98metrics\">4. 核心内存Metrics</a>\n<ul>\n<li><a href=\"#41-node%E5%86%85%E5%AD%98\">4.1 Node内存</a></li>\n<li><a href=\"#42-node-gc\">4.2 Node GC</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%E5%B7%A5%E5%85%B7\">5. 工具</a>\n<ul>\n<li><a href=\"#51-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-or-%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C-%E8%8C%83%E4%BE%8B%E8%84%9A%E6%9C%AC-id51\">5.1 内存泄露 or 正常运行 范例脚本 {#ID51}</a></li>\n<li><a href=\"#52-gc%E8%A7%A3%E6%9E%90%E7%AE%A1%E9%81%93%E8%84%9A%E6%9C%AC-id52\">5.2 GC解析管道脚本 {#ID52}</a></li>\n<li><a href=\"#53-nimnodejs-%E8%B0%83%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-id53\">5.3 NIM(Node.js 调试管理工具) {#ID53}</a></li>\n</ul>\n</li>\n<li><a href=\"#6-%E8%B5%84%E6%96%99\">6. 资料</a></li>\n</ul>\n</div>\n<h1 id=\"1-前言\" style=\"position:relative;\"><a href=\"#1-%E5%89%8D%E8%A8%80\" aria-label=\"1 前言 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 前言</h1>\n<p>本文是系列文章<a href=\"/2018/01/node-profile/\">Node.JS Profile</a>的一部分，完整的文章列表请去总章查看。</p>\n<p>本文是Node内存相关文章的其中一篇，主要负责介绍内存监控相关的API及实践操作。</p>\n<h1 id=\"2-内存metrics-api\" style=\"position:relative;\"><a href=\"#2-%E5%86%85%E5%AD%98metrics-api\" aria-label=\"2 内存metrics api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 内存Metrics API</h1>\n<p>本节介绍几个非常有用的获取内存相关信息的API方法。</p>\n<h2 id=\"21-processmemoryusage\" style=\"position:relative;\"><a href=\"#21-processmemoryusage\" aria-label=\"21 processmemoryusage permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1 <a href=\"https://nodejs.org/docs/v8.4.0/api/process.html#process_process_memoryusage\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">process.memoryUsage</a></h2>\n<ul>\n<li>rss：node进程总内存占用量</li>\n<li>heapTotal：总堆内存占用量（已申请下来的）</li>\n<li>heapUsed：实际堆内存使用量</li>\n<li>external：扩展等外部程序的内存占用量</li>\n</ul>\n<p>常用来查看基础的内存信息，特别是rss很有用。</p>\n<h2 id=\"22-requirev8getheapstatistics\" style=\"position:relative;\"><a href=\"#22-requirev8getheapstatistics\" aria-label=\"22 requirev8getheapstatistics permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2 <a href=\"https://nodejs.org/docs/v8.4.0/api/v8.html#v8_v8_getheapstatistics\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">require(“v8”).getHeapStatistics</a></h2>\n<ul>\n<li>total_heap_size：总堆内存占用量（已申请下来的），同<code class=\"language-text\">process.memoryUsage().heapTotal</code></li>\n<li>total_heap_size_executable：字节码、优化后的代码等可执行的内容占用的内存量</li>\n<li>total_physical_size：找到部分解释说是<code class=\"language-text\">Commited size</code>，测试下来该值\n<ul>\n<li>used_heap_size &#x3C; total_physical_size &#x3C; total_heap_size</li>\n<li>Committed memory is, essentially, all the memory which has been allocated by applications, whether it’s used or not.</li>\n</ul>\n</li>\n<li>total_available_size：剩余可用的堆内存量，包括尚未向操作系统申请的部分，其实就是<code class=\"language-text\">heap_size_limit - used_heap_size</code></li>\n<li>used_heap_size：实际堆内存使用量，同<code class=\"language-text\">process.memoryUsage().heapUsed</code></li>\n<li>heap_size_limit：最大可用堆内存（上限）</li>\n<li>malloced_memory：实际测试是一个很小的值，有解释说是：current amount of memory, obtained via malloc</li>\n<li>peak_malloced_memory：没搜到任何说明，有必要可以读下node源码</li>\n<li>does_zap_garbage：覆盖堆垃圾的模式的开关</li>\n</ul>\n<p>常用来查看堆上限大小。</p>\n<h2 id=\"23-requirev8getheapspacestatistics\" style=\"position:relative;\"><a href=\"#23-requirev8getheapspacestatistics\" aria-label=\"23 requirev8getheapspacestatistics permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3 <a href=\"https://nodejs.org/docs/v8.4.0/api/v8.html#v8_v8_getheapspacestatistics\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">require(“v8”).getHeapSpaceStatistics</a></h2>\n<p>按内存空间分类<code class=\"language-text\">space</code>种类不同，给出不同空间的内存使用状况统计。实用性不大，一般来说实际使用中需要关心的其实只有old space，且仅仅只有large object space。</p>\n<h2 id=\"24-top--ps\" style=\"position:relative;\"><a href=\"#24-top--ps\" aria-label=\"24 top  ps permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.4 top &#x26; ps</h2>\n<p>使用系统ps命令更快获取进程的内存占用情况：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ps -p $(pgrep -lfa node | grep leak-and-gc.js | awk '{print $1}') -o rss,vsz</code></pre></div>\n<p>以及：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">top -pid $(pgrep -lfa node | grep leak-and-gc.js | awk '{print $1}')</code></pre></div>\n<h1 id=\"3-内存泄露--chrome-dev-tool\" style=\"position:relative;\"><a href=\"#3-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2--chrome-dev-tool\" aria-label=\"3 内存泄露  chrome dev tool permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 内存泄露 &#x26; Chrome Dev Tool</h1>\n<p>本节会提供实际的内存泄露例子，并指导如何使用工具进行问题点的查找。</p>\n<h2 id=\"31-范例\" style=\"position:relative;\"><a href=\"#31-%E8%8C%83%E4%BE%8B\" aria-label=\"31 范例 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1 范例</h2>\n<p>内存泄露的实际例子可以使用下面<a href=\"#ID51\">5.1里的脚本</a>进行试验。</p>\n<h2 id=\"32-查找问题\" style=\"position:relative;\"><a href=\"#32-%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98\" aria-label=\"32 查找问题 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2 查找问题</h2>\n<p>使用node的<a href=\"https://nodejs.org/en/docs/inspector/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">inspector</a>来进行运行状态分析（当然，这工具可以做更多的事情）。关于Chrome Dev Tool，可以看<a href=\"https://developers.google.com/web/tools/chrome-devtools/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">官方教程</a>。</p>\n<blockquote>\n<p>DEBUG=* node —inspect xxx.js</p>\n</blockquote>\n<p>然后打开浏览器<code class=\"language-text\">chrome://inspect/</code>，找到你的脚本进行调试。也可以使用<a href=\"#ID53\">5.3里提到的工具</a>，简化操作。</p>\n<p>在打开的分析面板里，选中<code class=\"language-text\">Memory</code>tab，一共有3个选项可以操作：</p>\n<ul>\n<li>Take heap snapshot\n<ul>\n<li>获取node进程的堆快照</li>\n<li>点击之后需要等一段时间采集数据，然后就可以看到heap数据</li>\n<li>这个选项信息最全，一般是最常用的内存观察选项</li>\n<li>一般来说按最右边的<code class=\"language-text\">Retained Size</code>从大到小排序，就找到很有用的信息了</li>\n</ul>\n</li>\n<li>Record allocation profile\n<ul>\n<li>以内存使用者的角度查看内存的分配情况</li>\n<li>在需要知道内存使用大户是哪个部分的业务的情况下很有用</li>\n<li>一样需要点击之后等一段时间进行采集</li>\n</ul>\n</li>\n<li>Record allocation timeline\n<ul>\n<li>以时间轴为单位查看单位时间内的内存分配量</li>\n<li>在需要知道node的内存与时间关系的情况下很有用</li>\n</ul>\n</li>\n</ul>\n<p>结果页面上会有多个列，里面的意义这里简单介绍下，方便理解和查找问题：</p>\n<ul>\n<li>Constructor：对象构造函数名称</li>\n<li>Distance：对象到根节点的引用层级</li>\n<li>Objects Count：对象的数量</li>\n<li>Shallow Size： 对象本身所占用的内存，这里不包含其引用对象所占的内存</li>\n<li>Retained Size： 对象所占总内存</li>\n<li>Retainers：对象的引用层级关系</li>\n</ul>\n<p>和RSS类似，这里的<code class=\"language-text\">Retained Size</code>是最重要需要关注的值。</p>\n<p>在线上运行时有的时候如果需要看堆快照的话，可以使用第三方库<a href=\"https://github.com/bnoordhuis/node-heapdump\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">bnoordhuis/node-heapdump</a>在runtime使用代码导出快照。然后使用Chrome Dev Tool打开这个快照文件来查看内容。</p>\n<p>Chrome Dev Tool可以加载多个堆快照，并对他们进行比对分析，这对内存量增长变化的分析非常有用。可以在程序里隔一定时间获取一次堆快照，然后线下慢慢分析。</p>\n<p>更详细的可以看博客：</p>\n<ul>\n<li><a href=\"https://blog.yld.io/2015/08/10/debugging-memory-leaks-in-node-js-a-walkthrough\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">DEBUGGING MEMORY LEAKS IN NODE.JS - A WALKTHROUGH</a>，这篇文章里的node和chrome版本有点老，但大致的观点和步骤都是没有问题的</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/27310544\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Node.js 性能调优之内存篇(二)——heapdump</a>，这篇中文的更容易阅读，界面和操作等细节更多</li>\n</ul>\n<h1 id=\"4-核心内存metrics\" style=\"position:relative;\"><a href=\"#4-%E6%A0%B8%E5%BF%83%E5%86%85%E5%AD%98metrics\" aria-label=\"4 核心内存metrics permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 核心内存Metrics</h1>\n<p>本节整理出监控Node内存的时候需要关心的核心Metrics。</p>\n<h2 id=\"41-node内存\" style=\"position:relative;\"><a href=\"#41-node%E5%86%85%E5%AD%98\" aria-label=\"41 node内存 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1 Node内存</h2>\n<ul>\n<li>rss：node进程总内存占用量</li>\n<li>heapTotal：总堆内存占用量（已申请下来的）</li>\n<li>heapUsed：实际堆内存使用量</li>\n<li>external：扩展等外部程序的内存占用量，在某些情况下rss很大但堆内存很小的时候，就需要定点关注外部插件使用的内存了</li>\n<li>heapSizeLimit：堆内存上限，建议在node启动的时候每次都确定好堆内存大小</li>\n</ul>\n<p>按空间分类的堆内存信息可以酌情收集，如果有需要分析单独的<code class=\"language-text\">新生代</code>或<code class=\"language-text\">老生代</code>内存情况的话。</p>\n<h2 id=\"42-node-gc\" style=\"position:relative;\"><a href=\"#42-node-gc\" aria-label=\"42 node gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2 Node GC</h2>\n<p>所有的GC相关Metrics采集都应该按GC触发的时间节点进行收集，毕竟数据来自GC行为，没有GC行为那也就没数据可采集，所以不可能做到类似CPU和Node进程内存这样的按时间定时进行采集。</p>\n<ul>\n<li>gcTime：GC发生的时间，精度可能需要提高到ms级别，而不是second级别</li>\n<li>gcType：GC类型，一般来说新生代的scavenge回收可以忽略，这个类型GC的量级及可优化性都比较低</li>\n<li>gcPause：GC中断时长，需要按不同GC类型进行分类收集，老生代的<code class=\"language-text\">markSweepCompact</code>数据最为关键</li>\n<li>sizeBefore：GC前内存大小 bytes</li>\n<li>sizeAfter：GC后内存大小 bytes</li>\n<li>holesBefore：GC前内存空洞大小 bytes</li>\n<li>holesAfter：GC后内存空洞大小 bytes</li>\n<li>allocated：GC间，内存分配量 bytes</li>\n<li>promoted：GC间，对象晋升量 bytes</li>\n<li>allocationThroughput：GC间，新生代内存申请速率 bytes/ms</li>\n<li>promotionRatio：当前GC中内存从新生代晋升到老生代的百分比 %</li>\n<li>incrementalWalltime：增量标记时长 ms</li>\n<li>compactionSpeed：内存Compacting速率 bytes/ms</li>\n</ul>\n<h1 id=\"5-工具\" style=\"position:relative;\"><a href=\"#5-%E5%B7%A5%E5%85%B7\" aria-label=\"5 工具 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 工具</h1>\n<h2 id=\"51-内存泄露-or-正常运行-范例脚本-id51\" style=\"position:relative;\"><a href=\"#51-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-or-%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C-%E8%8C%83%E4%BE%8B%E8%84%9A%E6%9C%AC-id51\" aria-label=\"51 内存泄露 or 正常运行 范例脚本 id51 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5.1 内存泄露 or 正常运行 范例脚本 {#ID51}</h2>\n<p>为了观察内存泄露和GC日志，需要一个范例运行的脚本，我这里制作了一个。如何使用请查看该脚本头部的注释：</p>\n<script src=\"https://gist.github.com/agreatfool/024d11c54c1a8e474ded5269d54f5c99.js\"> </script>\n<h2 id=\"52-gc解析管道脚本-id52\" style=\"position:relative;\"><a href=\"#52-gc%E8%A7%A3%E6%9E%90%E7%AE%A1%E9%81%93%E8%84%9A%E6%9C%AC-id52\" aria-label=\"52 gc解析管道脚本 id52 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5.2 GC解析管道脚本 {#ID52}</h2>\n<p>可配合<a href=\"#ID51\">5.1的脚本</a>一起使用，当然使用你自己的业务脚本也是OK的。</p>\n<script src=\"https://gist.github.com/agreatfool/0980b5bd950d120b8751114817e0f30c.js\"> </script>\n<h2 id=\"53-nimnodejs-调试管理工具-id53\" style=\"position:relative;\"><a href=\"#53-nimnodejs-%E8%B0%83%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-id53\" aria-label=\"53 nimnodejs 调试管理工具 id53 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5.3 <a href=\"https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NIM(Node.js 调试管理工具)</a> {#ID53}</h2>\n<p>可在node进程使用<code class=\"language-text\">--inspect</code> flag时，自动打开chrome的调试tab。</p>\n<h1 id=\"6-资料\" style=\"position:relative;\"><a href=\"#6-%E8%B5%84%E6%96%99\" aria-label=\"6 资料 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. 资料</h1>\n<ul>\n<li><a href=\"https://nodejs.org/en/docs/inspector/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Debugging Node.js Apps</a></li>\n<li><a href=\"https://developers.google.com/web/tools/chrome-devtools/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Dev工具官方教程</a></li>\n<li><a href=\"https://developers.google.com/web/tools/chrome-devtools/memory-problems/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">解决内存问题</a></li>\n<li><a href=\"https://blog.yld.io/2015/08/10/debugging-memory-leaks-in-node-js-a-walkthrough\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">DEBUGGING MEMORY LEAKS IN NODE.JS - A WALKTHROUGH</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/27310544\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Node.js 性能调优之内存篇(二)——heapdump</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/shimo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">石墨文档技术酒馆</a></li>\n<li><a href=\"https://github.com/bnoordhuis/node-heapdump\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">bnoordhuis/node-heapdump</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/33816534\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">V8 内存浅析</a></li>\n</ul>\n<blockquote>\n<p>EOF</p>\n</blockquote>","fields":{"slug":"/posts/2018/02/node-memory-monitor","tagSlugs":["/tag/javascript/","/tag/performance/","/tag/profile/","/tag/memory/","/tag/monitor/","/tag/metrics/"]},"frontmatter":{"date":"2018-02-24T02:01:22.000Z","description":"","tags":["JavaScript","Performance","Profile","Memory","Monitor","Metrics"],"title":"Node.JS Profile 1.3 Node内存监控实践","socialImage":"/media/default-social-image.jpg"}},"allFile":{"totalCount":0,"nodes":[]}},"pageContext":{"slug":"/posts/2018/02/node-memory-monitor","gallery":"media/posts/2018/02/node-memory-monitor/gallery"}},
    "staticQueryHashes": ["251939775","357378587","401334301"]}