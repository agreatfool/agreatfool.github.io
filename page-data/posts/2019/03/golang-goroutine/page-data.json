{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/2019/03/golang-goroutine","result":{"data":{"markdownRemark":{"id":"9d3008da-6c42-5e7b-8e0a-d3ecc69ae373","html":"<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1-%E5%89%8D%E8%A8%80\">1. 前言</a></li>\n<li><a href=\"#2-gpm--%E5%8E%9F%E7%90%86\">2. GPM &#x26; 原理</a></li>\n<li>\n<p><a href=\"#3-profiling\">3. Profiling</a></p>\n<ul>\n<li><a href=\"#pprof-web\">pprof web</a></li>\n<li><a href=\"#godebugschedtrace1000\">GODEBUG=schedtrace=1000</a></li>\n</ul>\n</li>\n<li><a href=\"#4-blocking\">4. Blocking</a></li>\n<li><a href=\"#%E8%B5%84%E6%96%99\">资料</a></li>\n</ul>\n</div>\n<h1 id=\"1-前言\" style=\"position:relative;\"><a href=\"#1-%E5%89%8D%E8%A8%80\" aria-label=\"1 前言 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 前言</h1>\n<p>本文是Go语言系列文章<a href=\"/2019/02/golang-note/\">Golang Notes</a>的其中一篇，完整的文章列表请去总章查看。</p>\n<p>Goroutine或者说Go程是Go语言的高性能关键。常见的高级语言比如说node、php这种，天生就是单进程单线程的，如果需要充分利用CPU，就需要启动多个进程进行集群管理。即便如此，在多个进程之间如何进行数据交换、进行业务协作又是一个基本上无解的头痛问题。而像Java这种，虽然用的是单个进程中的多线程，但因语言本身及线程设计本质的问题，开发体验仍旧说不上好。</p>\n<p>Go为什么能这么快就火起来，第一是因为它本身的性能很好，能满足各种需求，另一个就是Goroutine了，可以说是Go的灵魂。在不增加程序复杂度的情况下，马上就能将所有的物理核心都跑满利用起来的，横向过一遍也就只有Go了。</p>\n<p>但世上无银弹，Goroutine虽然好用消耗小，但使用不当仍旧会出问题，所以这里就需要理解其原理，并知道如何profiling找问题。</p>\n<h1 id=\"2-gpm--原理\" style=\"position:relative;\"><a href=\"#2-gpm--%E5%8E%9F%E7%90%86\" aria-label=\"2 gpm  原理 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. GPM &#x26; 原理</h1>\n<p>这部分的文章实在是太多了，基本上看完或者选择性看完（最重要的是3和4）下面几篇，就OK了：</p>\n<ul>\n<li>如果只需要初步的理解，这篇即可：<a href=\"https://juejin.im/post/5b7678f451882533110e8948\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang 的 协程调度机制 与 GOMAXPROCS 性能调优</a></li>\n<li>如果需要深入源码及实现细节（过于细节，有点偏离了行文的目的）：<a href=\"https://studygolang.com/articles/11627\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang源码探索(二) 协程的实现原理</a></li>\n<li>如果需要完美理解GPM及Goroutine（其实这篇是最好的）：<a href=\"https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">也谈goroutine调度器</a></li>\n<li>接上一篇，更多范例的调度细节：<a href=\"https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Goroutine调度实例简要分析</a></li>\n</ul>\n<p>几点记住就好：</p>\n<ul>\n<li>G是任务，全局有一个队列，每个P还有自己的队列</li>\n<li>P是逻辑处理器，由P来处理G</li>\n<li>M是物理处理器（实际上是Go应用程序里的<code class=\"language-text\">线程</code>），P会和M绑定，得到执行的实体</li>\n<li>M最终会通过操作系统调度，在CPU上得到运行</li>\n</ul>\n<h1 id=\"3-profiling\" style=\"position:relative;\"><a href=\"#3-profiling\" aria-label=\"3 profiling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Profiling</h1>\n<h2 id=\"pprof-web\" style=\"position:relative;\"><a href=\"#pprof-web\" aria-label=\"pprof web permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>pprof web</h2>\n<p>继续建议使用基于WEB的入口的方式进行查看：<a href=\"/2019/03/golang-memory/#ID_PROF_PPROF_WEB\">Golang Memory#5.3.3 runtime/pprof web</a>。此外，由于Goroutine一般数量巨大，不像CPU和内存检查的是点，goroutine更多的时候是要把握一个状态（面），因此更建议使用pprof的WEB UI来进行观察。入口在：<code class=\"language-text\">http://127.0.0.1:8080/debug/pprof/goroutine</code>。</p>\n<p>e.g</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ go tool pprof -http=:8899 http://127.0.0.1:8080/debug/pprof/goroutine\nFetching profile over HTTP from http://127.0.0.1:8080/debug/pprof/goroutine\nSaved profile in /Users/Jonathan/pprof/pprof.goroutine.001.pb.gz</code></pre></div>\n<p>在Profile的分析结果里，一般会看到<code class=\"language-text\">gopark</code>这个东西，这个在之前的几篇文章里都没怎么提到过（当然最细节的那篇是有的）。这里可以再看下：</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/27056944\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Go调度详解</a></li>\n<li><a href=\"https://blog.csdn.net/u010853261/article/details/85887948\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang-gopark函数和goready函数原理分析</a></li>\n</ul>\n<p>在第一篇里还可以顺道看下<code class=\"language-text\">自旋（spinning）</code>的概念。</p>\n<p>测试代码这里就不帖了，写起来实在是太简单，做个循环，起一点goroutine就好。</p>\n<h2 id=\"godebugschedtrace1000\" style=\"position:relative;\"><a href=\"#godebugschedtrace1000\" aria-label=\"godebugschedtrace1000 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GODEBUG=schedtrace=1000</h2>\n<p>如果需要查看Go调度器当前状态：使用<code class=\"language-text\">GODEBUG=schedtrace=...</code>，第二个等号后面给时间间隔，单位为毫秒。</p>\n<p>e.g</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ GODEBUG=schedtrace=1000 go run goroutine.go\nSCHED 0ms: gomaxprocs=8 idleprocs=6 threads=4 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0 0 0 0 0]\n# command-line-arguments\nSCHED 0ms: gomaxprocs=8 idleprocs=5 threads=5 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0 0 0 0 0]\n# command-line-arguments\nSCHED 0ms: gomaxprocs=8 idleprocs=5 threads=5 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0 0 0 0 0]\nSCHED 0ms: gomaxprocs=8 idleprocs=6 threads=4 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0 0 0 0 0]\nSCHED 1000ms: gomaxprocs=8 idleprocs=8 threads=22 spinningthreads=0 idlethreads=15 runqueue=0 [0 0 0 0 0 0 0 0]\nSCHED 1010ms: gomaxprocs=8 idleprocs=0 threads=12 spinningthreads=0 idlethreads=1 runqueue=33 [1 1 0 2 2 1 1 2]\nSCHED 2010ms: gomaxprocs=8 idleprocs=8 threads=22 spinningthreads=0 idlethreads=15 runqueue=0 [0 0 0 0 0 0 0 0]\nSCHED 2022ms: gomaxprocs=8 idleprocs=0 threads=12 spinningthreads=0 idlethreads=1 runqueue=36 [1 1 0 1 0 2 2 0]\nSCHED 3019ms: gomaxprocs=8 idleprocs=8 threads=22 spinningthreads=0 idlethreads=15 runqueue=0 [0 0 0 0 0 0 0 0]\nSCHED 3027ms: gomaxprocs=8 idleprocs=0 threads=12 spinningthreads=0 idlethreads=1 runqueue=36 [1 1 1 1 0 1 1 0]\nSCHED 4028ms: gomaxprocs=8 idleprocs=8 threads=22 spinningthreads=0 idlethreads=15 runqueue=0 [0 0 0 0 0 0 0 0]\nSCHED 4034ms: gomaxprocs=8 idleprocs=0 threads=12 spinningthreads=0 idlethreads=1 runqueue=31 [1 0 4 4 1 0 1 0]\nSCHED 5037ms: gomaxprocs=8 idleprocs=8 threads=22 spinningthreads=0 idlethreads=15 runqueue=0 [0 0 0 0 0 0 0 0]\nSCHED 5037ms: gomaxprocs=8 idleprocs=0 threads=12 spinningthreads=0 idlethreads=1 runqueue=22 [3 3 3 0 3 2 3 3]\nSCHED 6041ms: gomaxprocs=8 idleprocs=8 threads=22 spinningthreads=0 idlethreads=15 runqueue=0 [0 0 0 0 0 0 0 0]\n...</code></pre></div>\n<p>字段说明：</p>\n<ul>\n<li><code class=\"language-text\">SCHED</code>：标识该输出信息为goroutine scheduler的输出</li>\n<li><code class=\"language-text\">5037ms</code>：从程序启动到输出这行日志的时间</li>\n<li><code class=\"language-text\">gomaxprocs</code>：P的数量</li>\n<li><code class=\"language-text\">idleprocs</code>：idle状态的P的数量</li>\n<li><code class=\"language-text\">threads</code>：操作系统threads的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量</li>\n<li><code class=\"language-text\">spinningthreads</code>：处于自旋状态的操作系统thread数量</li>\n<li><code class=\"language-text\">idlethread</code>：处于idle状态的操作系统thread的数量</li>\n<li><code class=\"language-text\">runqueue=22</code>：go scheduler全局队列中G的数量</li>\n<li><code class=\"language-text\">[3 3 3 0 3 2 3 3]</code>：8个P的local queue中的G的数量</li>\n</ul>\n<p>通过这个输出可以很清晰看到goroutine的整体状态，特别是调度的状态，到底有没有跑满CPU，到底有没有空闲的线程，任务调度整体是不是平滑的，等等。可以说是非常有用。</p>\n<p>如果在GODEBUG中再加上<code class=\"language-text\">,scheddetail=1</code>的话，则会给出更多的细节：每个G、M和P的详细调度信息。</p>\n<p>e.g</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ GODEBUG=schedtrace=1000,scheddetail=1 go run goroutine.go\n...\n# command-line-arguments\nSCHED 0ms: gomaxprocs=8 idleprocs=5 threads=5 spinningthreads=1 idlethreads=0 runqueue=0 gcwaiting=0 nmidlelocked=1 stopwait=0 sysmonwait=0\n  P0: status=1 schedtick=0 syscalltick=0 m=3 runqsize=0 gfreecnt=0\n  P1: status=1 schedtick=1 syscalltick=0 m=2 runqsize=0 gfreecnt=0\n  P2: status=1 schedtick=0 syscalltick=0 m=4 runqsize=0 gfreecnt=0\n  P3: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0\n  P4: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0\n  P5: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0\n  P6: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0\n  P7: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0\n  M4: p=2 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=true blocked=false lockedg=-1\n  M3: p=0 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=-1\n  M2: p=1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=true blocked=false lockedg=-1\n  M1: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=-1\n  M0: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=1\n  G1: status=1(chan receive) m=-1 lockedm=0\n  G2: status=4(force gc (idle)) m=-1 lockedm=-1\n  G3: status=4(GC sweep wait) m=-1 lockedm=-1\nSCHED 0ms: gomaxprocs=8 idleprocs=6 threads=4 spinningthreads=1 idlethreads=0 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0\n  P0: status=1 schedtick=0 syscalltick=0 m=0 runqsize=0 gfreecnt=0\n  P1: status=1 schedtick=0 syscalltick=0 m=3 runqsize=0 gfreecnt=0\n  P2: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0\n  P3: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0\n  P4: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0\n  P5: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0\n  P6: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0\n  P7: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0\n  M3: p=1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=-1\n  M2: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=-1\n  M1: p=-1 curg=17 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=false lockedg=17\n  M0: p=0 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=1\n  G1: status=1() m=-1 lockedm=0\n  G17: status=6() m=1 lockedm=1\n  G2: status=1() m=-1 lockedm=-1\n...</code></pre></div>\n<h1 id=\"4-blocking\" style=\"position:relative;\"><a href=\"#4-blocking\" aria-label=\"4 blocking permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Blocking</h1>\n<p>阻塞的事情在这里顺道提一笔，毕竟阻塞和goroutine还是有很深的关系的，很多时候我们的debug就是要找死循环或死锁的goroutine。如果需要查看程序当中的阻塞情况（主要是竞争锁），一样可以使用pprof，入口在：<code class=\"language-text\">go tool pprof http://127.0.0.1:8080/debug/pprof/block</code>。</p>\n<h1 id=\"资料\" style=\"position:relative;\"><a href=\"#%E8%B5%84%E6%96%99\" aria-label=\"资料 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>资料</h1>\n<ul>\n<li><a href=\"https://juejin.im/post/5b7678f451882533110e8948\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang 的 协程调度机制 与 GOMAXPROCS 性能调优</a></li>\n<li><a href=\"https://studygolang.com/articles/11627\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang源码探索(二) 协程的实现原理</a></li>\n<li><a href=\"https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">也谈goroutine调度器</a></li>\n<li><a href=\"https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Goroutine调度实例简要分析</a></li>\n<li><a href=\"https://juejin.im/post/5b7678f451882533110e8948\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang 的 协程调度机制 与 GOMAXPROCS 性能调优</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28351811\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">剖析使Go语言高效的5个特性(4/5): Goroutines</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28381197\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Goroutine是如何工作的?</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/27056944\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Go调度详解</a></li>\n<li><a href=\"https://blog.csdn.net/u010853261/article/details/85887948\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang-gopark函数和goready函数原理分析</a></li>\n<li><a href=\"https://software.intel.com/en-us/blogs/2014/05/10/debugging-performance-issues-in-go-programs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Debugging performance issues in Go programs</a></li>\n</ul>\n<blockquote>\n<p>EOF</p>\n</blockquote>","fields":{"slug":"/posts/2019/03/golang-goroutine","tagSlugs":["/tag/golang/","/tag/performance/","/tag/profile/","/tag/goroutine/","/tag/monitor/"]},"frontmatter":{"date":"2019-03-26T03:01:22.000Z","description":"","tags":["Golang","Performance","Profile","Goroutine","Monitor"],"title":"Golang Goroutine","socialImage":{"publicURL":"/static/7e722e026a41a08a8f9a1cc76782dd27/default-social-image.jpg"}}},"allFile":{"totalCount":0,"nodes":[]}},"pageContext":{"slug":"/posts/2019/03/golang-goroutine","gallery":"media/posts/2019/03/golang-goroutine/gallery"}},"staticQueryHashes":["251939775","401334301","825871152"]}