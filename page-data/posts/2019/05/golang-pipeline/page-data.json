{
    "componentChunkName": "component---src-templates-post-template-post-template-tsx",
    "path": "/posts/2019/05/golang-pipeline",
    "result": {"data":{"markdownRemark":{"id":"eb8f1949-7417-5979-8056-c800f3200276","html":"<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1-%E5%89%8D%E8%A8%80\">1. 前言</a></li>\n<li><a href=\"#2-channel%E5%AE%9E%E9%AA%8C%E8%8C%83%E4%BE%8B\">2. Channel实验范例</a></li>\n<li><a href=\"#3-go-concurrency-patterns-pipelines-and-cancellation\">3. Go Concurrency Patterns: Pipelines and cancellation</a>\n<ul>\n<li><a href=\"#31-%E4%BB%80%E4%B9%88%E6%98%AFpipeline\">3.1 什么是Pipeline</a></li>\n<li><a href=\"#32-cancel-channel-done\">3.2 Cancel: Channel Done</a></li>\n<li><a href=\"#33-cancel-context\">3.3 Cancel: Context</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%B5%84%E6%96%99\">资料</a>\n<ul>\n<li><a href=\"#%E9%93%BE%E6%8E%A5\">链接</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h1 id=\"1-前言\" style=\"position:relative;\"><a href=\"#1-%E5%89%8D%E8%A8%80\" aria-label=\"1 前言 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 前言</h1>\n<p>学习一门新语言最简单的就是那些顺序执行的语言，会了PHP，换JAVA、Python、Ruby，无非就是语法更换下，上stackoverflow查下：“python字符串拼接”之类的，看下怎么写就完事了。难的是那些有特殊编程思维的语言，比如说JavaScript，异步原生，写代码要非常小心注意异步的返回如何处理，否则就会明明看着是先A后B，执行的时候却成了先B再A。就这方面来说，Go语言也属于后者，属于那种<code class=\"language-text\">语法看会简单，实际学精很难</code>的语言，而Golang难就难在goroutine以及channel带来的功能上。</p>\n<p>之前在查看Go语言的gRPC第三方库的时候，其代码对channel的运用非常灵活：<a href=\"https://github.com/processout/grpc-go-pool/blob/master/pool.go\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">grpc-go-pool/pool.go</a>。深感需要加深这块的理解。</p>\n<p>在学习的时候，找到了一篇官方之前的博客，时间比较早了（2014年），但还算有用：<a href=\"https://blog.golang.org/pipelines\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Go Concurrency Patterns: Pipelines and cancellation</a>。</p>\n<p>不过语言还是一直在发展的，目前在进行批量的routine控制以及退出触发的方面，最佳的解决方案是<code class=\"language-text\">context</code>。</p>\n<p>接下来，一点点开始。</p>\n<h1 id=\"2-channel实验范例\" style=\"position:relative;\"><a href=\"#2-channel%E5%AE%9E%E9%AA%8C%E8%8C%83%E4%BE%8B\" aria-label=\"2 channel实验范例 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Channel实验范例</h1>\n<p>在阅读官方博文之前，先自己着手做一些范例代码，加深对于<a href=\"/2019/03/golang-basic/#ID_CHANNEL\">Golang Basic > 2.4 通道 / 信道 channel</a>的理解。</p>\n<p>我做了点简单的演示范例：<a href=\"https://github.com/agreatfool/dist-system-practice/tree/master/golang/src/experiment/channel\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">dist-system-practice/golang/src/experiment/channel/</a>。</p>\n<p>只需要结果的话，可以直接读README：<a href=\"https://github.com/agreatfool/dist-system-practice/blob/master/golang/src/experiment/channel/README.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">dist-system-practice/golang/src/experiment/channel/README.md</a>。</p>\n<p>当中有几点比较有意思：</p>\n<ul>\n<li>slice值进出channel之后，<code class=\"language-text\">地址</code>并<code class=\"language-text\">没有改变</code>，和pointer是一样的结果</li>\n<li>channel在无buffer的情况下，很容易就会阻塞，导致routine睡眠，必须小心处理</li>\n<li>带buffer的channel，在buffer耗尽之后也是同样的结果，实际上来说也必须小心阻塞</li>\n<li>虽然向关闭的通道写数据会引起panic，但向关闭的通道<code class=\"language-text\">读数据</code>却<code class=\"language-text\">不会</code>，只会获得通道类型的<code class=\"language-text\">默认值</code></li>\n</ul>\n<p>有一张图，很好地将一系列状态以及操作结果整理了出来，可以参考：</p>\n<p><img src=\"/media/posts/2019/05/golang-pipeline/close_chan.png\" alt=\"\"></p>\n<h1 id=\"3-go-concurrency-patterns-pipelines-and-cancellation\" style=\"position:relative;\"><a href=\"#3-go-concurrency-patterns-pipelines-and-cancellation\" aria-label=\"3 go concurrency patterns pipelines and cancellation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Go Concurrency Patterns: Pipelines and cancellation</h1>\n<p>这里并不会通篇翻译：<a href=\"https://blog.golang.org/pipelines\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Go Concurrency Patterns: Pipelines and cancellation</a>，有需要的可以看<a href=\"https://imdiot.github.io/2016/01/01/Go%20Concurrency%20Patterns-Pipelines%20and%20cancellation.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这篇</a>。</p>\n<p>此外，本章后半也会涉及到<code class=\"language-text\">context</code>，毕竟这家伙才是现在的准标准。</p>\n<h2 id=\"31-什么是pipeline\" style=\"position:relative;\"><a href=\"#31-%E4%BB%80%E4%B9%88%E6%98%AFpipeline\" aria-label=\"31 什么是pipeline permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1 什么是Pipeline</h2>\n<ul>\n<li>通过输入channel从<code class=\"language-text\">上游</code>接收值</li>\n<li>对这些数据执行某些函数，通常是生成一些新的值</li>\n<li>通过输出channel发送值到<code class=\"language-text\">下游</code></li>\n</ul>\n<p>而在这一系列的交棒过程中，<code class=\"language-text\">错误</code>的发生和事务的<code class=\"language-text\">取消</code>是正常的情况，必须要进行<code class=\"language-text\">处理</code>，否则的话作为下游的routine可能会一直等待已经错误退出或取消事务的上游routine，导致<code class=\"language-text\">资源泄露</code>。使用的难点就在这里。</p>\n<h2 id=\"32-cancel-channel-done\" style=\"position:relative;\"><a href=\"#32-cancel-channel-done\" aria-label=\"32 cancel channel done permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2 Cancel: Channel Done</h2>\n<p>官方博文中的代码范例写的非常散，因为有多处重复修改，这里提供一份完整拼接的版本：<a href=\"https://github.com/agreatfool/dist-system-practice/blob/master/golang/src/experiment/pipeline/pipeline.go\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">experiment/pipeline/pipeline.go</a>。</p>\n<p>官方博文通篇都阅读了的话，撇开行文中的Dummy业务逻辑不谈，可以了解到该文主要还是谈了如何对出问题的routine进行退出通知。官方的博文中使用的方法是申明一个类型为<code class=\"language-text\">struct{}</code>的Dummy通道，关闭该通道来进行退出消息的传送。</p>\n<p>通过：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">defer</span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>out<span class=\"token punctuation\">)</span> <span class=\"token comment\">// HL</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> nums <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">select</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">case</span> out <span class=\"token operator\">&lt;-</span> n<span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">case</span> <span class=\"token operator\">&lt;-</span>done<span class=\"token punctuation\">:</span>\n\t\t\t<span class=\"token keyword\">return</span> <span class=\"token comment\">// HL</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>以这样的方式，监听<code class=\"language-text\">done</code>通道的关闭，退出routine函数，并设置defer函数，在routine函数退出的时候，清理对应的资源并关闭通道。这种编码解决方法确实能解决问题，但非常难看，也没有层级退出的概念。</p>\n<h2 id=\"33-cancel-context\" style=\"position:relative;\"><a href=\"#33-cancel-context\" aria-label=\"33 cancel context permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3 Cancel: Context</h2>\n<p><code class=\"language-text\">done通道</code>确实能在功能上达到要求，但尚欠缺了一些要素，因此后续就有<code class=\"language-text\">context</code>这个包的出现。相关的学习可以阅读：<a href=\"https://deepzz.com/post/golang-context-package-notes.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">快速掌握 Golang context 包，简单示例</a>。此外，还有官方博客：<a href=\"https://blog.golang.org/context\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Go Concurrency Patterns: Context</a>。</p>\n<p>一些概念和规范这里做下引用：</p>\n<p>Context 的调用应该是链式的，通过<code class=\"language-text\">WithCancel</code>，<code class=\"language-text\">WithDeadline</code>，<code class=\"language-text\">WithTimeout</code>或<code class=\"language-text\">WithValue</code>派生出新的 Context。当父 Context 被取消时，其派生的所有 Context 都将取消。</p>\n<p>通过<code class=\"language-text\">context.WithXXX</code>都将返回新的 Context 和 CancelFunc。调用 CancelFunc 将取消子代，移除父代对子代的引用，并且停止所有定时器。未能调用 CancelFunc 将泄漏子代，直到父代被取消或定时器触发。<code class=\"language-text\">go vet</code>工具检查所有流程控制路径上使用 CancelFuncs。</p>\n<p>遵循以下规则，以保持包之间的接口一致，并启用静态分析工具以检查上下文传播。</p>\n<ul>\n<li>不要将 Contexts 放入结构体，相反<code class=\"language-text\">context</code>应该作为第一个参数传入，命名为ctx。<code class=\"language-text\">func DoSomething（ctx context.Context，arg Arg）error { // ... use ctx ... }</code></li>\n<li>即使函数允许，也不要传入<code class=\"language-text\">nil</code>的 Context。如果不知道用哪种 Context，可以使用<code class=\"language-text\">context.TODO()</code>。</li>\n<li>使用context的Value相关方法只应该用于在程序和接口中传递的和请求相关的元数据，不要用它来传递一些可选的参数</li>\n<li>相同的 Context 可以传递给在不同的<code class=\"language-text\">goroutine</code>；Context 是并发安全的。</li>\n</ul>\n<p>用法：</p>\n<p>Done函数会返回一个channel，用来进行close通知（本质上还是之前的那一套）：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">gen <span class=\"token operator\">:=</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>ctx context<span class=\"token punctuation\">.</span>Context<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">select</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">case</span> <span class=\"token operator\">&lt;-</span>ctx<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t\t\t<span class=\"token keyword\">return</span> <span class=\"token comment\">// returning not to leak the goroutine</span>\n\t\t<span class=\"token comment\">//...</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//...</span>\nctx<span class=\"token punctuation\">,</span> cancel <span class=\"token operator\">:=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">WithCancel</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span><span class=\"token function\">Background</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">defer</span> <span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// cancel when we are finished consuming integers</span></code></pre></div>\n<p>此外，还有一篇老王的：<a href=\"https://blog.huoding.com/2019/04/15/730\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang之Context的迷思</a>，可以好好读下。</p>\n<h1 id=\"资料\" style=\"position:relative;\"><a href=\"#%E8%B5%84%E6%96%99\" aria-label=\"资料 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>资料</h1>\n<h2 id=\"链接\" style=\"position:relative;\"><a href=\"#%E9%93%BE%E6%8E%A5\" aria-label=\"链接 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>链接</h2>\n<ul>\n<li><a href=\"https://github.com/processout/grpc-go-pool/blob/master/pool.go\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">grpc-go-pool/pool.go</a></li>\n<li><a href=\"https://blog.golang.org/pipelines\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Go Concurrency Patterns: Pipelines and cancellation</a></li>\n<li><a href=\"https://imdiot.github.io/2016/01/01/Go%20Concurrency%20Patterns-Pipelines%20and%20cancellation.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">『译』Go Concurrency Patterns: Pipelines and cancellation</a></li>\n<li><a href=\"https://deepzz.com/post/golang-context-package-notes.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">快速掌握 Golang context 包，简单示例</a></li>\n<li><a href=\"https://blog.huoding.com/2019/04/15/730\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang之Context的迷思</a></li>\n</ul>\n<blockquote>\n<p>EOF</p>\n</blockquote>","fields":{"slug":"/posts/2019/05/golang-pipeline","tagSlugs":["/tag/golang/","/tag/goroutine/"]},"frontmatter":{"date":"2019-05-10T02:01:22.000Z","description":"","tags":["Golang","Goroutine"],"title":"Golang Pipeline","socialImage":"/media/default-social-image.jpg"}},"allFile":{"totalCount":0,"nodes":[]}},"pageContext":{"slug":"/posts/2019/05/golang-pipeline","gallery":"media/posts/2019/05/golang-pipeline/gallery"}},
    "staticQueryHashes": ["251939775","357378587","401334301"]}