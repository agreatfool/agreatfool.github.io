{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/2020/05/golang-concurrency","result":{"data":{"markdownRemark":{"id":"94cd2ae9-3327-5a90-88fb-2d1d0b8bd2f9","html":"<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1-%E5%89%8D%E8%A8%80\">1. 前言</a></li>\n<li><a href=\"#2-%E8%B5%84%E6%96%99\">2. 资料</a></li>\n<li><a href=\"#3-%E9%A2%9D%E5%A4%96%E7%9A%84%E5%87%A0%E7%82%B9\">3. 额外的几点</a></li>\n</ul>\n</div>\n<h2 id=\"1-前言\" style=\"position:relative;\"><a href=\"#1-%E5%89%8D%E8%A8%80\" aria-label=\"1 前言 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 前言</h2>\n<p>Go语言的并发支持在语言上是第一级原生直接支持的，就像异步事件在Node.js上是语言原生支持的一样。Go语言的并发与其他语言的多线程使用还有点不太一样，在使用的时候需要从思路上理解这个”原生支持”的概念，才能用好。因此这篇博文就对其中的一些内容做个整理，此外在<a href=\"https://github.com/agreatfool/golang-practice\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">golang-practice</a>这个代码库中进行实践操作，并进行监控观察效果。</p>\n<h2 id=\"2-资料\" style=\"position:relative;\"><a href=\"#2-%E8%B5%84%E6%96%99\" aria-label=\"2 资料 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 资料</h2>\n<p>因着Go语言在国内的火热，大量分析和资料其实都有了，这里我尽量多做整理，不做重复发明轮子的无用功：</p>\n<p><strong>channel &#x26; goroutine</strong></p>\n<ul>\n<li>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3MTA0NDQ1OQ==&#x26;mid=2247483671&#x26;idx=1&#x26;sn=1706ffa6deee44a367c34ef84448f55f\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang并发模型：轻松入门流水线模型</a></p>\n<ul>\n<li>channel的基本运用</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3MTA0NDQ1OQ==&#x26;mid=2247483680&#x26;idx=1&#x26;sn=de463ebbd088c0acf6c2f0b5f179f38d\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang并发模型：轻松入门流水线FAN模式</a></p>\n<ul>\n<li>channel的多routine协同工作</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3MTA0NDQ1OQ==&#x26;mid=2247483702&#x26;idx=1&#x26;sn=50825426986120a0b306e0f6da176951\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang并发模型：轻松入门select</a></p>\n<ul>\n<li>select的使用，routine的情况判断</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3MTA0NDQ1OQ==&#x26;mid=2247483714&#x26;idx=1&#x26;sn=383e060fbf824d956dab6dc0a5555352\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang并发模型：select进阶</a></p>\n<ul>\n<li>select的高级运用，需要排除的select的分支处理，select的阻塞运用等</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3MTA0NDQ1OQ==&#x26;mid=2247483689&#x26;idx=1&#x26;sn=7dfed7ffb000752a456125513ed99c26\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang并发模型：并发协程的优雅退出</a></p>\n<ul>\n<li>routine的退出方法</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3MTA0NDQ1OQ==&#x26;mid=2247483724&#x26;idx=1&#x26;sn=6890ab956c2f0020e9107ef60a388d5b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang并发模型：轻松入门协程池</a></p>\n<ul>\n<li>和FAN模式有异曲同工之妙</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3MTA0NDQ1OQ==&#x26;mid=2247483788&#x26;idx=1&#x26;sn=3b9d237029bfaa02847b4dacdc118173\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang并发：再也不愁选channel还是选锁</a></p>\n<ul>\n<li>channel和锁的选择问题，根据情况有不同的选择</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://mp.weixin.qq.com/s/m8HjfS0tJCibD8hSRIxrBA\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang并发模型：一招教你无阻塞读写通道</a></p>\n<ul>\n<li>巧用select，在阻塞的情况下进入到不同的分支做到零等待</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3MTA0NDQ1OQ==&#x26;mid=2247483803&#x26;idx=1&#x26;sn=7be293f3d03e892058bebbdebed68cb5\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">总结了才知道，原来channel有这么多用法！</a></p>\n<ul>\n<li>总结了所有的channel用法和细节</li>\n</ul>\n</li>\n</ul>\n<p><strong>sync &#x26; lock</strong></p>\n<ul>\n<li>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3MTA0NDQ1OQ==&#x26;mid=2247483768&#x26;idx=1&#x26;sn=dd94f808b9ee48d0fe2661d9a5efdd96\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Golang并发的次优选择：sync包</a></p>\n<ul>\n<li>sync包及锁的基本运用</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-额外的几点\" style=\"position:relative;\"><a href=\"#3-%E9%A2%9D%E5%A4%96%E7%9A%84%E5%87%A0%E7%82%B9\" aria-label=\"3 额外的几点 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 额外的几点</h2>\n<p>上面的资料可能因为时间问题，没有提到Context，实际上在真实场景中，对多routine的退出协作使用的更多的是context：<a href=\"https://blog.golang.org/context\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Go Concurrency Patterns: Context</a>。</p>\n<p>channel和锁之间的选择简单来说就是：</p>\n<ul>\n<li>如果有共享内存需要在多个routine之间共用，选择锁</li>\n<li>如果所有的内存都无需在routine之间共享，选择channel</li>\n</ul>\n<blockquote>\n<p>EOF</p>\n</blockquote>","fields":{"slug":"/posts/2020/05/golang-concurrency","tagSlugs":["/tag/golang/","/tag/concurrency/","/tag/goroutine/"]},"frontmatter":{"date":"2020-05-03T05:02:22.000Z","description":"","tags":["Golang","Concurrency","Goroutine"],"title":"Golang Concurrency","socialImage":{"publicURL":"/static/7e722e026a41a08a8f9a1cc76782dd27/default-social-image.jpg"}}},"allFile":{"totalCount":0,"nodes":[]}},"pageContext":{"slug":"/posts/2020/05/golang-concurrency","gallery":"media/posts/2020/05/golang-concurrency/gallery"}},"staticQueryHashes":["251939775","401334301","825871152"]}