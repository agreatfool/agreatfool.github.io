<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.23.1"/><meta name="theme-color" content="hsl(31, 92%, 62%)"/><meta data-react-helmet="true" name="description" content=""/><meta data-react-helmet="true" property="og:site_name" content="Docker Notes - Blog by Jonathan Dai"/><meta data-react-helmet="true" property="og:image" content="https://xenojoshua.com/media/default-social-image.jpg"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="Docker Notes - Blog by Jonathan Dai"/><meta data-react-helmet="true" name="twitter:description" content=""/><meta data-react-helmet="true" name="twitter:image" content="https://xenojoshua.com/media/default-social-image.jpg"/><style data-href="/styles.73ba2c353057148cd83d.css" data-identity="gatsby-global-css">html{font-size:100}body{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-rendering:optimizelegibility;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#212121;font-size:16px;line-height:1.625;margin:0 0 0 calc(100vw - 100%)}body,h1,h2,h3,h4,h5,h6{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif}h1,h2,h3,h4,h5,h6{font-weight:600}h1{font-size:40px;line-height:52px;margin-bottom:26px;margin-top:104px}h2{font-size:27px;line-height:39px}h2,h3{margin-bottom:13px;margin-top:52px}h3{font-size:22px;line-height:26px}h4{font-size:19.2px;margin-top:39px}h4,h5{line-height:26px;margin-bottom:13px}h5,h6{font-size:16px;margin-top:65px}h6{line-height:26px;margin-bottom:13px}img{max-width:100%}hr,img{border:0;display:block}hr{background-image:linear-gradient(180deg,transparent 1px,transparent 11px,#212121 0,#212121 15px,transparent 0,transparent 26px);background-size:100% 26px;color:#212121;height:26px;margin:52px auto;width:100px}a{color:#5c92ff;text-decoration:none}a:active,a:focus,a:hover{color:#f7a145}b,strong{font-weight:600}ul{list-style:square;margin-bottom:26px}ul li{margin-bottom:10px;padding:0 5px}p{line-height:26px;margin-bottom:26px}blockquote{font-style:italic;padding:0;text-align:center}figure{display:block;height:auto;width:100%}figcaption{color:#212121;font-size:14px;font-style:italic;line-height:19.5px;margin-bottom:0;margin-top:6.5px;text-align:center}@media screen and (min-width:685px){figure.float-left,figure.float-right{max-width:310px;padding:0 26px}.float-right{float:right}.float-left{float:left}}code[class*=language-],pre[class*=language-]{word-wrap:normal;color:#657b83;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5;-o-tab-size:4;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}pre[class*=language-]{border-radius:.3em;margin:.5em 0;overflow:auto;padding:1em}:not(pre)>code[class*=language-],pre[class*=language-]{background-color:#fdf6e3}:not(pre)>code[class*=language-]{border-radius:.3em;padding:.1em}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#073642}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{background:#eee8d5;color:#657b83;cursor:help}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.class-name,.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}blockquote{border-left:5px solid #424242!important;color:#424242!important;display:block!important;font-style:normal!important;padding-left:1rem!important;text-align:left!important}table{border-collapse:collapse;box-shadow:0 0 20px rgba(0,0,0,.15)}thead tr{background-color:#009879;color:#fff;text-align:left}td,th{padding:12px 15px}tbody tr{border-bottom:1px solid #ddd}tbody tr:nth-of-type(2n){background-color:#f3f3f3}tbody tr:last-of-type{border-bottom:2px solid #009879}h1{margin-top:0!important}.Feed-module--feed--3dYe7 .Feed-module--item--ooOky{margin-bottom:32.5px}.Feed-module--feed--3dYe7 .Feed-module--item--ooOky:last-child{margin-bottom:13px}.Feed-module--feed--3dYe7 .Feed-module--item--ooOky .Feed-module--title--1qA0W{font-size:27px;line-height:39px;margin-bottom:13px;margin-top:0}.Feed-module--feed--3dYe7 .Feed-module--item--ooOky .Feed-module--title--1qA0W .Feed-module--link--GNuXE{color:#212121}.Feed-module--feed--3dYe7 .Feed-module--item--ooOky .Feed-module--title--1qA0W .Feed-module--link--GNuXE:focus,.Feed-module--feed--3dYe7 .Feed-module--item--ooOky .Feed-module--title--1qA0W .Feed-module--link--GNuXE:hover{border-bottom:1px solid #212121;color:#212121}.Feed-module--feed--3dYe7 .Feed-module--item--ooOky .Feed-module--description--UXUO2{font-size:16px;line-height:26px;margin-bottom:19.5px}.Feed-module--feed--3dYe7 .Feed-module--item--ooOky .Feed-module--meta--ECIPa .Feed-module--time--17yla{color:#212121;font-size:14px;font-weight:600;text-transform:uppercase}.Feed-module--feed--3dYe7 .Feed-module--item--ooOky .Feed-module--meta--ECIPa .Feed-module--divider--3kBgQ{margin:0 13px}.Feed-module--feed--3dYe7 .Feed-module--item--ooOky .Feed-module--meta--ECIPa .Feed-module--category--DGEwP .Feed-module--link--GNuXE{color:#f7a145;font-size:14px;font-weight:600;text-transform:uppercase}.Feed-module--feed--3dYe7 .Feed-module--item--ooOky .Feed-module--meta--ECIPa .Feed-module--category--DGEwP .Feed-module--link--GNuXE:focus,.Feed-module--feed--3dYe7 .Feed-module--item--ooOky .Feed-module--meta--ECIPa .Feed-module--category--DGEwP .Feed-module--link--GNuXE:hover{color:#5c92ff}.Feed-module--feed--3dYe7 .Feed-module--item--ooOky .Feed-module--more--Axk8-{color:#5c92ff;font-size:16px}.Feed-module--feed--3dYe7 .Feed-module--item--ooOky .Feed-module--more--Axk8-:focus,.Feed-module--feed--3dYe7 .Feed-module--item--ooOky .Feed-module--more--Axk8-:hover{border-bottom:1px solid #5c92ff;color:#5c92ff}.Layout-module--layout--36KWw{margin-left:auto;margin-right:auto;max-width:1070px}.Layout-module--layout--36KWw:before{content:"";display:table}.Layout-module--layout--36KWw:after{clear:both;content:"";display:table}.Page-module--page--2Y5e7{margin-bottom:52px}.Page-module--page--2Y5e7 .Page-module--inner--3HKeR{padding:26px 19.5px 0}.Page-module--page--2Y5e7 .Page-module--title--Z69a4{font-size:40px;font-weight:600;line-height:52px;margin-bottom:37.7px;margin-top:0}.Page-module--page--2Y5e7 .Page-module--body--hPYHN{font-size:16px;line-height:26px;margin:0 0 26px}@media screen and (min-width:685px){.Page-module--page--2Y5e7{width:calc(58.275% - 12.5px)}.Page-module--page--2Y5e7:nth-child(1n){clear:none;float:left;margin-right:30px}.Page-module--page--2Y5e7:last-child{margin-right:0}.Page-module--page--2Y5e7:nth-child(12n){float:right;margin-right:0}.Page-module--page--2Y5e7:nth-child(12n+1){clear:both}.Page-module--page--2Y5e7 .Page-module--inner--3HKeR{padding:32.5px 19.5px 0}}@media screen and (min-width:960px){.Page-module--page--2Y5e7{width:calc(66.6% - 10px)}.Page-module--page--2Y5e7:nth-child(1n){clear:none;float:left;margin-right:30px}.Page-module--page--2Y5e7:last-child{margin-right:0}.Page-module--page--2Y5e7:nth-child(3n){float:right;margin-right:0}.Page-module--page--2Y5e7:nth-child(3n+1){clear:both}.Page-module--page--2Y5e7 .Page-module--inner--3HKeR{padding:39px 26px 0}}.Pagination-module--pagination--3KtNE{display:flex;margin-top:52px}.Pagination-module--pagination--3KtNE .Pagination-module--previous--3Jp_8{text-align:left;width:50%}.Pagination-module--pagination--3KtNE .Pagination-module--previous--3Jp_8 .Pagination-module--previousLink--1mLDH{color:#f7a145;font-size:26px;font-weight:700}.Pagination-module--pagination--3KtNE .Pagination-module--previous--3Jp_8 .Pagination-module--previousLink--1mLDH:focus,.Pagination-module--pagination--3KtNE .Pagination-module--previous--3Jp_8 .Pagination-module--previousLink--1mLDH:hover{color:#5c92ff}.Pagination-module--pagination--3KtNE .Pagination-module--previous--3Jp_8 .Pagination-module--previousLink--1mLDH.Pagination-module--disable--4zAQA{color:#9b9b9b;pointer-events:none}.Pagination-module--pagination--3KtNE .Pagination-module--next--PX9hj{text-align:right;width:50%}.Pagination-module--pagination--3KtNE .Pagination-module--next--PX9hj .Pagination-module--nextLink--DTlD5{color:#f7a145;font-size:26px;font-weight:700}.Pagination-module--pagination--3KtNE .Pagination-module--next--PX9hj .Pagination-module--nextLink--DTlD5:focus,.Pagination-module--pagination--3KtNE .Pagination-module--next--PX9hj .Pagination-module--nextLink--DTlD5:hover{color:#5c92ff}.Pagination-module--pagination--3KtNE .Pagination-module--next--PX9hj .Pagination-module--nextLink--DTlD5.Pagination-module--disable--4zAQA{color:#9b9b9b;pointer-events:none}.Author-module--author--12DFk .Author-module--photo--1WT_U{background-clip:padding-box;border-radius:50%;display:inline-block;height:75px;margin-bottom:0;width:75px}.Author-module--author--12DFk .Author-module--title--2UdHe{font-size:18px;font-weight:600;line-height:29.25px;margin:13px 0}.Author-module--author--12DFk .Author-module--title--2UdHe .Author-module--link--1dqxo,.Author-module--author--12DFk .Author-module--title--2UdHe .Author-module--link--1dqxo:focus,.Author-module--author--12DFk .Author-module--title--2UdHe .Author-module--link--1dqxo:hover{color:#212121}.Author-module--author--12DFk .Author-module--subtitle--3HDSh{color:#878787;line-height:26px;margin-bottom:26px}.Icon-module--icon--fdMTB{fill:currentcolor;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;speak:none;stroke:currentcolor;stroke-width:0;display:inline-block;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1em;text-align:center;text-transform:none;width:1em}.Contacts-module--contacts--3rFuK{margin-bottom:26px}.Contacts-module--contacts--3rFuK .Contacts-module--list--3gIi_{display:flex;flex-flow:row wrap;flex-grow:0;flex-shrink:0;list-style:none;margin:13px 0;max-width:150px;padding:0}.Contacts-module--contacts--3rFuK .Contacts-module--list--3gIi_ .Contacts-module--item--3aZ8X{align-content:center;align-items:center;border:1px solid #ebebeb;border-radius:50%;display:flex;height:35px;justify-content:center;line-height:35px;margin:6.5px;padding:0;text-align:center;width:35px}.Contacts-module--contacts--3rFuK .Contacts-module--list--3gIi_ .Contacts-module--item--3aZ8X:nth-child(3n+1){margin-left:0}.Contacts-module--contacts--3rFuK .Contacts-module--list--3gIi_ .Contacts-module--item--3aZ8X .Contacts-module--link--2rGsi{border:0;color:#212121;display:flex}.Contacts-module--contacts--3rFuK .Contacts-module--list--3gIi_ .Contacts-module--item--3aZ8X .Contacts-module--link--2rGsi:focus,.Contacts-module--contacts--3rFuK .Contacts-module--list--3gIi_ .Contacts-module--item--3aZ8X .Contacts-module--link--2rGsi:hover{color:#5c92ff}.Copyright-module--copyright--1IQFN{color:#999;font-size:14px}.Menu-module--menu--3SbXJ{margin-bottom:26px}.Menu-module--menu--3SbXJ .Menu-module--list--1n4ZI{list-style:none;margin:0;padding:0}.Menu-module--menu--3SbXJ .Menu-module--list--1n4ZI .Menu-module--item--DDbJ8{margin:13px 0;padding:0}.Menu-module--menu--3SbXJ .Menu-module--list--1n4ZI .Menu-module--item--DDbJ8 .Menu-module--link--3lstV{border:0;color:#212121;font-size:16px;font-weight:400}.Menu-module--menu--3SbXJ .Menu-module--list--1n4ZI .Menu-module--item--DDbJ8 .Menu-module--link--3lstV:focus,.Menu-module--menu--3SbXJ .Menu-module--list--1n4ZI .Menu-module--item--DDbJ8 .Menu-module--link--3lstV:hover{border-bottom:1px solid #5c92ff;color:#5c92ff}.Menu-module--menu--3SbXJ .Menu-module--list--1n4ZI .Menu-module--item--DDbJ8 .Menu-module--link--3lstV.Menu-module--active--aYO_r{border-bottom:1px solid #212121;color:#212121}.Sidebar-module--sidebar--1NhQN{width:100%}.Sidebar-module--sidebar--1NhQN .Sidebar-module--inner--12iqG{padding:26px 19.5px 0;position:relative}@media screen and (min-width:685px){.Sidebar-module--sidebar--1NhQN{width:calc(41.625% - 17.5px)}.Sidebar-module--sidebar--1NhQN:nth-child(1n){clear:none;float:left;margin-right:30px}.Sidebar-module--sidebar--1NhQN:last-child{margin-right:0}.Sidebar-module--sidebar--1NhQN:nth-child(12n){float:right;margin-right:0}.Sidebar-module--sidebar--1NhQN:nth-child(12n+1){clear:both}.Sidebar-module--sidebar--1NhQN .Sidebar-module--inner--12iqG{padding:32.5px 19.5px 0}.Sidebar-module--sidebar--1NhQN .Sidebar-module--inner--12iqG:after{background:#e6e6e6;background:linear-gradient(180deg,#e6e6e6 0,#e6e6e6 48%,#fff);bottom:0;content:"";height:540px;position:absolute;right:-10px;top:30px;width:1px}}@media screen and (min-width:960px){.Sidebar-module--sidebar--1NhQN{width:calc(33.3% - 20px)}.Sidebar-module--sidebar--1NhQN:nth-child(1n){clear:none;float:left;margin-right:30px}.Sidebar-module--sidebar--1NhQN:last-child{margin-right:0}.Sidebar-module--sidebar--1NhQN:nth-child(3n){float:right;margin-right:0}.Sidebar-module--sidebar--1NhQN:nth-child(3n+1){clear:both}.Sidebar-module--sidebar--1NhQN .Sidebar-module--inner--12iqG{padding:39px}}.Author-module--author--2kT-Q{border-top:1px solid #e6e6e6;line-height:26px;margin-bottom:52px;margin-top:26px;max-width:640px;padding-top:26px}.Author-module--author--2kT-Q .Author-module--bio--2YX8- .Author-module--twitter--1B6I5{display:block;text-decoration:underline}@media screen and (min-width:685px){.Author-module--author--2kT-Q{margin-left:auto;margin-right:auto}}.Content-module--content--3dNJJ{margin:0 auto;max-width:945px;padding:0 13px}.Content-module--content--3dNJJ .Content-module--title--3vQh6{font-size:32px;font-weight:600;line-height:42.9px;margin:26px auto 0;max-width:640px;text-align:center}.Content-module--content--3dNJJ .Content-module--body--3LJXt figure{margin-bottom:26px}.Content-module--content--3dNJJ .Content-module--body--3LJXt figure blockquote{font-style:italic;margin-top:0;padding:26px 0;text-align:center}.Content-module--content--3dNJJ .Content-module--body--3LJXt figure blockquote p{font-size:26.9072px;line-height:39px;margin-bottom:26px;margin-top:0;max-width:640px}.Content-module--content--3dNJJ .Content-module--body--3LJXt a{text-decoration:underline}.Content-module--content--3dNJJ .Content-module--body--3LJXt *{margin-left:auto;margin-right:auto;max-width:640px}.Content-module--content--3dNJJ .Content-module--body--3LJXt h2>a{visibility:hidden}.Content-module--content--3dNJJ .Content-module--body--3LJXt img{max-width:100%}@media screen and (min-width:960px){.Content-module--content--3dNJJ{padding:0}.Content-module--content--3dNJJ .Content-module--title--3vQh6{font-size:48px;line-height:58.5px;margin-bottom:39px;margin-top:58.5px}.Content-module--content--3dNJJ .Content-module--body--3LJXt,.Content-module--content--3dNJJ .Content-module--body--3LJXt p{font-size:18px;line-height:29.25px;margin-bottom:29.25px}.Content-module--content--3dNJJ .Content-module--body--3LJXt h2>a{padding-right:26px;visibility:unset}}.Meta-module--meta--3YYBJ .Meta-module--date--U0EV3{font-style:italic}.Tags-module--tags--1r6Jk{margin-bottom:13px}.Tags-module--tags--1r6Jk .Tags-module--list--3a6Ka{list-style:none;padding:0}.Tags-module--tags--1r6Jk .Tags-module--list--3a6Ka .Tags-module--item--2JSXQ{display:inline-block;margin:13px 3.25px}@media screen and (min-width:685px){.Tags-module--tags--1r6Jk .Tags-module--list--3a6Ka .Tags-module--item--2JSXQ:first-child{margin-left:0;padding-left:0}}.Tags-module--tags--1r6Jk .Tags-module--list--3a6Ka .Tags-module--item--2JSXQ .Tags-module--link--hkiai{border:1px solid #e6e6e6;border-radius:20px;color:#212121;display:inline-block;height:35px;line-height:35px;padding:0 19.5px;text-decoration:none}.Tags-module--tags--1r6Jk .Tags-module--list--3a6Ka .Tags-module--item--2JSXQ .Tags-module--link--hkiai:focus,.Tags-module--tags--1r6Jk .Tags-module--list--3a6Ka .Tags-module--item--2JSXQ .Tags-module--link--hkiai:hover{color:#5c92ff}.Gallery-module--gallery--2g0Rf{grid-gap:.5em;display:grid;grid-auto-rows:16vw;grid-template-columns:repeat(4,1fr)}.Gallery-module--gallery--2g0Rf>*{box-shadow:0 2px 8px 0 rgba(0,0,0,.2),0 3px 20px 0 rgba(0,0,0,.19)}.Gallery-module--gallery--2g0Rf>:hover{cursor:pointer;-webkit-filter:blur(4px);filter:blur(4px);transition:all .5s ease}.Gallery-module--gallery--2g0Rf>:nth-child(6n+3){grid-column:span 1;grid-row:span 2}.Gallery-module--gallery--2g0Rf>:nth-child(6n+2),.Gallery-module--gallery--2g0Rf>:nth-child(6n+5),.Gallery-module--gallery--2g0Rf>:nth-child(6n+6){grid-column:span 2;grid-row:span 2}.Post-module--post--mo55f .Post-module--content--3cRzw{margin:0 auto}.Post-module--post--mo55f .Post-module--comments--2bE-0,.Post-module--post--mo55f .Post-module--footer--NpFTW{margin:0 auto;max-width:640px;padding:0 13px}.Post-module--post--mo55f .Post-module--button--27HfC{border:1px solid #e6e6e6;border-radius:20px;color:#212121;display:block;font-size:16px;font-weight:400;height:35px;line-height:35px;margin-left:auto;margin-right:auto;margin-top:26px;max-width:90px;padding:0 26px;text-align:center}.Post-module--post--mo55f .Post-module--button--27HfC:focus,.Post-module--post--mo55f .Post-module--button--27HfC:hover{color:#5c92ff}@media screen and (min-width:960px){.Post-module--post--mo55f .Post-module--comments--2bE-0,.Post-module--post--mo55f .Post-module--footer--NpFTW{padding:0}.Post-module--post--mo55f .Post-module--button--27HfC{left:30px;margin:0;max-width:none;position:fixed;top:30px}}</style><link rel="alternate" type="application/rss+xml" title="Blog by Jonathan Dai" href="/rss.xml"/><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><link rel="preconnect" href="https://www.googletagmanager.com"/><link rel="dns-prefetch" href="https://www.googletagmanager.com"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FHVTN0K4SH"></script><script>
      
      
      if(true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){window.dataLayer && window.dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-FHVTN0K4SH', {"send_page_view":false});
      }
      </script><link rel="sitemap" type="application/xml" href="/sitemap/sitemap-index.xml"/><link rel="icon" href="/favicon-32x32.png?v=bc5f0053fc3ffc2dfb62b5abaa975347" type="image/png"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="anonymous"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=bc5f0053fc3ffc2dfb62b5abaa975347"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=bc5f0053fc3ffc2dfb62b5abaa975347"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=bc5f0053fc3ffc2dfb62b5abaa975347"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=bc5f0053fc3ffc2dfb62b5abaa975347"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=bc5f0053fc3ffc2dfb62b5abaa975347"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=bc5f0053fc3ffc2dfb62b5abaa975347"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=bc5f0053fc3ffc2dfb62b5abaa975347"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=bc5f0053fc3ffc2dfb62b5abaa975347"/><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><title data-react-helmet="true">Docker Notes - Blog by Jonathan Dai</title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="Layout-module--layout--36KWw"><div class="Post-module--post--mo55f"><a class="Post-module--button--27HfC" href="/">All Articles</a><div class="Post-module--content--3cRzw"><div class="Content-module--content--3dNJJ"><h1 class="Content-module--title--3vQh6">Docker Notes</h1><div class="Content-module--body--3LJXt"><div class="table-of-contents">
<ul>
<li><a href="#1-%E5%89%8D%E8%A8%80">1. 前言</a></li>
<li><a href="#2-%E5%AE%89%E8%A3%85">2. 安装</a></li>
<li><a href="#3-%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93">3. 镜像仓库</a>
<ul>
<li><a href="#31-%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93">3.1 创建镜像仓库</a></li>
<li><a href="#32-login">3.2 login</a></li>
<li><a href="#33-push--pull">3.3 push &#x26; pull</a></li>
<li><a href="#34-list-tags">3.4 list tags</a></li>
</ul>
</li>
<li><a href="#4-%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8">4. 日常使用</a>
<ul>
<li><a href="#41-docker-images">4.1 docker images</a></li>
<li><a href="#42-docker-rmi">4.2 docker rmi</a></li>
<li><a href="#43-docker-ps--a">4.3 docker ps -a</a></li>
<li><a href="#44-docker-rm">4.4 docker rm</a></li>
<li><a href="#45-docker-build-id_docker_build">4.5 docker build {#ID_DOCKER_BUILD}</a>
<ul>
<li><a href="#451-%E9%95%9C%E5%83%8F%E5%91%BD%E5%90%8D%E5%8F%8Atag">4.5.1 镜像命名及tag</a></li>
<li><a href="#452-%E6%8C%87%E5%AE%9Adockerfile">4.5.2 指定Dockerfile</a></li>
<li><a href="#453-%E6%8C%87%E5%AE%9A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">4.5.3 指定全局变量</a></li>
<li><a href="#454-%E6%8C%87%E5%AE%9Aulimit">4.5.4 指定ulimit</a></li>
<li><a href="#455-%E6%8C%87%E5%AE%9A%E7%88%B6%E7%BA%A7cgroup">4.5.5 指定父级cgroup</a></li>
<li><a href="#456-%E6%B7%BB%E5%8A%A0etchosts">4.5.6 添加/etc/hosts</a></li>
<li><a href="#457-%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87%E7%8E%AF%E5%A2%83">4.5.7 构建目标环境</a></li>
<li><a href="#458-%E5%85%B6%E4%BB%96">4.5.8 其他</a>
<ul>
<li><a href="#%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%9B%B8%E5%85%B3%E4%BC%9A%E5%9C%A8%E5%90%8E%E9%9D%A2%E7%9A%84%E7%AB%A0%E8%8A%82%E6%B7%B1%E5%85%A5">资源限制相关（会在后面的章节深入）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#46-docker-run">4.6 docker run</a>
<ul>
<li><a href="#461-%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B">4.6.1 后台进程</a></li>
<li><a href="#462-%E6%8C%87%E5%AE%9A%E5%90%8D%E7%A7%B0">4.6.2 指定名称</a></li>
<li><a href="#463-%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE">4.6.3 网络设置</a></li>
<li><a href="#464-%E6%B7%BB%E5%8A%A0etchosts">4.6.4 添加/etc/hosts</a></li>
<li><a href="#465-%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5">4.6.5 重启策略</a></li>
<li><a href="#466-%E9%80%80%E5%87%BA%E4%BB%A3%E7%A0%81-exit-status">4.6.6 退出代码 Exit Status</a></li>
<li><a href="#467-%E9%80%80%E5%87%BA%E6%B8%85%E7%90%86">4.6.7 退出清理</a></li>
<li><a href="#468-%E5%AE%89%E5%85%A8%E9%80%89%E9%A1%B9">4.6.8 安全选项</a></li>
<li><a href="#469-%E6%9D%83%E9%99%90%E4%B8%8Elinux-capabilities">4.6.9 权限与Linux Capabilities</a></li>
<li><a href="#4610-%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA">4.6.10 日志输出</a></li>
<li><a href="#4611-%E8%A6%86%E7%9B%96dockerfile%E8%AE%BE%E7%BD%AE">4.6.11 覆盖Dockerfile设置</a></li>
<li><a href="#4612-%E5%85%B6%E4%BB%96">4.6.12 其他</a>
<ul>
<li><a href="#%E5%91%BD%E4%BB%A4%E6%B5%8B%E8%AF%95">命令测试</a></li>
<li><a href="#%E9%9A%94%E7%A6%BB%E4%B8%8E%E5%85%B1%E4%BA%AB">隔离与共享</a></li>
<li><a href="#%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%9B%B8%E5%85%B3%E4%BC%9A%E5%9C%A8%E5%90%8E%E9%9D%A2%E7%9A%84%E7%AB%A0%E8%8A%82%E6%B7%B1%E5%85%A5-1">资源限制相关（会在后面的章节深入）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#47-docker-attach">4.7 docker attach</a>
<ul>
<li><a href="#471-attach">4.7.1 attach</a></li>
<li><a href="#472-detach">4.7.2 detach</a></li>
</ul>
</li>
<li><a href="#48-docker-exec">4.8 docker exec</a></li>
<li><a href="#49-tips">4.9 tips</a></li>
</ul>
</li>
<li><a href="#5-dockerfile-id_dockerfile">5. Dockerfile {#ID_DOCKERFILE}</a>
<ul>
<li><a href="#51-dockerfile%E6%8C%87%E4%BB%A4">5.1 Dockerfile指令</a>
<ul>
<li><a href="#511-run-id_dockerfile_run">5.1.1 RUN {#ID_DOCKERFILE_RUN}</a></li>
<li><a href="#512-cmd--entrypoint">5.1.2 CMD &#x26; ENTRYPOINT</a></li>
<li><a href="#513-volume">5.1.3 VOLUME</a></li>
<li><a href="#514-arg">5.1.4 ARG</a></li>
<li><a href="#515-healthcheck">5.1.5 HEALTHCHECK</a></li>
<li><a href="#516-%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4">5.1.6 其他指令</a></li>
</ul>
</li>
<li><a href="#52-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">5.2 最佳实践</a>
<ul>
<li><a href="#521-%E7%BC%A9%E5%B0%8F%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E7%9A%84context">5.2.1 缩小镜像构建的Context</a></li>
<li><a href="#522-%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">5.2.2 使用多阶段构建</a></li>
<li><a href="#523-%E6%9E%84%E5%BB%BA%E7%9A%84%E7%BC%93%E5%AD%98">5.2.3 构建的缓存</a></li>
<li><a href="#524-%E9%95%9C%E5%83%8F%E5%B1%82%E7%9A%84%E5%88%9B%E5%BB%BA">5.2.4 镜像层的创建</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-image">6. Image</a></li>
<li><a href="#7-docker-machine">7. Docker Machine</a></li>
<li><a href="#8-%E6%B7%B1%E5%85%A5">8. 深入</a>
<ul>
<li><a href="#81-%E7%BD%91%E7%BB%9C">8.1 网络</a>
<ul>
<li><a href="#811-bridge">8.1.1 bridge</a></li>
<li><a href="#812-%E5%85%B6%E4%BB%96">8.1.2 其他</a></li>
<li><a href="#813-%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C">8.1.3 实践经验</a>
<ul>
<li><a href="#%E5%AE%B9%E5%99%A8ip">容器IP</a></li>
<li><a href="#%E5%AE%B9%E5%99%A8%E5%90%8D">容器名</a></li>
<li><a href="#expose-vs-publish">expose vs publish</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#82-%E5%AD%98%E5%82%A8-id_principle_storage">8.2 存储 {#ID_PRINCIPLE_STORAGE}</a>
<ul>
<li><a href="#821-%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84mount">8.2.1 几种类型的mount</a></li>
<li><a href="#822-%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4">8.2.2 日常使用命令</a></li>
<li><a href="#823-volumes">8.2.3 Volumes</a></li>
<li><a href="#824-bind-mounts">8.2.4 Bind mounts</a></li>
<li><a href="#825-storage-drivers">8.2.5 Storage drivers</a></li>
</ul>
</li>
<li><a href="#83-%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6-id_principle_resource">8.3 资源限制 {#ID_PRINCIPLE_RESOURCE}</a>
<ul>
<li><a href="#831-linux">8.3.1 Linux</a></li>
<li><a href="#832-docker">8.3.2 Docker</a></li>
<li><a href="#833-%E5%85%B6%E4%BB%96">8.3.3 其他</a></li>
</ul>
</li>
<li><a href="#84-%E7%9B%91%E6%8E%A7--metrics">8.4 监控 &#x26; Metrics</a>
<ul>
<li><a href="#841-official-guide">8.4.1 Official Guide</a></li>
<li><a href="#842-cadvisor">8.4.2 cAdvisor</a></li>
</ul>
</li>
<li><a href="#85-%E5%AE%89%E5%85%A8">8.5 安全</a></li>
<li><a href="#87-%E5%85%B6%E4%BB%96">8.7 其他</a></li>
</ul>
</li>
<li><a href="#9-os%E9%95%9C%E5%83%8F%E9%80%89%E6%8B%A9">9. OS镜像选择</a>
<ul>
<li><a href="#91-alpine">9.1 Alpine</a>
<ul>
<li><a href="#dns-issue">DNS issue</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#10-%E5%AE%9E%E8%B7%B5">10. 实践</a>
<ul>
<li><a href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E6%9C%AC%E6%9C%BA%E9%95%9C%E5%83%8F">列出所有本机镜像</a></li>
<li><a href="#%E5%88%97%E5%87%BA%E6%9C%AC%E6%9C%BA%E6%89%80%E6%9C%89%E5%AE%B9%E5%99%A8">列出本机所有容器</a></li>
<li><a href="#%E5%88%97%E5%87%BA%E6%9C%AC%E6%9C%BA%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5">列出本机磁盘使用情况</a></li>
<li><a href="#%E6%9C%AC%E6%9C%BA%E7%A9%BA%E9%97%B4%E6%B8%85%E7%90%86">本机空间清理</a></li>
<li><a href="#%E6%9C%AC%E6%9C%BA%E9%95%9C%E5%83%8F%E6%B8%85%E7%90%86">本机镜像清理</a></li>
<li><a href="#%E6%9C%AC%E6%9C%BA%E5%8D%B7%E6%B8%85%E7%90%86">本机卷清理</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E9%A9%B1%E5%8A%A8%E5%8F%8A%E5%AE%B9%E9%87%8F%E8%AE%BE%E7%BD%AE">日志驱动及容量设置</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%99%A8%E5%88%97%E8%A1%A8">查看网络内容器列表</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%89%80%E5%B1%9E%E7%BD%91%E7%BB%9C">查看容器所属网络</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81">查看容器运行状态</a></li>
</ul>
</li>
<li><a href="#11-swarm%E9%9B%86%E7%BE%A4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">11. Swarm集群解决方案</a>
<ul>
<li><a href="#111-overview">11.1 Overview</a></li>
<li><a href="#112-network">11.2 Network</a></li>
<li><a href="#113-%E4%B8%AD%E6%96%87%E7%B3%BB%E5%88%97%E5%8D%9A%E6%96%87">11.3 中文系列博文</a></li>
<li><a href="#114-%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C%E7%BB%8F%E9%AA%8C">11.4 实际操作经验</a>
<ul>
<li><a href="#1141-%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8Bdocker%E7%8E%AF%E5%A2%83">11.4.1 创建远程docker环境</a></li>
<li><a href="#1142-%E6%8A%B9%E9%99%A4%E8%BF%9C%E7%A8%8Bdocker%E7%8E%AF%E5%A2%83">11.4.2 抹除远程docker环境</a></li>
<li><a href="#1143-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C">11.4.3 远程命令执行</a></li>
<li><a href="#1144-swarm%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86">11.4.4 Swarm集群管理</a></li>
<li><a href="#1145-service">11.4.5 Service</a></li>
<li><a href="#1146-stack">11.4.6 Stack</a></li>
<li><a href="#1147-%E7%8A%B6%E6%80%81%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4">11.4.7 状态查看命令</a></li>
</ul>
</li>
<li><a href="#115-issues">11.5 Issues</a></li>
</ul>
</li>
<li><a href="#12-%E5%85%B6%E4%BB%96">12. 其他</a>
<ul>
<li><a href="#121-%E4%BB%80%E4%B9%88%E6%98%AFdocker-host">12.1 什么是docker host</a></li>
<li><a href="#122-comdockerhyperkit-x00-cpu-consumption-mac">12.2 com.docker.hyperkit X00% cpu consumption MAC</a></li>
</ul>
</li>
<li><a href="#%E8%B5%84%E6%96%99">资料</a>
<ul>
<li><a href="#docker%E5%AE%98%E6%96%B9">Docker官方</a></li>
<li><a href="#docker%E5%91%BD%E4%BB%A4">Docker命令</a></li>
<li><a href="#%E9%95%9C%E5%83%8F%E7%9B%B8%E5%85%B3">镜像相关</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
<li><a href="#docker-info-id_app_docker_info">docker info {#ID_APP_DOCKER_INFO}</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="1-前言" style="position:relative;"><a href="#1-%E5%89%8D%E8%A8%80" aria-label="1 前言 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. 前言</h1>
<p>云原生概念风生云起，最近算是非常火热，而其最基本的依仗就在于能将任何程序运行在轻量级Cell上的容器Docker。Docker如果仅只是使用的话，是一点都不难的，但作为一个所有应用程序运行其上的基石，对其的细节了解是非常有必要的。</p>
<p>本文会记录从最基本的Docker基础，到日常的工作操作，到比较深入的原理细节，都会有所涉及。</p>
<p>版本信息如下：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker version
Client: Docker Engine - Community
 Version:           18.09.2
 API version:       1.39
 Go version:        go1.10.8
 Git commit:        6247962
 Built:             Sun Feb 10 04:12:39 2019
 OS/Arch:           darwin/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          18.09.2
  API version:      1.39 (minimum version 1.12)
  Go version:       go1.10.6
  Git commit:       6247962
  Built:            Sun Feb 10 04:13:06 2019
  OS/Arch:          linux/amd64
  Experimental:     false</code></pre></div>
<p>此外，<a href="#ID_APP_DOCKER_INFO">docker info</a>比较长，就不贴这里了，放在下面的资料部分。简单看了下应该是不带敏感信息的，这部分应该是做了剔除的。</p>
<p>这里顺道加一个非常重要的文档：<a href="https://github.com/docker/labs" target="_blank" rel="nofollow noopener noreferrer">Docker Tutorials and Labs</a>。这个文档库里存放的是docker官方的tutorial以及一些架构设计等的资料。对于想要深入的读者来说是非常重要的资料。</p>
<h1 id="2-安装" style="position:relative;"><a href="#2-%E5%AE%89%E8%A3%85" aria-label="2 安装 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. 安装</h1>
<p>MAC下的安装比较简单，直接下载Docker官方的桌面版本即可：<a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank" rel="nofollow noopener noreferrer">Docker Desktop for Mac</a>。文档在：<a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="nofollow noopener noreferrer">Get started with Docker Desktop for Mac</a>。</p>
<p>此外，为了能使用（下载）一些官方（软件公司）发布镜像文件，你需要注册一个docker hub账号（其实也就是docker官方账号）：<a href="https://hub.docker.com" target="_blank" rel="nofollow noopener noreferrer">docker hub</a>。</p>
<h1 id="3-镜像仓库" style="position:relative;"><a href="#3-%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93" aria-label="3 镜像仓库 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. 镜像仓库</h1>
<p>Docker的核心功能点之一就是能将部署这个事情代码化。本来运维的工作中充斥着各种不确定性，版本不兼容、软件包不同、Linux内核不同导致的安装问题，等等。而Docker可以使用Dockerfile将一个镜像的制作（以代码形式）固定下来，保证只要是一份Dockerfile，制作出来的镜像是完全一致的。</p>
<p>此外，只要保证Docker的版本一致，docker镜像的运行状态及结果是可预期的。这就保证了一个软件的研发流程中，只要镜像被制作完成了，后续就可以使用这个镜像文件进行分发了，不再需要每个部署环境都从Dockerfile从头开始制作一份本地的镜像。</p>
<p>而分发这个过程就需要镜像仓库的介入：本地制作镜像 => 上传镜像到仓库 => 部署服务器拉取镜像 => 部署服务器本地运行镜像。</p>
<p>Docker官方有一个开放的<a href="https://hub.docker.com" target="_blank" rel="nofollow noopener noreferrer">镜像仓库</a>，一般知名的第三方软件提供者都会将自己软件的镜像文件发布到这个开放的仓库中，方便第三方使用者下载。当然，私有仓库对于大部分软件公司来说都是必须的。</p>
<h2 id="31-创建镜像仓库" style="position:relative;"><a href="#31-%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93" aria-label="31 创建镜像仓库 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.1 创建镜像仓库</h2>
<p>制作一个私有的镜像仓库非常简单，直接使用docker命令即可，官方文档在：<a href="https://docs.docker.com/registry/" target="_blank" rel="nofollow noopener noreferrer">Docker Registry</a>。</p>
<p>运行：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">docker run -d -p 5000:5000 --name registry registry:2</code></pre></div>
<p>这样就在<code class="language-text">localhost:5000</code>运行了一个镜像仓库。</p>
<h2 id="32-login" style="position:relative;"><a href="#32-login" aria-label="32 login permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.2 login</h2>
<p>从镜像仓库获得镜像以及上传镜像都需要有对应的身份认证。使用：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker login --help

Usage:	docker login [OPTIONS] [SERVER]

Log in to a Docker registry

Options:
  -p, --password string   Password
      --password-stdin    Take the password from stdin
  -u, --username string   Username</code></pre></div>
<p>即便是从官方镜像仓库获取镜像也是需要认证的，所以一开始需要注册一个账号。如果使用的是Docker Desktop的话，可以从UI界面上进行登录。</p>
<p>如果登录的是私有仓库，<code class="language-text">[SERVER]</code>这块需要输入私有仓库地址。</p>
<h2 id="33-push--pull" style="position:relative;"><a href="#33-push--pull" aria-label="33 push  pull permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.3 push &#x26; pull</h2>
<p>如果是从私有仓库上进行对应的拉取和推送镜像，需要在镜像名字之前补完仓库地址：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">docker push localhost:5000/imagename:major.minor.patch
docker pull localhost:5000/imagename:major.minor.patch</code></pre></div>
<h2 id="34-list-tags" style="position:relative;"><a href="#34-list-tags" aria-label="34 list tags permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.4 list tags</h2>
<p>docker的命令行工具没有提供查询一个镜像所有tags的命令（ridiculous），可以使用以下方法来查询：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"># require tool jq
brew update --verbose
brew install jq --verbose

curl -s https://registry.hub.docker.com/v2/repositories/${repo_name}/tags/?page_size=1024 | jq .
# sample repo_name: elastic/filebeat</code></pre></div>
<h1 id="4-日常使用" style="position:relative;"><a href="#4-%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8" aria-label="4 日常使用 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4. 日常使用</h1>
<h2 id="41-docker-images" style="position:relative;"><a href="#41-docker-images" aria-label="41 docker images permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.1 docker images</h2>
<p>显示所有镜像（本地）</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              18.10               b977ae81df17        2 weeks ago         73.9MB</code></pre></div>
<h2 id="42-docker-rmi" style="position:relative;"><a href="#42-docker-rmi" aria-label="42 docker rmi permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.2 docker rmi</h2>
<p>删除镜像，可以同时删除多个，给的名字可以是镜像名也可以是镜像id</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker rmi imagename imageid ...</code></pre></div>
<h2 id="43-docker-ps--a" style="position:relative;"><a href="#43-docker-ps--a" aria-label="43 docker ps  a permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.3 docker ps -a</h2>
<p>可以显示所有的容器（本地），包括不在运行状态的。<code class="language-text">-a</code>一般来说是必须的，否则无法将停止状态的镜像也列出来。</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker ps -a</code></pre></div>
<h2 id="44-docker-rm" style="position:relative;"><a href="#44-docker-rm" aria-label="44 docker rm permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.4 docker rm</h2>
<p>删除容器，可以同时删除多个，给的名字可以是容器名也可以是容器id</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker rm containername containerid ...</code></pre></div>
<h2 id="45-docker-build-id_docker_build" style="position:relative;"><a href="#45-docker-build-id_docker_build" aria-label="45 docker build id_docker_build permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.5 docker build {#ID_DOCKER_BUILD}</h2>
<p>从一个Dockerfile构建一个镜像，一般都会进入到Dockerfile同一层目录进行构建：<code class="language-text">docker build [OPTIONS] .</code>，这里的<code class="language-text">.</code>就是Dockerfile的路径。全选项参数可以通过：<code class="language-text">docker build --help</code>来获得，这里就不贴了。</p>
<p>细节相当多，有需要的可以看下官方文档：<a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank" rel="nofollow noopener noreferrer">docker build</a>。</p>
<p>此外，docker build命令与Dockerfile息息相关，部分优化相关内容描述在Dockerfile内，请去此处查看：<a href="#ID_DOCKERFILE">5. Dockerfile</a>。</p>
<h3 id="451-镜像命名及tag" style="position:relative;"><a href="#451-%E9%95%9C%E5%83%8F%E5%91%BD%E5%90%8D%E5%8F%8Atag" aria-label="451 镜像命名及tag permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.5.1 镜像命名及tag</h3>
<p>通过<code class="language-text">-t</code>在构建的时候对镜像进行命名，并打上标签。一般来说这是必须的，方便后续进行镜像查找和仓库内巨量镜像的维护。</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker build -t imagename:major.minor.patch .</code></pre></div>
<h3 id="452-指定dockerfile" style="position:relative;"><a href="#452-%E6%8C%87%E5%AE%9Adockerfile" aria-label="452 指定dockerfile permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.5.2 指定Dockerfile</h3>
<p>通过<code class="language-text">-f</code>指定镜像文件路径。</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker build -f yourrepo/Dockerfile .</code></pre></div>
<h3 id="453-指定全局变量" style="position:relative;"><a href="#453-%E6%8C%87%E5%AE%9A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F" aria-label="453 指定全局变量 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.5.3 指定全局变量</h3>
<p>在构建镜像的时候为了对内部的应用程序提供一些配置，常用环境变量的方式进行注入，而在镜像构建的时候，可以使用<code class="language-text">--build-args XXX=...</code>这样的方式进行操作。</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker build --build-arg HTTP_PROXY=http://10.20.30.2:1234 --build-arg FTP_PROXY=http://40.50.60.5:4567 .</code></pre></div>
<p>如果是裸用Docker的话，这样的操作还算是比较容易理解的，但一般来说大型分布系统肯定还使用了K8S这样的容器管理系统或者还甚至用了类似于Istio这样的服务编排系统，就不需要在制作镜像的时候这么弄了。</p>
<h3 id="454-指定ulimit" style="position:relative;"><a href="#454-%E6%8C%87%E5%AE%9Aulimit" aria-label="454 指定ulimit permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.5.4 指定ulimit</h3>
<p>通过<code class="language-text">--ulimit</code>来指定该镜像文件在运行时候的ulimit。</p>
<h3 id="455-指定父级cgroup" style="position:relative;"><a href="#455-%E6%8C%87%E5%AE%9A%E7%88%B6%E7%BA%A7cgroup" aria-label="455 指定父级cgroup permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.5.5 指定父级cgroup</h3>
<p>通过<code class="language-text">--cgroup-parent</code>来指定该镜像文件在运行时候的资源限制群组。关于cgroup这个话题，后面会专门起一个章节来深入。详见：<a href="#ID_PRINCIPLE_RESOURCE">8.3 资源限制</a>。</p>
<h3 id="456-添加etchosts" style="position:relative;"><a href="#456-%E6%B7%BB%E5%8A%A0etchosts" aria-label="456 添加etchosts permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.5.6 添加/etc/hosts</h3>
<p>通过<code class="language-text">--add-host=domain.com:10.180.0.1</code>来向/etc/hosts里添加匹配。</p>
<h3 id="457-构建目标环境" style="position:relative;"><a href="#457-%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87%E7%8E%AF%E5%A2%83" aria-label="457 构建目标环境 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.5.7 构建目标环境</h3>
<p>通过<code class="language-text">--target</code>来指定构建的目标环境：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">FROM debian AS build-env
...

FROM alpine AS production-env
...</code></pre></div>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker build -t mybuildimage --target build-env .</code></pre></div>
<h3 id="458-其他" style="position:relative;"><a href="#458-%E5%85%B6%E4%BB%96" aria-label="458 其他 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.5.8 其他</h3>
<ul>
<li><code class="language-text">--no-cache</code>：在构建镜像的时候不使用cache，在频繁更新某个镜像时很有用，防止cache污染</li>
<li><code class="language-text">--ssh</code>：SSH agent socket or keys to expose to the build (only if BuildKit enabled) (format: default|[=|[,]])</li>
</ul>
<h4 id="资源限制相关会在后面的章节深入" style="position:relative;"><a href="#%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%9B%B8%E5%85%B3%E4%BC%9A%E5%9C%A8%E5%90%8E%E9%9D%A2%E7%9A%84%E7%AB%A0%E8%8A%82%E6%B7%B1%E5%85%A5" aria-label="资源限制相关会在后面的章节深入 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>资源限制相关（会在后面的章节深入）</h4>
<ul>
<li><code class="language-text">--cpu-period</code>：Limit the CPU CFS (Completely Fair Scheduler) period</li>
<li><code class="language-text">--cpu-quota</code>：Limit the CPU CFS (Completely Fair Scheduler) quota</li>
<li><code class="language-text">--cpu-shares</code>：CPU shares (relative weight)</li>
<li><code class="language-text">--cpuset-cpus</code>：CPUs in which to allow execution (0-3, 0,1)</li>
<li><code class="language-text">--cpuset-mems</code>：MEMs in which to allow execution (0-3, 0,1)</li>
<li><code class="language-text">--memory</code>：Memory limit</li>
<li><code class="language-text">--memory-swap</code>：Swap limit equal to memory plus swap: ‘-1’ to enable unlimited swap</li>
</ul>
<p>详见：<a href="#ID_PRINCIPLE_RESOURCE">8.3 资源限制</a>。</p>
<h2 id="46-docker-run" style="position:relative;"><a href="#46-docker-run" aria-label="46 docker run permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.6 docker run</h2>
<p>将镜像运行成容器的命令，虽然是一个很简单的命令，但细节相当多，用起来其实还蛮麻烦的。全选项参数可以通过：<code class="language-text">docker run --help</code>来获得，这里就不贴了。中文的帖子也有，可以看了参考：<a href="https://www.jianshu.com/p/ea4a00c6c21c" target="_blank" rel="nofollow noopener noreferrer">Docker run 命令参数及使用</a></p>
<p>细节相当多，有需要的可以看下官方文档：<a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="nofollow noopener noreferrer">docker run</a>。</p>
<p>命令的基本使用格式：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker run [OPTIONS] IMAGE[:TAG\|@DIGEST] [COMMAND] [ARG...]</code></pre></div>
<h3 id="461-后台进程" style="position:relative;"><a href="#461-%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B" aria-label="461 后台进程 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.6.1 后台进程</h3>
<p>通过<code class="language-text">-d</code>来让docker run命令运行起来的容器转为后台常驻进程。</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker run -d -p 80:80 my_image service nginx start</code></pre></div>
<h3 id="462-指定名称" style="position:relative;"><a href="#462-%E6%8C%87%E5%AE%9A%E5%90%8D%E7%A7%B0" aria-label="462 指定名称 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.6.2 指定名称</h3>
<p>通过<code class="language-text">--name</code>来让docker run命名运行起来的容器，后续可以使用这个名字来访问这个启动的容器，不再需要<code class="language-text">docker ps -a</code>查找这个容器的UUID。在使用同一个镜像启动多个容器的时候特别有用。</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker run --name myconname -d ubuntu:18.10</code></pre></div>
<h3 id="463-网络设置" style="position:relative;"><a href="#463-%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE" aria-label="463 网络设置 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.6.3 网络设置</h3>
<p>网络这块相关的配置内容也非常多，细节的内容建议直接阅读官方的文档：<a href="https://docs.docker.com/engine/reference/run/#network-settings" target="_blank" rel="nofollow noopener noreferrer">docker run > Network settings</a>。</p>
<p><code class="language-text">--network=...</code>用来控制网络模式：</p>
<ul>
<li><code class="language-text">none</code>：No networking in the container.</li>
<li><code class="language-text">bridge (default)</code>：Connect the container to the bridge via veth interfaces.</li>
<li><code class="language-text">host</code>：Use the host’s network stack inside the container.</li>
<li><code class="language-text">container:&lt;name\|id></code>：Use the network stack of another container, specified via its name or id.</li>
<li><code class="language-text">NETWORK</code>：Connects the container to a user created network (using docker network create command)</li>
</ul>
<h3 id="464-添加etchosts" style="position:relative;"><a href="#464-%E6%B7%BB%E5%8A%A0etchosts" aria-label="464 添加etchosts permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.6.4 添加/etc/hosts</h3>
<p>参数同docker build命令，但很奇怪的是docker官方给出的例子这里倒是没有<code class="language-text">=</code>：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker run -it --add-host domain.com:10.180.0.1 ubuntu cat /etc/hosts</code></pre></div>
<h3 id="465-重启策略" style="position:relative;"><a href="#465-%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5" aria-label="465 重启策略 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.6.5 重启策略</h3>
<p>通过<code class="language-text">--restart</code>可以让docker run启动的容器在退出之后按策略重启。官方文档在：<a href="https://docs.docker.com/engine/reference/run/#restart-policies---restart" target="_blank" rel="nofollow noopener noreferrer">docker run > Restart policies (—restart)</a>。</p>
<ul>
<li><code class="language-text">no</code>：Do not automatically restart the container when it exits. This is the default.</li>
<li><code class="language-text">on-failure[:max-retries]</code>：Restart only if the container exits with a non-zero exit status. Optionally, limit the number of restart retries the Docker daemon attempts.</li>
<li><code class="language-text">always</code>：Always restart the container regardless of the exit status. When you specify always, the Docker daemon will try to restart the container indefinitely. The container will also always start on daemon startup, regardless of the current state of the container.</li>
<li><code class="language-text">unless-stopped</code>：Always restart the container regardless of the exit status, including on daemon startup, except if the container was put into a stopped state before the Docker daemon was stopped.</li>
</ul>
<p>该选项与<code class="language-text">--rm</code>是冲突的。</p>
<h3 id="466-退出代码-exit-status" style="position:relative;"><a href="#466-%E9%80%80%E5%87%BA%E4%BB%A3%E7%A0%81-exit-status" aria-label="466 退出代码 exit status permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.6.6 退出代码 Exit Status</h3>
<p>接上面的重试策略，<code class="language-text">on-failure</code>会检查退出代码。官方文档在：<a href="https://docs.docker.com/engine/reference/run/#exit-status" target="_blank" rel="nofollow noopener noreferrer">docker run > Exit Status</a>。</p>
<h3 id="467-退出清理" style="position:relative;"><a href="#467-%E9%80%80%E5%87%BA%E6%B8%85%E7%90%86" aria-label="467 退出清理 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.6.7 退出清理</h3>
<p>通过<code class="language-text">--rm</code>可以让docker run启动的容器在退出之后删除所有的留存信息。如果没有加这个参数的话，在容器退出、停止之后使用<code class="language-text">docker ps -a</code>可以找到刚才启动的容器。这对于测试来说是很麻烦的，每次停止之后还要使用<code class="language-text">docker rm</code>命令删除。这时候就可以通过<code class="language-text">--rm</code>来命令容器退出后自动清理：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"># not cleanup
$ docker run -i -t ubuntu:18.10 ps afx
$ docker ps -a

# cleanup
$ docker run -i -t --rm ubuntu:18.10 ps afx
$ docker ps -a</code></pre></div>
<h3 id="468-安全选项" style="position:relative;"><a href="#468-%E5%AE%89%E5%85%A8%E9%80%89%E9%A1%B9" aria-label="468 安全选项 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.6.8 安全选项</h3>
<p>参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#security-configuration" target="_blank" rel="nofollow noopener noreferrer">docker run > Security configuration</a>。</p>
<h3 id="469-权限与linux-capabilities" style="position:relative;"><a href="#469-%E6%9D%83%E9%99%90%E4%B8%8Elinux-capabilities" aria-label="469 权限与linux capabilities permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.6.9 权限与Linux Capabilities</h3>
<p>参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities" target="_blank" rel="nofollow noopener noreferrer">docker run > Runtime privilege and Linux capabilities</a>。后续详见：<a href="#ID_PRINCIPLE_RESOURCE">8.3 资源限制</a>。</p>
<h3 id="4610-日志输出" style="position:relative;"><a href="#4610-%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA" aria-label="4610 日志输出 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.6.10 日志输出</h3>
<p>通过<code class="language-text">--log-driver</code>容器可以指定和docker daemon不同的日志输出设备。参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#logging-drivers---log-driver" target="_blank" rel="nofollow noopener noreferrer">Logging drivers (—log-driver)</a>。</p>
<h3 id="4611-覆盖dockerfile设置" style="position:relative;"><a href="#4611-%E8%A6%86%E7%9B%96dockerfile%E8%AE%BE%E7%BD%AE" aria-label="4611 覆盖dockerfile设置 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.6.11 覆盖Dockerfile设置</h3>
<p>主要是以下几项：</p>
<ul>
<li>CMD (Default Command or Options)</li>
<li>ENTRYPOINT (Default Command to Execute at Runtime)</li>
<li>EXPOSE (Incoming Ports)</li>
<li>ENV (Environment Variables)</li>
<li>HEALTHCHECK</li>
<li>VOLUME (Shared Filesystems)</li>
<li>USER</li>
<li>WORKDIR</li>
</ul>
<p>细节参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#overriding-dockerfile-image-defaults" target="_blank" rel="nofollow noopener noreferrer">Overriding Dockerfile image defaults</a>。</p>
<h3 id="4612-其他" style="position:relative;"><a href="#4612-%E5%85%B6%E4%BB%96" aria-label="4612 其他 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.6.12 其他</h3>
<h4 id="命令测试" style="position:relative;"><a href="#%E5%91%BD%E4%BB%A4%E6%B5%8B%E8%AF%95" aria-label="命令测试 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>命令测试</h4>
<p>使用如下命令可以启动容器之后执行命令进行测试，并在退出之后自动清理刚才生成的容器。</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker run --rm -i -t $image_name:$version $command</code></pre></div>
<h4 id="隔离与共享" style="position:relative;"><a href="#%E9%9A%94%E7%A6%BB%E4%B8%8E%E5%85%B1%E4%BA%AB" aria-label="隔离与共享 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>隔离与共享</h4>
<ul>
<li>—pid</li>
<li>—uts</li>
<li>—ipc</li>
</ul>
<p>容器之间拥有自己的PID命名空间，并相互隔离。通过<code class="language-text">--pid=...</code>可以让容器之间共享进程。具体的例子可以直接阅读官方的文档：<a href="https://docs.docker.com/engine/reference/run/#pid-settings---pid" target="_blank" rel="nofollow noopener noreferrer">PID settings (—pid)</a>。</p>
<p>简单的例子可以尝试（看下输出的内容有什么不同）：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"># without pid
$ docker run -i -t --rm ubuntu:18.10 ps afx
...

# with pid
$ docker run -i -t --rm --pid=host ubuntu:18.10 ps afx
...</code></pre></div>
<p><code class="language-text">--uts</code>和<code class="language-text">--ipc</code>也是类似的，可以参考官方文档里的：<a href="https://docs.docker.com/engine/reference/run/#uts-settings---uts" target="_blank" rel="nofollow noopener noreferrer">UTS settings (—uts)</a>和<a href="https://docs.docker.com/engine/reference/run/#ipc-settings---ipc" target="_blank" rel="nofollow noopener noreferrer">IPC settings (—ipc)</a>。中文资料可以看：<a href="https://www.centos.bz/2017/01/docker-run-uts-ipc/" target="_blank" rel="nofollow noopener noreferrer">Docker run参考(5) – UTS(–uts)和IPC (–ipc)设置</a>。</p>
<h4 id="资源限制相关会在后面的章节深入-1" style="position:relative;"><a href="#%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%9B%B8%E5%85%B3%E4%BC%9A%E5%9C%A8%E5%90%8E%E9%9D%A2%E7%9A%84%E7%AB%A0%E8%8A%82%E6%B7%B1%E5%85%A5-1" aria-label="资源限制相关会在后面的章节深入 1 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>资源限制相关（会在后面的章节深入）</h4>
<p>参见官方文档：<a href="https://docs.docker.com/engine/reference/run/#runtime-constraints-on-resources" target="_blank" rel="nofollow noopener noreferrer">docker run > Runtime constraints on resources</a>。后续详见：<a href="#ID_PRINCIPLE_RESOURCE">8.3 资源限制</a>。</p>
<h2 id="47-docker-attach" style="position:relative;"><a href="#47-docker-attach" aria-label="47 docker attach permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.7 docker attach</h2>
<h3 id="471-attach" style="position:relative;"><a href="#471-attach" aria-label="471 attach permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.7.1 attach</h3>
<p>将本地的输入输出及错误流附到一个运行中的容器上。简单来说可以理解为：进入到容器的命令行中。</p>
<p>如果需要在一个容器启动之后连上去的话，需要容器在启动（<code class="language-text">docker run</code>）的时候指定：<code class="language-text">-i -t</code>参数：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker run -i -t -d --rm ubuntu:18.10</code></pre></div>
<p>这样就可以在之后使用<code class="language-text">docker attach</code>命令附到该容器上并打开命令行了：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS
80172e3d5574        ubuntu:18.10        "/bin/bash"         38 seconds ago      Up 37 seconds

$ docker attach 80172e3d5574
root@80172e3d5574:/#</code></pre></div>
<h3 id="472-detach" style="position:relative;"><a href="#472-detach" aria-label="472 detach permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.7.2 detach</h3>
<p>新手常犯的一个错误就是使用<code class="language-text">exit</code>命令退出附上的shell，结果就是非但退出了shell还把容器本身给stop了。正确的做法是在shell里<code class="language-text">ctrl+p</code>然后<code class="language-text">ctrl+q</code>，这里切记是先按p的组合键，然后按q的组合键，而不是同时<code class="language-text">ctrl+p+q</code>。</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker attach f269e680ae14
root@f269e680ae14:/# 
# ctrl+p &amp; ctrl+q
root@f269e680ae14:/# read escape sequence
$ </code></pre></div>
<p>资料：</p>
<ul>
<li><a href="https://stackoverflow.com/a/19689048" target="_blank" rel="nofollow noopener noreferrer">How do you attach and detach from Docker’s process?</a></li>
</ul>
<h2 id="48-docker-exec" style="position:relative;"><a href="#48-docker-exec" aria-label="48 docker exec permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.8 docker exec</h2>
<p>在一个已经处于<code class="language-text">运行中</code>状态的容器里执行一条命令。</p>
<p>一般来说，如果是有连续工作的话，还是会使用<code class="language-text">docker attach</code>附上去之后再操作。但如果仅只是一两句命令，或自动化的脚本，就需要使用到<code class="language-text">docker exec</code>了。这里需要注意，exec只能用在running的容器上，如果没有容器且需要执行命令测试的话，也可以使用<code class="language-text">docker run</code>命令，直接附带上需要执行的命令即可。</p>
<p>也有有趣的用法：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker exec -it e8c541f9fb33 /bin/bash</code></pre></div>
<p>这条语句的效果和<code class="language-text">docker attach</code>是一致的。</p>
<p>在某些不能以<code class="language-text">/bin/bash</code>作为命令启动的镜像（默认入口已经在Dockerfile里指定了，这种情况还蛮多的，稍微复杂点的镜像一般都会把入口设置掉)，比如说Elasticsearch、nginx，等等。在这种情况下，如果需要attach到这个运行中的镜像，就必须使用exec了：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker exec -it e8c541f9fb33 /bin/sh</code></pre></div>
<p>此外，以Alpine镜像为基础的镜像，默认是<code class="language-text">没有/bin/bash</code>的，这种时候就需要换成<code class="language-text">/bin/sh</code>。</p>
<h2 id="49-tips" style="position:relative;"><a href="#49-tips" aria-label="49 tips permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.9 tips</h2>
<ul>
<li>做开发的时候可以把镜像构建多包几层，一层层做成镜像存在本地。后面的build可以直接from前面的，节约docker build失败之后的重新测试时间。否则中间一个步骤出错，很多耗时很长的源码编译工作就要从头来一次，太伤</li>
<li>node.js docker里的npm安装记得要加上<code class="language-text">--unsafe-perm</code>，具体可以看：<a href="https://github.com/grpc/grpc-node/issues/604" target="_blank" rel="nofollow noopener noreferrer">grpc/grpc-node#604</a></li>
</ul>
<h1 id="5-dockerfile-id_dockerfile" style="position:relative;"><a href="#5-dockerfile-id_dockerfile" aria-label="5 dockerfile id_dockerfile permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5. Dockerfile {#ID_DOCKERFILE}</h1>
<p>Dockerfile是用来进行镜像构建的文本文件，也是docker能将构建整个过程转化为文本固定下来的关键，可以说是docker能如此风靡的核心功能点也不为过。</p>
<p>官方的文档：</p>
<ul>
<li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="nofollow noopener noreferrer">Dockerfile reference</a></li>
<li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="nofollow noopener noreferrer">Best practices for writing Dockerfiles</a></li>
</ul>
<p>下面行文不会过于注重Dockerfile如何编写的语法，因为这东西你看看手册和几个例子也就会了。主要还是关注在几个比较麻烦的概念上。</p>
<p>几点零碎的：</p>
<ul>
<li>Dockerfile里类似<code class="language-text">COPY</code>、<code class="language-text">EXPOSE</code>之类的，都被称为指令（instruction），这个单词可以了解下</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" target="_blank" rel="nofollow noopener noreferrer">.dockerignore file</a></li>
<li>因为在build命令执行之前，当前指定PATH的context会被发送给docker daemon，因此文件夹越小执行越效率</li>
</ul>
<h2 id="51-dockerfile指令" style="position:relative;"><a href="#51-dockerfile%E6%8C%87%E4%BB%A4" aria-label="51 dockerfile指令 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5.1 Dockerfile指令</h2>
<h3 id="511-run-id_dockerfile_run" style="position:relative;"><a href="#511-run-id_dockerfile_run" aria-label="511 run id_dockerfile_run permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5.1.1 RUN {#ID_DOCKERFILE_RUN}</h3>
<p>官方文档：<a href="https://docs.docker.com/engine/reference/builder/#run" target="_blank" rel="nofollow noopener noreferrer">RUN</a>。</p>
<p>运行指令，有两种语法模式：</p>
<ul>
<li>RUN <command> (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)</li>
<li>RUN [“executable”, “param1”, “param2”] (exec form)</li>
</ul>
<p>这里需要注意<code class="language-text">exec模式</code>并不是在shell里运行的：</p>
<blockquote>
<p>Note: Unlike the shell form, the exec form does not invoke a command shell. This means that normal shell processing does not happen. For example, RUN [ “echo”, “$HOME” ] will not do variable substitution on $HOME. If you want shell processing then either use the shell form or execute a shell directly, for example: RUN [ “sh”, “-c”, “echo $HOME” ]. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker.</p>
</blockquote>
<p>建议是使用<code class="language-text">exec模式</code>，细节可以看下面一个小节。</p>
<h3 id="512-cmd--entrypoint" style="position:relative;"><a href="#512-cmd--entrypoint" aria-label="512 cmd  entrypoint permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5.1.2 CMD &#x26; ENTRYPOINT</h3>
<p>官方文档：</p>
<ul>
<li><a href="https://docs.docker.com/engine/reference/builder/#run" target="_blank" rel="nofollow noopener noreferrer">CMD</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank" rel="nofollow noopener noreferrer">ENTRYPOINT</a></li>
</ul>
<p>这两个东西可以放在一起说，因为他们做的事情基本上是类似的。两者都是在容器启动之后执行一个命令，CMD提供的是在镜像启动后会默认执行的一个命令，而ENTRYPOINT则是在镜像启动后提供一个程序入口。</p>
<p>区别在于：</p>
<ul>
<li>CMD：提供的默认执行命令可以在<code class="language-text">docker run $imagename $command</code>后面接命令进行覆盖，这样操作的话写在Dockerfile CMD里的命令就不会执行了，被替代了；CMD在一个Dockerfile里只能有一个生效，如果编写了多个则只有最后的那个会被执行</li>
<li>ENTRYPOINT：提供的是镜像的<code class="language-text">功能入口</code>，不会被<code class="language-text">docker run $imagename $command</code>中的命令替换掉，除非指定<code class="language-text">--entrypoint=...</code>进行替换；当然ENTRYPOINT也只允许有一个</li>
</ul>
<p>一般来说通常的做法是：ENTRYPOINT提供容器运行之后程序入口，而CMD则提供供给给程序入口的参数，方便后续在docker run的时候进行替换。这两者以这样的方式进行协同工作。</p>
<p>官方文档里也有这部分内容：<a href="https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact" target="_blank" rel="nofollow noopener noreferrer">Understand how CMD and ENTRYPOINT interact</a>。</p>
<ul>
<li>Dockerfile should specify at least one of <code class="language-text">CMD</code> or <code class="language-text">ENTRYPOINT</code> commands.</li>
<li><code class="language-text">ENTRYPOINT</code> should be defined when using the container as an executable.</li>
<li><code class="language-text">CMD</code> should be used as a way of defining default arguments for an <code class="language-text">ENTRYPOINT</code> command or for executing an ad-hoc command in a container.</li>
<li><code class="language-text">CMD</code> will be overridden when running the container with alternative arguments.</li>
</ul>
<p>这两个指令和<a href="#ID_DOCKERFILE_RUN">5.2 RUN</a>一样，都有多种模式可以选择，一般来说最常使用的是直接写命令的<code class="language-text">shell模式</code>以及使用JSON格式编写的<code class="language-text">exec模式</code>。最佳实践是：在所有的情况下都使用<code class="language-text">exec模式</code>。原因如下：</p>
<ul>
<li>shell模式的PID 1进程是<code class="language-text">/bin/sh</code>，后续的信号不能很好传递到真正执行的命令上</li>
<li>shell模式依赖<code class="language-text">/bin/sh</code>，但某些微型镜像不一定有</li>
</ul>
<p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#entrypoint" target="_blank" rel="nofollow noopener noreferrer">Best practices for writing Dockerfiles > ENTRYPOINT</a>：</p>
<blockquote>
<p>Configure app as PID 1</p>
<p>This script uses the exec Bash command so that the final running application becomes the container’s PID 1. This allows the application to receive any Unix signals sent to the container. For more, see the ENTRYPOINT reference.</p>
</blockquote>
<p>CMD指令还多一种模式：<code class="language-text">CMD ["param1","param2"] (as default parameters to ENTRYPOINT)</code>，这也是刚才提到的参数提供者角色的做法。</p>
<p>e.g</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">FROM ubuntu:trusty
ENTRYPOINT ["/bin/ping","-c","3"]
CMD ["localhost"]

$ docker run ping
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.025 ms
...

$ docker run ping docker.io
PING docker.io (162.242.195.84) 56(84) bytes of data.
64 bytes from 162.242.195.84: icmp_seq=1 ttl=61 time=76.7 ms
...</code></pre></div>
<p>资料：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/30555962" target="_blank" rel="nofollow noopener noreferrer">Dockerfile: ENTRYPOINT和CMD的区别</a></li>
<li><a href="https://medium.freecodecamp.org/docker-entrypoint-cmd-dockerfile-best-practices-abc591c30e21" target="_blank" rel="nofollow noopener noreferrer">Docker ENTRYPOINT &#x26; CMD: Dockerfile best practices</a></li>
</ul>
<p>有时间的话，官方的ENTRYPOINT文档可以通读一下：<a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank" rel="nofollow noopener noreferrer">Dockerfile > ENTRYPOINT</a>，里面信息量不小。</p>
<h3 id="513-volume" style="position:relative;"><a href="#513-volume" aria-label="513 volume permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5.1.3 VOLUME</h3>
<p>官方文档：<a href="https://docs.docker.com/engine/reference/builder/#volume" target="_blank" rel="nofollow noopener noreferrer">VOLUME</a>。</p>
<p>卷加载相关在docker里是一个比较麻烦的概念，这里不作展开，只列出文档里提到的注意点：</p>
<ul>
<li><code class="language-text">Changing the volume from within the Dockerfile</code>: If any build steps change the data within the volume after it has been declared, those changes will be discarded.</li>
<li><code class="language-text">The host directory is declared at container run-time</code>: The host directory (the mountpoint) is, by its nature, host-dependent. This is to preserve image portability, since a given host directory can’t be guaranteed to be available on all hosts. For this reason, you can’t mount a host directory from within the Dockerfile. The <code class="language-text">VOLUME</code> instruction does not support specifying a <code class="language-text">host-dir</code> parameter. You must specify the mountpoint when you create or run the container.</li>
</ul>
<p>更多的深入理解可以查看：<a href="#ID_PRINCIPLE_STORAGE">9.2 存储</a>。</p>
<h3 id="514-arg" style="position:relative;"><a href="#514-arg" aria-label="514 arg permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5.1.4 ARG</h3>
<p>官方文档：<a href="https://docs.docker.com/engine/reference/builder/#arg" target="_blank" rel="nofollow noopener noreferrer">ARG</a>。</p>
<p>除了用户定义的变量之外，docker还有一部分预定义的变量，可以通过<code class="language-text">docker build --build-arg name=value</code>来加入：<a href="https://docs.docker.com/engine/reference/builder/#predefined-args" target="_blank" rel="nofollow noopener noreferrer">Predefined ARGs</a>。</p>
<ul>
<li>HTTP_PROXY</li>
<li>http_proxy</li>
<li>HTTPS_PROXY</li>
<li>https_proxy</li>
<li>FTP_PROXY</li>
<li>ftp_proxy</li>
<li>NO_PROXY</li>
<li>no_proxy</li>
</ul>
<h3 id="515-healthcheck" style="position:relative;"><a href="#515-healthcheck" aria-label="515 healthcheck permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5.1.5 HEALTHCHECK</h3>
<p>官方文档：<a href="https://docs.docker.com/engine/reference/builder/#healthcheck" target="_blank" rel="nofollow noopener noreferrer">HEALTHCHECK</a>。</p>
<p>类似于客户端服务器保持连接的心跳检查的概念，这个指令是用来检查当前的容器其提供的服务是否正常的。</p>
<p>用法：<code class="language-text">HEALTHCHECK [OPTIONS] CMD command</code>。CMD之前的选项有：</p>
<ul>
<li>—interval=DURATION (default: 30s)</li>
<li>—timeout=DURATION (default: 30s)</li>
<li>—start-period=DURATION (default: 0s)</li>
<li>—retries=N (default: 3)</li>
</ul>
<p>范例，每5分钟检查一次WEB服务器是否正常工作（3秒内能响应请求）：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">HEALTHCHECK --interval=5m --timeout=3s \
  CMD curl -f http://localhost/ || exit 1</code></pre></div>
<p>退出代码：</p>
<ul>
<li>0: success - the container is healthy and ready for use</li>
<li>1: unhealthy - the container is not working correctly</li>
<li>2: reserved - do not use this exit code</li>
</ul>
<p>同样细节比较多，可以仔细阅读下官方文档：<a href="https://docs.docker.com/engine/reference/builder/#healthcheck" target="_blank" rel="nofollow noopener noreferrer">Dockerfile > HEALTHCHECK</a>。</p>
<p>资料：</p>
<ul>
<li><a href="https://howchoo.com/g/zwjhogrkywe/how-to-add-a-health-check-to-your-docker-container" target="_blank" rel="nofollow noopener noreferrer">How to add a health check to your Docker container</a></li>
</ul>
<h3 id="516-其他指令" style="position:relative;"><a href="#516-%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4" aria-label="516 其他指令 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5.1.6 其他指令</h3>
<p>有相当多的指令在本文中并没有展开，可以查看其官方文档：</p>
<ul>
<li><a href="https://docs.docker.com/engine/reference/builder/#from" target="_blank" rel="nofollow noopener noreferrer">FROM</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#label" target="_blank" rel="nofollow noopener noreferrer">LABEL</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#expose" target="_blank" rel="nofollow noopener noreferrer">EXPOSE</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#env" target="_blank" rel="nofollow noopener noreferrer">ENV</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#add" target="_blank" rel="nofollow noopener noreferrer">ADD</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#copy" target="_blank" rel="nofollow noopener noreferrer">COPY</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#user" target="_blank" rel="nofollow noopener noreferrer">USER</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#workdir" target="_blank" rel="nofollow noopener noreferrer">WORKDIR</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#onbuild" target="_blank" rel="nofollow noopener noreferrer">ONBUILD</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#stopsignal" target="_blank" rel="nofollow noopener noreferrer">STOPSIGNAL</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#shell" target="_blank" rel="nofollow noopener noreferrer">SHELL</a></li>
</ul>
<h2 id="52-最佳实践" style="position:relative;"><a href="#52-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" aria-label="52 最佳实践 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5.2 最佳实践</h2>
<h3 id="521-缩小镜像构建的context" style="position:relative;"><a href="#521-%E7%BC%A9%E5%B0%8F%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E7%9A%84context" aria-label="521 缩小镜像构建的context permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5.2.1 缩小镜像构建的Context</h3>
<p>官方文档：<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#understand-build-context" target="_blank" rel="nofollow noopener noreferrer">Understand build context</a>。</p>
<p>简单理解就是保证运行<code class="language-text">docker build</code>命令的根工作文件夹里的内容尽量少，最好只保有构建镜像必须的文件，能显著加速镜像构建的速度（减少Context传送需要花费的时间）。</p>
<p>举个例子：</p>
<div class="gatsby-highlight" data-language="docker"><pre class="language-docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> alpine:3.9.2</span>
<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">"/bin/sh"</span>]</span></code></pre></div>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ mkdir ~/Downloads/docker &amp;&amp; cd ~/Downloads/docker
$ docker build -f Dockerfile -t empty_img:0.0.1 .

Sending build context to Docker daemon  2.048kB
Step 1/2 : FROM alpine:3.9.2
 ---> 5cb3aa00f899
Step 2/2 : ENTRYPOINT ["/bin/sh"]
 ---> Running in 6190582d6894
Removing intermediate container 6190582d6894
 ---> bd0e931e4706
Successfully built bd0e931e4706
Successfully tagged empty_img:0.0.1</code></pre></div>
<p>然后拷贝点垃圾文件到<code class="language-text">~/Downloads/docker</code>，再执行一次：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker build -f Dockerfile --no-cache -t dummy_img:0.0.1 .

Sending build context to Docker daemon  630.1MB
Step 1/2 : FROM alpine:3.9.2
 ---> 5cb3aa00f899
Step 2/2 : ENTRYPOINT ["/bin/sh"]
 ---> Running in 0b6ebe8953ca
Removing intermediate container 0b6ebe8953ca
 ---> 681e135d49b6
Successfully built 681e135d49b6
Successfully tagged dummy_img:0.0.1</code></pre></div>
<p><code class="language-text">Sending build context to Docker daemon  630.1MB</code>这一步花了很长时间（因为我拷贝过去的是630MB很零碎的小文件）。如果Context再大点，到百千GB级别的话，那影响更大。</p>
<p>对于构建出来的镜像大小是没有任何影响的：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
dummy_img           0.0.1               681e135d49b6        40 seconds ago      5.53MB
empty_img           0.0.1               bd0e931e4706        8 minutes ago       5.53MB
alpine              3.9.2               5cb3aa00f899        3 weeks ago         5.53MB</code></pre></div>
<h3 id="522-使用多阶段构建" style="position:relative;"><a href="#522-%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA" aria-label="522 使用多阶段构建 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5.2.2 使用多阶段构建</h3>
<p>官方文档：<a href="https://docs.docker.com/develop/develop-images/multistage-build/" target="_blank" rel="nofollow noopener noreferrer">Use multi-stage builds</a>。</p>
<p>一般来说总是希望镜像的体积越小越好，有利于传输也有利于减小容器的资源占用。而在镜像构建的时候，总会有很多中间产物。以go语言来举例，go语言最后编译产生的可执行文件是自包含的，对于外部的类库等都是不作要求的，而在go源码构建成可执行文件的过程中，则会有很多SDK等的环境需求。这就对<code class="language-text">构建</code>和<code class="language-text">生产</code>两个环境做了不同的定义及隔离要求。而<code class="language-text">多阶段构建</code>这个功能，就是为了这种需求而服务的。</p>
<p>简单来说就是在同一个Dockerfile里有<code class="language-text">多个``FROM指令</code>，每个FROM指令可以使用<code class="language-text">as ...</code>这样的语法进行命名，这样的一行语句就定义了一个<code class="language-text">阶段</code>。后面的阶段可以随意利用之前阶段里产生任何资源。通常的用法就是定义两个FROM即两个阶段，构建阶段和生产阶段。将所有的环境设置等都定义在构建阶段，然后将构建阶段编译产生的二进制文件拷贝到生产环境，这样生产环境就能够做到最小化了。</p>
<p>详细的例子可以直接查看官方文档，里面有一份非常详细的范例，正好就是按go制作的范例。</p>
<h3 id="523-构建的缓存" style="position:relative;"><a href="#523-%E6%9E%84%E5%BB%BA%E7%9A%84%E7%BC%93%E5%AD%98" aria-label="523 构建的缓存 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5.2.3 构建的缓存</h3>
<p>官方文档：<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache" target="_blank" rel="nofollow noopener noreferrer">Leverage build cache</a>。</p>
<p>这部分建议通读后理解，因为在<code class="language-text">docker build</code>的时候，只要不添加<code class="language-text">--no-cache</code>选项的话，构建就会检查并使用缓存。除非在工作中每次都放弃使用cache（在某些情况下会大大增加构建的时间消耗），否则对于缓存的命中还是有理解的必要。</p>
<h3 id="524-镜像层的创建" style="position:relative;"><a href="#524-%E9%95%9C%E5%83%8F%E5%B1%82%E7%9A%84%E5%88%9B%E5%BB%BA" aria-label="524 镜像层的创建 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5.2.4 镜像层的创建</h3>
<blockquote>
<p>Only the instructions RUN, COPY, ADD create layers. Other instructions create temporary intermediate images, and do not increase the size of the build.</p>
</blockquote>
<p>因此对于<code class="language-text">RUN</code>、<code class="language-text">COPY</code>以及<code class="language-text">ADD</code>指令的使用需要非常小心，特别是RUN指令，尽量使用<code class="language-text">&amp;&amp;</code>将其串起来。</p>
<h1 id="6-image" style="position:relative;"><a href="#6-image" aria-label="6 image permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>6. Image</h1>
<p>镜像文件的很多细节在之前的<a href="#ID_DOCKER_BUILD">4.5 docker build</a>以及<a href="#ID_DOCKERFILE">5. Dockerfile</a>都有提到了，所以讲到这里其实已经没什么很有价值的内容可以讲了。关于Image，有一篇非常不错的文章，只要过了一遍基本上Image本身就没什么神秘的了，可以看下：<a href="https://cameronlonsdale.com/2018/11/26/whats-in-a-docker-image/" target="_blank" rel="nofollow noopener noreferrer">What’s in a Docker image?</a>。</p>
<p>一些额外的资料：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/31222377/what-are-docker-image-layers" target="_blank" rel="nofollow noopener noreferrer">What are Docker image “layers”?</a></li>
<li><a href="https://forums.docker.com/t/do-number-of-layers-in-an-image-affect-the-runtime-performance/43119" target="_blank" rel="nofollow noopener noreferrer">Do number of layers (in an image) affect the runtime performance?</a></li>
<li><a href="https://medium.com/@jessgreb01/digging-into-docker-layers-c22f948ed612" target="_blank" rel="nofollow noopener noreferrer">Digging into Docker layers</a></li>
</ul>
<h1 id="7-docker-machine" style="position:relative;"><a href="#7-docker-machine" aria-label="7 docker machine permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7. Docker Machine</h1>
<p>官方文档：<a href="https://docs.docker.com/machine/overview/" target="_blank" rel="nofollow noopener noreferrer">Docker Machine Overview</a>。</p>
<p>Docker machine是用来辅助Ops对大批量机器进行docker部署时使用的工具。现如今规模化使用容器一般都会使用类似K8S这样的工具，所以这东西了解下就好。</p>
<p>资料：</p>
<ul>
<li><a href="https://juejin.im/entry/5b3df2b4f265da0f6e5156de" target="_blank" rel="nofollow noopener noreferrer">docker-machine</a></li>
</ul>
<h1 id="8-深入" style="position:relative;"><a href="#8-%E6%B7%B1%E5%85%A5" aria-label="8 深入 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8. 深入</h1>
<p>上面的文章基本上把docker的命令以及一些日常使用的细节都过了一遍，也包含了类似镜像体积等优化内容。后面就会进入一些docker比较底层的东西了，类似于docker的网络模式、docker的磁盘模式等。</p>
<h2 id="81-网络" style="position:relative;"><a href="#81-%E7%BD%91%E7%BB%9C" aria-label="81 网络 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.1 网络</h2>
<p>官方文档：<a href="https://docs.docker.com/network/" target="_blank" rel="nofollow noopener noreferrer">docker network overview</a></p>
<p>docker的网络子系统是可插拔式设计，其中可选的有：</p>
<ul>
<li><code class="language-text">bridge</code>：默认的网络驱动。如果不指定一个驱动的话，默认就是bridge模式。bridge模式通常应用在独立运行的容器相互之间需要通讯的应用场景</li>
<li><code class="language-text">host</code>：移除独立容器和Docker主机之间的网络隔离，并直接使用主机的网络。host模式仅针对高于Docker 17.06版本的swarm services可用</li>
<li><code class="language-text">overlay</code>：Overlay模式将多个Docker daemon连接起来，并启用swarm service来互通。你也可以使用overlay模式促进swarm service和独立容器之间的沟通，或是两个分别归属于不同Docker daemon的容器。这个策略简化了容器之间的互通，不再依赖于OS级别的路由</li>
<li><code class="language-text">macvlan</code>：Macvlan模式允许将一个MAC地址交付给一个容器，使得这个容器在你的网络中以一个硬件设备的身份出现。Docker daemon通过MAC地址将通讯路由到容器。macvlan模式通常用来处理需要直接连接到物理网络的遗留应用，而不需要路经Docker主机的网络栈</li>
<li><code class="language-text">none</code>：将某个容器禁用网络。通常与自定义的网络驱动结合使用。none驱动对swarm service不可用</li>
<li><code class="language-text">Third-party network plugins</code>：第三方网络插件，可自由安装使用。可以通过Docker Hub来安装，或通过第三方vendor安装</li>
</ul>
<p>选择建议：</p>
<ul>
<li><code class="language-text">User-defined bridge networks</code>：当相同Docker主机内的多个容器需要相互通讯的时候，这是最优解</li>
<li><code class="language-text">Host networks</code>：当容器的网络不应该与Docker主机隔离，且容器的其他方面应该与Docker主机隔离的情况下，这是最优解</li>
<li><code class="language-text">Overlay networks</code>：当需要运行在不同的Docker主机上的容器相互之间进行通讯，或当多个容器需要使用swarm service进行协同工作的时候，这是最优解</li>
<li><code class="language-text">Macvlan networks</code>：当从VM环境迁移到Docker环境或需要让容器看起来像物理主机的时候（每个容器都拥有一个唯一的MAC地址），这是最优解</li>
<li><code class="language-text">Third-party network plugins</code>：允许你将Docker整合到特殊的网络栈中</li>
</ul>
<p>通篇过一下之后会发现，基本上常用的场景，只要有bridge驱动就够了。后面会主要看下bridge驱动，其他的可以查看官方文档。</p>
<p>此外，有一篇比较老的文章，用中文举了点例子进行网络模式的说明，可以一读：<a href="http://dockone.io/article/1261" target="_blank" rel="nofollow noopener noreferrer">Docker网络模式</a>。</p>
<h3 id="811-bridge" style="position:relative;"><a href="#811-bridge" aria-label="811 bridge permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.1.1 bridge</h3>
<p>如果在创建容器的时候不指定网络设置的话，容器会使用默认的bridge驱动。而如果用户进行自定义bridge设置的话，使用的网络驱动就是稍微有点不同：<code class="language-text">User-defined bridge networks</code>。这里还是有不少区别的：<a href="https://docs.docker.com/network/bridge/#differences-between-user-defined-bridges-and-the-default-bridge" target="_blank" rel="nofollow noopener noreferrer">Differences between user-defined bridges and the default bridge</a>：</p>
<ul>
<li>User-defined bridges provide better isolation and interoperability between containerized applications.</li>
<li>User-defined bridges provide automatic DNS resolution between containers.</li>
<li>Containers can be attached and detached from user-defined networks on the fly.</li>
<li>Each user-defined network creates a configurable bridge.</li>
<li>Linked containers on the default bridge network share environment variables.</li>
</ul>
<p>自定义bridge驱动使用：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker network create my-net
$ docker network rm my-net

$ docker create --name my-nginx \
  --network my-net \
  --publish 8080:80 \
  nginx:latest

$ docker network connect my-net my-nginx
$ docker network disconnect my-net my-nginx</code></pre></div>
<p>官方文档里写清楚了，默认的bridge驱动已经属于遗留功能，不建议在生产环境上使用。</p>
<blockquote>
<p>The default bridge network is considered a legacy detail of Docker and is not recommended for production use.</p>
</blockquote>
<p>见文档：<a href="https://docs.docker.com/network/bridge/#use-the-default-bridge-network" target="_blank" rel="nofollow noopener noreferrer">Use the default bridge network</a>。</p>
<h3 id="812-其他" style="position:relative;"><a href="#812-%E5%85%B6%E4%BB%96" aria-label="812 其他 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.1.2 其他</h3>
<p>后面几种总的来说应用面都不大，在结合K8S使用的情况下（应该是大部分应用场景），只需要K8S即可。这里都可以略过。</p>
<h3 id="813-实践经验" style="position:relative;"><a href="#813-%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C" aria-label="813 实践经验 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.1.3 实践经验</h3>
<p>如果只是照范例抄启动命令的话，一般来说总会有几个知识点理解不是很透彻，这个章节就仔细看下这些知识点。</p>
<h4 id="容器ip" style="position:relative;"><a href="#%E5%AE%B9%E5%99%A8ip" aria-label="容器ip permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>容器IP</h4>
<p>每个容器在启动之后，都有其在设定的<code class="language-text">--network=xxx</code>下的固定IP地址（e.g 172.17.0.35）。因此不要在让容器上运行的应用程序监听<code class="language-text">Listener=127.0.0.1:xxx</code>这样的地址，否则其他服务将无法找到该应用。这和在本地运行应用程序是不一样的。</p>
<p>在本地开发和运行应用的时候，实际上所有的应用程序是部署在同一台物理机上的，因此回环地址可以正确找到应用。但使用容器的时候一般一个容器内只会有一个应用程序，会启动不同的几个容器让他们相互之间通讯，这时候回环地址就不会起效果了。</p>
<p>这是一个理解上的盲点，需要注意。</p>
<h4 id="容器名" style="position:relative;"><a href="#%E5%AE%B9%E5%99%A8%E5%90%8D" aria-label="容器名 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>容器名</h4>
<p>上面举的例子中，如果多个容器之间的应用程序需要相互访问，最好的监听地址配置方法是使用<code class="language-text">容器名</code>作为监听的<code class="language-text">host</code>。e.g <code class="language-text">Listener=node1:xxx</code>。容器只要启动在同一个network下，相互之间是可以通过容器名查找到的。</p>
<h4 id="expose-vs-publish" style="position:relative;"><a href="#expose-vs-publish" aria-label="expose vs publish permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>expose vs publish</h4>
<p>两者之间的区别很简单：</p>
<ul>
<li>expose仅将端口暴露给同一个network下的其他容器</li>
<li>publish会将端口暴露给其他不同的网络或docker host</li>
</ul>
<p>如果你的应用全部运行在同一个network下，那么就用expose就够了，如果有多个docker network，相互之间的访问需要publish port。</p>
<p>参见：</p>
<ul>
<li><a href="https://medium.freecodecamp.org/expose-vs-publish-docker-port-commands-explained-simply-434593dbc9a3" target="_blank" rel="nofollow noopener noreferrer">Expose vs publish: Docker port commands explained simply</a></li>
</ul>
<h2 id="82-存储-id_principle_storage" style="position:relative;"><a href="#82-%E5%AD%98%E5%82%A8-id_principle_storage" aria-label="82 存储 id_principle_storage permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.2 存储 {#ID_PRINCIPLE_STORAGE}</h2>
<p>官方文档：<a href="https://docs.docker.com/storage/" target="_blank" rel="nofollow noopener noreferrer">Manage data in Docker</a>。</p>
<p>任何在容器内创建的文件都会存储在容器的可写层内。这意味着：</p>
<ul>
<li>当容器消失的时候这些数据会丢失，且当其他进程需要共享这些数据的时候很难获取到这些数据</li>
<li>容器的可写层是和物理主机紧密关联的，很难轻易移动到其他机器上</li>
<li>向容器的可写层写入数据要求一个存储驱动来管理文件系统。存储驱动是一个洋葱式的文件系统，使用Linux内核。这额外的抽象会降低性能，和直接使用<code class="language-text">data volumn</code>相比，后者直接向主机的文件系统写入数据</li>
</ul>
<p>Docker提供了选项来让容器在物理主机上存储文件，这样才能保证容器在停止之后文件仍旧存在：</p>
<ul>
<li>volumes</li>
<li>bind mounts</li>
<li>tmpfs mount（仅限Linux）</li>
</ul>
<h3 id="821-几种类型的mount" style="position:relative;"><a href="#821-%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84mount" aria-label="821 几种类型的mount permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.2.1 几种类型的mount</h3>
<ul>
<li><code class="language-text">Volumes</code>：会将数据写入到主机磁盘上的<code class="language-text">Docker指定</code>地点（/var/lib/docker/volumes/ on Linux），且这些文件是由Docker进程进行管理的，其他任何进程都不应该直接修改这些文件。Volumes是在Docker内存储数据的最佳选择</li>
<li><code class="language-text">Bind mounts</code>：可将数据写入到主机磁盘上的<code class="language-text">任何</code>地点，甚至可以是重要的系统文件，或文件夹。非Docker进程及Docker容器都可以在任何时候修改这些文件</li>
<li><code class="language-text">tmpfs mounts</code>：仅将数据保存在内存中，并永远不会存储到磁盘上</li>
</ul>
<p>更进一步的各种mount类型细节可以查阅官方文档：<a href="https://docs.docker.com/storage/#more-details-about-mount-types" target="_blank" rel="nofollow noopener noreferrer">More details about mount types</a>。这里做一下整理：</p>
<p><strong>Volumns</strong></p>
<ul>
<li>一个volume可以被多个容器共享</li>
<li>volume在容器都停止之后不会被删除，除非手动操作：<code class="language-text">docker volume prune</code></li>
<li>volume是可命名的，如果没有被命名，则会被自动附加一个唯一串作为名字</li>
<li>volume还可以加载volume drivers，为其提供更丰富的存储功能</li>
</ul>
<p><strong>Bind mounts</strong></p>
<ul>
<li>使用bind mounts的时候，一个主机上的文件或文件夹被加载到容器中</li>
<li>文件或文件夹需要完整路径</li>
<li>文件或文件夹不需要已经存在</li>
<li>docker cli命令无法直接操作bind mounts资料</li>
<li>官方更推荐命名化的volumes，而不是使用bind mounts</li>
</ul>
<p>官方还给了最佳使用范例：</p>
<ul>
<li><a href="https://docs.docker.com/storage/#good-use-cases-for-volumes" target="_blank" rel="nofollow noopener noreferrer">Good use cases for volumes</a></li>
<li><a href="https://docs.docker.com/storage/#good-use-cases-for-bind-mounts" target="_blank" rel="nofollow noopener noreferrer">Good use cases for bind mounts</a></li>
<li><a href="https://docs.docker.com/storage/#good-use-cases-for-tmpfs-mounts" target="_blank" rel="nofollow noopener noreferrer">Good use cases for tmpfs mounts</a></li>
</ul>
<p>几点tips：</p>
<ul>
<li>如果把一个空的volume（使用docker create创建出来的）绑定到运行中容器的某个已经存在的文件夹上，会导致已经存在文件夹内的资料被拷贝到volume内</li>
<li>如果把一个bind mount或已经有内容的volume绑定到某个运行中容器的某个已经存在的文件夹上，则容器内重合文件夹内的资料会被屏蔽（不会被删除），volume内的资料则可访问</li>
</ul>
<p>在我看来：</p>
<ul>
<li>volumes应该是最先选择，如果没有特殊需求的话，类似于web服务器这种无状态可以很快横向扩展的就很适合使用volumes</li>
<li>bind mounts可以用在<code class="language-text">其他进程有直接访问文件需求</code>的场景。volumes是docker进程自组织的，对外就是一个block文件，无法看到细节，其实不太友好，在docker之外的进程也需要对文件进行访问的时候就很不方便了，这种场景就需要bind mounts</li>
</ul>
<h3 id="822-日常使用命令" style="position:relative;"><a href="#822-%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4" aria-label="822 日常使用命令 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.2.2 日常使用命令</h3>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker volume create my-vol
$ docker volume ls
$ docker volume inspect my-vol
$ docker volume rm my-vol # delete volume
$ docker volume prune # delete all</code></pre></div>
<h3 id="823-volumes" style="position:relative;"><a href="#823-volumes" aria-label="823 volumes permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.2.3 Volumes</h3>
<p>官方文档：<a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="nofollow noopener noreferrer">Use volumes</a>。</p>
<p>优势：</p>
<ul>
<li>Volumes are easier to back up or migrate than bind mounts.</li>
<li>You can manage volumes using Docker CLI commands or the Docker API.</li>
<li>Volumes work on both Linux and Windows containers.</li>
<li>Volumes can be more safely shared among multiple containers.</li>
<li>Volume drivers let you store volumes on remote hosts or cloud providers, to encrypt the contents of volumes, or to add other functionality.</li>
<li>New volumes can have their content pre-populated by a container.</li>
</ul>
<p>可以使用<code class="language-text">--volume</code>或<code class="language-text">--mount</code>来指定容器运行时需要mount的卷，使用上有点些微的不同：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker run --volume \
    $volume_name:$path_mounted_in_container:$option1,$option2,...

$ docker run --mount \
    type=volume,source|src=$volume_name,destination|dst|target=$path_mounted_in_container,readonly,volume-opt=$key1=$val1,volume-opt=$key2=$val2,...</code></pre></div>
<p>几点不常用但可能用得到的点：</p>
<ul>
<li><a href="https://docs.docker.com/storage/volumes/#use-a-volume-driver" target="_blank" rel="nofollow noopener noreferrer">Use a volume driver</a></li>
<li><a href="https://docs.docker.com/storage/volumes/#backup-restore-or-migrate-data-volumes" target="_blank" rel="nofollow noopener noreferrer">Backup, restore, or migrate data volumes</a></li>
</ul>
<h3 id="824-bind-mounts" style="position:relative;"><a href="#824-bind-mounts" aria-label="824 bind mounts permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.2.4 Bind mounts</h3>
<p>官方文档：<a href="https://docs.docker.com/storage/bind-mounts/" target="_blank" rel="nofollow noopener noreferrer">Use bind mounts</a>。</p>
<p>可以使用<code class="language-text">--volume</code>或<code class="language-text">--mount</code>来指定容器运行时需要mount的卷，使用上有点些微的不同：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ docker run --volume \
    $path_on_host_tobe_bound:$path_mounted_in_container:$option1,$option2,...

$ docker run --mount \
    type=bind,source|src=$path_on_host_tobe_bound,destination|dst|target=$path_mounted_in_container,readonly,bind-propagation=rprivate|private|rshared|shared|rslave|slave</code></pre></div>
<p>对bind mounts来说<code class="language-text">--volume</code>和<code class="language-text">--mount</code>在使用上是有区别的：</p>
<ul>
<li><code class="language-text">--volume</code>：指定的主机位置不存在的话，会主动创建出来（总是创建成文件夹）</li>
<li><code class="language-text">--mount</code>：指定的主机位置不存在的话，不会主动创建，而是报错</li>
</ul>
<p>举个简单的例子：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ cd /Users/XXX &amp;&amp; mkdir ./docker &amp;&amp; cd ./docker &amp;&amp; touch ./dummy.txt &amp;&amp; echo dummy > ./dummy.txt
$ docker run -it -d --rm -v /Users/XXX/Downloads/docker/:/dirinc --name bind_mount_test ubuntu:18.10
$ docker attach 8d11c4aad023

root@8d11c4aad023:/# ll /dirinc
...
-rw-r--r-- 1 root root    8 Apr  3 02:23 dummy.txt
root@8d11c4aad023:/# echo changed > /dirinc/dummy.txt

$ cat /Users/XXX/docker/dummy.txt
changed</code></pre></div>
<p>几点不常用但可能用得到的点：</p>
<ul>
<li><a href="https://docs.docker.com/storage/bind-mounts/#configure-bind-propagation" target="_blank" rel="nofollow noopener noreferrer">Configure bind propagation</a></li>
<li><a href="https://docs.docker.com/storage/bind-mounts/#configure-the-selinux-label" target="_blank" rel="nofollow noopener noreferrer">Configure the selinux label</a></li>
</ul>
<h3 id="825-storage-drivers" style="position:relative;"><a href="#825-storage-drivers" aria-label="825 storage drivers permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.2.5 Storage drivers</h3>
<p>官方文档：<a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/" target="_blank" rel="nofollow noopener noreferrer">Docker storage drivers</a>。</p>
<p>这部分里会讲到的<code class="language-text">storage drivers</code>和之前的volumes是不同的东西，所谓的<code class="language-text">storage drivers</code>是指docker从镜像生成容器之后，在容器的最上面创建出来的那一层可写入层里，使用的文件处理策略（驱动）。</p>
<p>这部分不会太过展开，主要是因为：</p>
<ul>
<li>会在容器的可写层里大量产生数据的应用场景一般不会存在，如果存在那一般也是有问题的</li>
<li>在真的需要容器对存储设备进行大量写入操作的情况，需要考虑是否使用volumes，而不是直接在容器的可写入层里进行写操作（两者在性能上也有差距）</li>
</ul>
<p>因此实际上这块的实用性并不高。后面主要以认识<code class="language-text">storage drivers</code>为主。</p>
<p>Docker支持的storage drivers：</p>
<ul>
<li><code class="language-text">overlay2</code>：首选的驱动，对现行的所有Linux发行版本可用，且无需额外的配置</li>
<li><code class="language-text">aufs</code>：对 Docker 18.06 及更老旧的版本来说是首选驱动，或 Ubuntu 14.04 kernel 3.13 不支持 overlay2 的环境</li>
<li><code class="language-text">devicemapper</code>：受到支持，但在生产环境需要<code class="language-text">direct-lvm</code>，是因为<code class="language-text">loopback-lvm</code>虽然无需配置，但性能不是很好</li>
<li>The <code class="language-text">btrfs</code> and <code class="language-text">zfs</code> storage drivers are used if they are the backing filesystem (the filesystem of the host on which Docker is installed). These filesystems allow for advanced options, such as creating “snapshots”, but require more maintenance and setup. Each of these relies on the backing filesystem being configured correctly.</li>
<li>The <code class="language-text">vfs</code> storage driver is intended for testing purposes, and for situations where no copy-on-write filesystem can be used. Performance of this storage driver is poor, and is not generally recommended for production use.</li>
</ul>
<p>要查看各Linux发行版本支持的驱动，可以查看：<a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/#supported-storage-drivers-per-linux-distribution" target="_blank" rel="nofollow noopener noreferrer">Supported storage drivers per Linux distribution</a>。</p>
<p>要查看各文件系统支持的驱动，可以查看：<a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/#supported-backing-filesystems" target="_blank" rel="nofollow noopener noreferrer">Supported backing filesystems</a>。</p>
<p>后面还有很多各种驱动的细节，这里就不展开了，给出一些资料：</p>
<ul>
<li><a href="https://docs.docker.com/storage/storagedriver/aufs-driver/" target="_blank" rel="nofollow noopener noreferrer">Use the AUFS storage driver</a></li>
<li><a href="https://docs.docker.com/storage/storagedriver/btrfs-driver/" target="_blank" rel="nofollow noopener noreferrer">Use the BTRFS storage driver</a></li>
<li><a href="https://docs.docker.com/storage/storagedriver/device-mapper-driver/" target="_blank" rel="nofollow noopener noreferrer">Use the Device Mapper storage driver</a></li>
<li><a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank" rel="nofollow noopener noreferrer">Use the OverlayFS storage driver</a></li>
<li><a href="https://docs.docker.com/storage/storagedriver/zfs-driver/" target="_blank" rel="nofollow noopener noreferrer">Use the ZFS storage driver</a></li>
<li><a href="https://docs.docker.com/storage/storagedriver/vfs-driver/" target="_blank" rel="nofollow noopener noreferrer">Use the VFS storage driver</a></li>
<li><a href="https://coolshell.cn/articles/17061.html" target="_blank" rel="nofollow noopener noreferrer">DOCKER基础技术：AUFS</a></li>
<li><a href="https://coolshell.cn/articles/17200.html" target="_blank" rel="nofollow noopener noreferrer">DOCKER基础技术：DEVICEMAPPER</a></li>
</ul>
<h2 id="83-资源限制-id_principle_resource" style="position:relative;"><a href="#83-%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6-id_principle_resource" aria-label="83 资源限制 id_principle_resource permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.3 资源限制 {#ID_PRINCIPLE_RESOURCE}</h2>
<p>这块的话题有点大，本质上来说，Docker的资源限制利用的还是Linux本身的机制。即便撇开Docker，这些知识点也是值得一看的，但鉴于主题，这里就不多展开了。后续这个章节的主要目标是将Docker的一些限制手段以及后面的Linux原理相关的思路整理出来，并附上资料，不会过于深入。</p>
<p>实际上在真实场景使用的时候一般也会使用类似K8S这样的系统来进行集群管理，不太会直接在Docker这一层工具上对资源限制这块过多设置。</p>
<h3 id="831-linux" style="position:relative;"><a href="#831-linux" aria-label="831 linux permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.3.1 Linux</h3>
<p>Linux中的namespace、cgroup、capabilities等核心概念，可以看下面几篇：</p>
<ul>
<li><a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="nofollow noopener noreferrer">DOCKER基础技术：LINUX NAMESPACE（上）</a></li>
<li><a href="https://coolshell.cn/articles/17029.html" target="_blank" rel="nofollow noopener noreferrer">DOCKER基础技术：LINUX NAMESPACE（下）</a></li>
<li><a href="https://coolshell.cn/articles/17049.html" target="_blank" rel="nofollow noopener noreferrer">DOCKER基础技术：LINUX CGROUP</a></li>
<li><a href="https://rk700.github.io/2016/10/26/linux-capabilities/" target="_blank" rel="nofollow noopener noreferrer">Linux的capabilities机制</a></li>
</ul>
<h3 id="832-docker" style="position:relative;"><a href="#832-docker" aria-label="832 docker permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.3.2 Docker</h3>
<p>Docker官方对于资源限制也有不小的篇幅进行解说，在使用上有需要的时候可以查看：</p>
<ul>
<li><a href="https://docs.docker.com/engine/reference/run/#runtime-constraints-on-resources" target="_blank" rel="nofollow noopener noreferrer">docker run > Runtime constraints on resources</a></li>
<li><a href="https://docs.docker.com/config/containers/resource_constraints/" target="_blank" rel="nofollow noopener noreferrer">Limit a container’s resources</a></li>
</ul>
<h3 id="833-其他" style="position:relative;"><a href="#833-%E5%85%B6%E4%BB%96" aria-label="833 其他 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.3.3 其他</h3>
<p>其他资料：</p>
<ul>
<li><a href="http://cizixs.com/2017/08/25/linux-cgroup/" target="_blank" rel="nofollow noopener noreferrer">docker 容器基础技术：linux cgroup 简介</a></li>
<li><a href="https://infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank" rel="nofollow noopener noreferrer">Docker 背后的内核知识——cgroups 资源限制</a></li>
<li><a href="https://medium.com/@asishrs/docker-limit-resource-utilization-using-cgroup-parent-72a646651f9d" target="_blank" rel="nofollow noopener noreferrer">Docker limit resource utilization using cgroup-parent</a></li>
<li><a href="https://medium.com/@kasunmaduraeng/docker-namespace-and-cgroups-dece27c209c7" target="_blank" rel="nofollow noopener noreferrer">Docker Namespace and Cgroups</a></li>
<li><a href="https://my.oschina.net/HardySimpson/blog/868186" target="_blank" rel="nofollow noopener noreferrer">cgroup, docker,和kubernetes</a></li>
<li><a href="https://www.cnblogs.com/sammyliu/p/5886833.html" target="_blank" rel="nofollow noopener noreferrer">理解Docker（4）：Docker 容器使用 cgroups 限制资源使用</a></li>
</ul>
<h2 id="84-监控--metrics" style="position:relative;"><a href="#84-%E7%9B%91%E6%8E%A7--metrics" aria-label="84 监控  metrics permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.4 监控 &#x26; Metrics</h2>
<h3 id="841-official-guide" style="position:relative;"><a href="#841-official-guide" aria-label="841 official guide permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.4.1 Official Guide</h3>
<p>Docker官方的监控，这块和上面的内容类似也比较鸡肋，一般来说不会直接裸用Docker，如果有K8S之类的，那监控也不会从Docker来了。所以这里就给点资料即可，有需要的可以深入下官方文档：</p>
<ul>
<li><a href="https://docs.docker.com/config/containers/runmetrics/" target="_blank" rel="nofollow noopener noreferrer">Runtime metrics</a>
<ul>
<li><code class="language-text">docker stats</code>是类似top的工具，可以对整体运行的容器有一个overall的把握</li>
<li>docker对于性能指标的监控仍旧依赖于Linux的cgroup</li>
<li><a href="https://docs.docker.com/config/containers/runmetrics/#metrics-from-cgroups-memory-cpu-block-io" target="_blank" rel="nofollow noopener noreferrer">Metrics from cgroups: memory, CPU, block I/O</a></li>
<li><a href="https://docs.docker.com/config/containers/runmetrics/#cpu-metrics-cpuacctstat" target="_blank" rel="nofollow noopener noreferrer">CPU metrics: cpuacct.stat</a></li>
<li><a href="https://docs.docker.com/config/containers/runmetrics/#network-metrics" target="_blank" rel="nofollow noopener noreferrer">Network metrics</a></li>
</ul>
</li>
<li><a href="https://docs.docker.com/config/thirdparty/prometheus/" target="_blank" rel="nofollow noopener noreferrer">Collect Docker metrics with Prometheus</a></li>
</ul>
<h3 id="842-cadvisor" style="position:relative;"><a href="#842-cadvisor" aria-label="842 cadvisor permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.4.2 cAdvisor</h3>
<p>在以容器为主的系统架构中，除了主机监控之外还需要监控容器，因为应用程序都是运行在容器中的。而且也有可能某些主机运行了多个容器，那么这些容器（应用程序）占用了多少资源就需要进行监控了。Google出品的cAdvisor基本上是最优解：</p>
<ul>
<li>代码：<a href="https://github.com/google/cadvisor" target="_blank" rel="nofollow noopener noreferrer">google/cadvisor</a></li>
<li>镜像：<a href="https://hub.docker.com/r/google/cadvisor/" target="_blank" rel="nofollow noopener noreferrer">google/cadvisor</a>
<ul>
<li>google/cadvisor:v0.33.0</li>
</ul>
</li>
<li>配置：<a href="https://github.com/google/cadvisor/blob/master/docs/runtime_options.md" target="_blank" rel="nofollow noopener noreferrer">cAdvisor Runtime Options</a></li>
<li>Dashboard：<a href="https://grafana.com/dashboards/893" target="_blank" rel="nofollow noopener noreferrer">Docker and system monitoring</a></li>
</ul>
<p>注意cAdvisor不仅仅只服务于Docker，也可以用在其他容器运行时上。</p>
<h2 id="85-安全" style="position:relative;"><a href="#85-%E5%AE%89%E5%85%A8" aria-label="85 安全 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.5 安全</h2>
<p>官方文档：<a href="https://docs.docker.com/engine/security/security/" target="_blank" rel="nofollow noopener noreferrer">Docker security</a>。</p>
<p>老话重提，里面的知识点仍旧是上面提到过的Linux cgroup、capabilities等几个知识点。</p>
<p>此外，用户管理也是一个需要关注的点，Docker默认的用户是root，在某些情况下使用者有必要进行更换。参见：<a href="https://stackoverflow.com/questions/30052019/docker-creates-files-as-root-in-mounted-volume" target="_blank" rel="nofollow noopener noreferrer">Docker creates files as root in mounted volume [duplicate]</a>。</p>
<h2 id="87-其他" style="position:relative;"><a href="#87-%E5%85%B6%E4%BB%96" aria-label="87 其他 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8.7 其他</h2>
<ul>
<li>停止容器：<a href="https://www.ctl.io/developers/blog/post/gracefully-stopping-docker-containers/" target="_blank" rel="nofollow noopener noreferrer">Gracefully Stopping Docker Containers</a></li>
<li><a href="https://coolshell.cn/articles/18654.html" target="_blank" rel="nofollow noopener noreferrer">记一次KUBERNETES/DOCKER网络排障</a></li>
<li><code class="language-text">vm.max_map_count</code>需要改大，MAC下操作方法：<a href="https://stackoverflow.com/questions/41192680/update-max-map-count-for-elasticsearch-docker-container-mac-host" target="_blank" rel="nofollow noopener noreferrer">Update max_map_count for ElasticSearch docker container Mac host</a>
<ul>
<li>screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty</li>
<li>sysctl -w vm.max_map_count=1048575</li>
<li>ctrl-A ctrl-\</li>
</ul>
</li>
<li>在mac下如果要使用docker-machine，需要安装virtualbox：brew cask install virtualbox</li>
</ul>
<h1 id="9-os镜像选择" style="position:relative;"><a href="#9-os%E9%95%9C%E5%83%8F%E9%80%89%E6%8B%A9" aria-label="9 os镜像选择 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>9. OS镜像选择</h1>
<h2 id="91-alpine" style="position:relative;"><a href="#91-alpine" aria-label="91 alpine permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>9.1 Alpine</h2>
<p>技术过硬的话，Alpine应该说是制作生产环境产品镜像的首选了，毕竟体积摆在那边，只有几兆的基本镜像可真的没几个好选的。</p>
<ul>
<li><a href="https://github.com/gliderlabs/docker-alpine" target="_blank" rel="nofollow noopener noreferrer">gliderlabs/docker-alpine</a>：官方项目</li>
<li><a href="https://hub.docker.com/_/alpine" target="_blank" rel="nofollow noopener noreferrer">docker hub > alpine</a>：官方镜像</li>
</ul>
<p>一些资料：</p>
<ul>
<li><a href="https://github.com/gliderlabs/docker-alpine#why" target="_blank" rel="nofollow noopener noreferrer">gliderlabs/docker-alpine#Why?</a>：官方安利，主要的主张就是体积小+软件安装包全面</li>
<li><a href="https://wiki.alpinelinux.org/wiki/Comparison_with_other_distros" target="_blank" rel="nofollow noopener noreferrer">Comparison with other distros</a>：一篇比较的wiki，不过这篇更倾向于使用上的比较，指导意义不大</li>
<li><a href="https://nickjanetakis.com/blog/benchmarking-debian-vs-alpine-as-a-base-docker-image" target="_blank" rel="nofollow noopener noreferrer">Benchmarking Debian vs Alpine as a Base Docker Image</a>：这篇比较硬核，从具体的benchmark上进行了比较，非常值得一读</li>
<li><a href="https://thenewstack.io/alpine-linux-heart-docker/" target="_blank" rel="nofollow noopener noreferrer">Meet Alpine Linux, Docker’s Distribution of Choice for Containers</a>：这是一篇安利文，讲的点比较全面，可以一读</li>
</ul>
<h3 id="dns-issue" style="position:relative;"><a href="#dns-issue" aria-label="dns issue permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DNS issue</h3>
<p>DNS问题算是Alpine被诟病得比较多的一点，可以看一个issue：<a href="https://github.com/gliderlabs/docker-alpine/issues/255" target="_blank" rel="nofollow noopener noreferrer">DNS Issue #255</a>。官方在github的文档上也给了说明，可以看下：<a href="https://github.com/gliderlabs/docker-alpine/blob/master/docs/caveats.md#dns" target="_blank" rel="nofollow noopener noreferrer">caveats.md >> DNS</a>，当然具体是否有这个情况以及如何解决，就要看实践了。</p>
<h1 id="10-实践" style="position:relative;"><a href="#10-%E5%AE%9E%E8%B7%B5" aria-label="10 实践 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>10. 实践</h1>
<h2 id="列出所有本机镜像" style="position:relative;"><a href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E6%9C%AC%E6%9C%BA%E9%95%9C%E5%83%8F" aria-label="列出所有本机镜像 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>列出所有本机镜像</h2>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> images</code></pre></div>
<h2 id="列出本机所有容器" style="position:relative;"><a href="#%E5%88%97%E5%87%BA%E6%9C%AC%E6%9C%BA%E6%89%80%E6%9C%89%E5%AE%B9%E5%99%A8" aria-label="列出本机所有容器 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>列出本机所有容器</h2>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span></code></pre></div>
<h2 id="列出本机磁盘使用情况" style="position:relative;"><a href="#%E5%88%97%E5%87%BA%E6%9C%AC%E6%9C%BA%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5" aria-label="列出本机磁盘使用情况 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>列出本机磁盘使用情况</h2>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> system <span class="token function">df</span> <span class="token parameter variable">-v</span></code></pre></div>
<h2 id="本机空间清理" style="position:relative;"><a href="#%E6%9C%AC%E6%9C%BA%E7%A9%BA%E9%97%B4%E6%B8%85%E7%90%86" aria-label="本机空间清理 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>本机空间清理</h2>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> system prune</code></pre></div>
<p>几个概念：</p>
<ul>
<li>已使用镜像（used image）： 指所有已被容器（包括已停止的）关联的镜像。即 docker ps -a 看到的所有容器使用的镜像</li>
<li>未引用镜像（unreferenced image）：没有被分配或使用在容器中的镜像，但它有 Tag 信息</li>
<li>悬空镜像（dangling image）：未配置任何 Tag （也就无法被引用）的镜像，所以悬空。这通常是由于镜像 build 的时候没有指定 -t 参数配置 Tag 导致的</li>
<li>挂起的卷（dangling Volume)：类似的，dangling=true 的 Volume 表示没有被任何容器引用的卷</li>
</ul>
<p>docker system prune 自动清理说明：</p>
<p>该指令默认会清除所有如下资源：</p>
<ul>
<li>已停止的容器（container）</li>
<li>未被任何容器所使用的卷（volume）</li>
<li>未被任何容器所关联的网络（network）</li>
<li>所有悬空镜像（image）</li>
<li>该指令默认只会清除悬空镜像，未被使用的镜像不会被删除</li>
<li>添加 -a 或 —all 参数后，可以一并清除所有未使用的镜像和悬空镜像</li>
<li>可以添加 -f 或 —force 参数用以忽略相关告警确认信息</li>
<li>指令结尾处会显示总计清理释放的空间大小</li>
</ul>
<p>参见：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/31820191" target="_blank" rel="nofollow noopener noreferrer">Docker 空间使用分析与清理</a></li>
</ul>
<h2 id="本机镜像清理" style="position:relative;"><a href="#%E6%9C%AC%E6%9C%BA%E9%95%9C%E5%83%8F%E6%B8%85%E7%90%86" aria-label="本机镜像清理 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>本机镜像清理</h2>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 删除所有悬空镜像，但不会删除未使用镜像：</span>
$ <span class="token function">docker</span> rmi <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images <span class="token parameter variable">-f</span> <span class="token string">"dangling=true"</span> <span class="token parameter variable">-q</span><span class="token variable">)</span></span>

<span class="token comment"># 删除所有未使用镜像和悬空镜像。</span>
<span class="token comment"># 【说明】：轮询到还在被使用的镜像时，会有类似"image is being used by xxx container"的告警信息，所以相关镜像不会被删除，忽略即可。</span>
$ <span class="token function">docker</span> rmi <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images <span class="token parameter variable">-q</span><span class="token variable">)</span></span></code></pre></div>
<h2 id="本机卷清理" style="position:relative;"><a href="#%E6%9C%AC%E6%9C%BA%E5%8D%B7%E6%B8%85%E7%90%86" aria-label="本机卷清理 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>本机卷清理</h2>
<p>如果通过 docker system df 分析，是卷占用了过高空间。则可以根据业务情况，评估相关卷的使用情况。对于未被任何容器调用的卷（-v 结果信息中，“LINKS” 显示为 0），可以使用如下指令手工清理：</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 删除所有未被任何容器关联引用的卷：</span>
$ <span class="token function">docker</span> volume <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> volume <span class="token function">ls</span> <span class="token parameter variable">-f</span> <span class="token string">"dangling=true"</span> <span class="token parameter variable">-q</span><span class="token variable">)</span></span>

<span class="token comment"># 也可以直接使用如下指令，删除所有未被任何容器关联引用的卷（但建议使用上面的方式）</span>
<span class="token comment"># 【说明】轮询到还在使用的卷时，会有类似"volume is in use"的告警信息，所以相关卷不会被删除，忽略即可。</span>
$ <span class="token function">docker</span> volume <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> volume <span class="token function">ls</span> <span class="token parameter variable">-q</span><span class="token variable">)</span></span></code></pre></div>
<h2 id="日志驱动及容量设置" style="position:relative;"><a href="#%E6%97%A5%E5%BF%97%E9%A9%B1%E5%8A%A8%E5%8F%8A%E5%AE%B9%E9%87%8F%E8%AE%BE%E7%BD%AE" aria-label="日志驱动及容量设置 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>日志驱动及容量设置</h2>
<p>见过好几个日志文件膨胀到把主机磁盘吃光的情况，所以这方面还是要小心处理。</p>
<p>官方文档：</p>
<ul>
<li><a href="https://docs.docker.com/config/containers/logging/configure/" target="_blank" rel="nofollow noopener noreferrer">Configure logging drivers</a></li>
<li><a href="https://docs.docker.com/config/containers/logging/json-file/" target="_blank" rel="nofollow noopener noreferrer">JSON File logging driver</a></li>
</ul>
<p>在docker run命令中修改日志输出driver，以及限定最大日志空间占用：</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> run <span class="token punctuation">\</span>
      --log-driver json-file --log-opt max-size<span class="token operator">=</span>10m <span class="token punctuation">\</span>
      alpine <span class="token builtin class-name">echo</span> hello world</code></pre></div>
<p>更多的可以查看官方文档。</p>
<h2 id="查看网络内容器列表" style="position:relative;"><a href="#%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%99%A8%E5%88%97%E8%A1%A8" aria-label="查看网络内容器列表 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查看网络内容器列表</h2>
<p>注意下面的例子中双花括号的转译符需要自行去除：</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 只获取名字</span>
$ <span class="token function">docker</span> network inspect <span class="token parameter variable">-f</span> <span class="token string">'\{\{ range $key, $value := .Containers \}\}\{\{ printf "%s\n" $value.Name \}\}\{\{ end \}\}'</span> <span class="token variable">${网络名}</span>

<span class="token comment"># 观察打印出来的结构中的 Containers 部分，可以获得更详细的信息</span>
$ <span class="token function">docker</span> network inspect <span class="token variable">${网络名}</span></code></pre></div>
<h2 id="查看容器所属网络" style="position:relative;"><a href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%89%80%E5%B1%9E%E7%BD%91%E7%BB%9C" aria-label="查看容器所属网络 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查看容器所属网络</h2>
<p>注意下面的例子中双花括号的转译符需要自行去除：</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 只获取名字</span>
$ <span class="token function">docker</span> inspect <span class="token parameter variable">-f</span> <span class="token string">'\{\{ range $key, $value := .NetworkSettings.Networks \}\}\{\{ printf "%s\n" $key \}\}\{\{ end \}\}'</span> <span class="token variable">${容器名}</span>

<span class="token comment"># 观察打印出来的结构中的 Networks 部分，可以获得更详细的信息</span>
$ <span class="token function">docker</span> inspect <span class="token variable">${容器名}</span></code></pre></div>
<h2 id="查看容器运行状态" style="position:relative;"><a href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81" aria-label="查看容器运行状态 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查看容器运行状态</h2>
<p>注意下面的例子中双花括号的转译符需要自行去除：</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> stats <span class="token comment"># 默认一直刷新，类似top命令</span>
$ <span class="token function">docker</span> stats --no-stream <span class="token comment"># 不刷新，只获取一次</span>
$ <span class="token function">docker</span> stats --no-stream <span class="token variable">${容器名}</span> <span class="token comment"># 获取指定的容器状态</span>
$ <span class="token function">docker</span> stats <span class="token parameter variable">--format</span> <span class="token string">"table \{\{.Name\}\}<span class="token entity" title="\t">\t</span>\{\{.CPUPerc\}\}<span class="token entity" title="\t">\t</span>\{\{.MemUsage\}\}"</span> <span class="token comment"># 格式化输出</span>
<span class="token comment"># JSON格式输出</span>
$ <span class="token function">docker</span> stats --no-stream <span class="token parameter variable">--format</span> <span class="token punctuation">\</span>
      <span class="token string">"{<span class="token entity" title="\&quot;">\"</span>container<span class="token entity" title="\&quot;">\"</span>:<span class="token entity" title="\&quot;">\"</span>\{\{ .Container \}\}<span class="token entity" title="\&quot;">\"</span>,<span class="token entity" title="\&quot;">\"</span>memory<span class="token entity" title="\&quot;">\"</span>:{<span class="token entity" title="\&quot;">\"</span>raw<span class="token entity" title="\&quot;">\"</span>:<span class="token entity" title="\&quot;">\"</span>\{\{ .MemUsage \}\}<span class="token entity" title="\&quot;">\"</span>,<span class="token entity" title="\&quot;">\"</span>percent<span class="token entity" title="\&quot;">\"</span>:<span class="token entity" title="\&quot;">\"</span>\{\{ .MemPerc \}\}<span class="token entity" title="\&quot;">\"</span>},<span class="token entity" title="\&quot;">\"</span>cpu<span class="token entity" title="\&quot;">\"</span>:<span class="token entity" title="\&quot;">\"</span>\{\{ .CPUPerc \}\}<span class="token entity" title="\&quot;">\"</span>}"</span></code></pre></div>
<ul>
<li>.Container：根据用户指定的名称显示容器的名称或 ID</li>
<li>.Name：容器名称</li>
<li>.ID：容器 ID</li>
<li>.CPUPerc：CPU 使用率</li>
<li>.MemUsage：内存使用量</li>
<li>.NetIO：网络 I/O</li>
<li>.BlockIO：磁盘 I/O</li>
<li>.MemPerc：内存使用率</li>
<li>.PIDs：PID 号</li>
</ul>
<p>参见：</p>
<ul>
<li><a href="https://www.cnblogs.com/sparkdev/p/7821376.html" target="_blank" rel="nofollow noopener noreferrer">查看 docker 容器使用的资源</a></li>
</ul>
<h1 id="11-swarm集群解决方案" style="position:relative;"><a href="#11-swarm%E9%9B%86%E7%BE%A4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" aria-label="11 swarm集群解决方案 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>11. Swarm集群解决方案</h1>
<h2 id="111-overview" style="position:relative;"><a href="#111-overview" aria-label="111 overview permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>11.1 Overview</h2>
<p>如今在集群解决方案方面执牛耳的无疑是Kubernetes以及Mesh解决方案Istio，但docker自身也具备集群管理和部署的能力。在Docker中这被称为Swarm，具体使用上来说：</p>
<ul>
<li>docker-machine：在远程主机上安装docker engine守护进程，保证远程主机作为docker环境可用，并将远程机器记录在操作者机器上，形成记录，以便后续远程控制</li>
<li>docker swarm：系列命令可以用来构建一个swarm集群，其中有一台作为master机，所有的集群操作都必须在master机上执行</li>
<li>docker stack：集群部署相关命令，使用compose配置文件，swarm版的docker compose命令</li>
<li>docker service：单独服务管理命令，swarm版的docker run命令</li>
</ul>
<p>相关官方文档：</p>
<ul>
<li>docker machine：
<ul>
<li><a href="https://docs.docker.com/machine/overview/" target="_blank" rel="nofollow noopener noreferrer">Docker Machine Overview</a></li>
<li><a href="https://docs.docker.com/machine/get-started/" target="_blank" rel="nofollow noopener noreferrer">Get started with Docker Machine and a local VM</a></li>
<li><a href="https://docs.docker.com/machine/examples/aws/" target="_blank" rel="nofollow noopener noreferrer">Amazon Web Services (AWS) EC2 example</a></li>
<li><a href="https://docs.docker.com/machine/drivers/generic/" target="_blank" rel="nofollow noopener noreferrer">Generic</a></li>
</ul>
</li>
<li>docker swarm：
<ul>
<li><a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="nofollow noopener noreferrer">Swarm mode overview</a></li>
</ul>
</li>
</ul>
<h2 id="112-network" style="position:relative;"><a href="#112-network" aria-label="112 network permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>11.2 Network</h2>
<p>Swarm集群使用的网络不再是简单的bridge类型的driver，而是overlay类型的driver。如果仅只是在单一一台物理机上部署docker container，并能够让他们相互感知并进行通讯的话，只需要使用bridge类型的driver network，而这样的网络类型是不能让两台相互物理隔离的服务器上的container相互通讯的。要做到在swarm集群内各容器相互之间能够进行通讯，则必须使用overlay类型的driver的network。</p>
<ul>
<li>官方tutorial：<a href="https://github.com/docker/labs/blob/master/networking/A3-overlay-networking.md" target="_blank" rel="nofollow noopener noreferrer">Overlay networking and service discovery</a>，使用上看这篇就OK了</li>
<li>官方架构阐释：<a href="https://github.com/docker/labs/blob/master/networking/concepts/06-overlay-networks.md" target="_blank" rel="nofollow noopener noreferrer">Overlay Driver Network Architecture</a>，想要了解原理的话必须深度理解这篇博文</li>
</ul>
<h2 id="113-中文系列博文" style="position:relative;"><a href="#113-%E4%B8%AD%E6%96%87%E7%B3%BB%E5%88%97%E5%8D%9A%E6%96%87" aria-label="113 中文系列博文 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>11.3 中文系列博文</h2>
<p>有作者做了一个系列的博文，虽然细节上来说并不算特别好，但看看还行了：<a href="http://www.spring4all.com/article/1254" target="_blank" rel="nofollow noopener noreferrer">Docker Swarm 系列教程</a>。最主要是三篇：</p>
<ul>
<li><a href="https://www.jianshu.com/p/3251f2991d5c" target="_blank" rel="nofollow noopener noreferrer">Docker Swarm - 单机创建 Swarm 集群</a></li>
<li><a href="https://www.jianshu.com/p/48dd5fff7150" target="_blank" rel="nofollow noopener noreferrer">Docker Swarm - 节点管理</a></li>
<li><a href="https://www.jianshu.com/p/31db684deeba" target="_blank" rel="nofollow noopener noreferrer">MongoDB 集群构建：分片+副本+选举</a></li>
</ul>
<h2 id="114-实际操作经验" style="position:relative;"><a href="#114-%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C%E7%BB%8F%E9%AA%8C" aria-label="114 实际操作经验 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>11.4 实际操作经验</h2>
<p>我这里也做了点实践进行试验：<a href="https://github.com/agreatfool/dist-system-practice/tree/master/experiment/swarm" target="_blank" rel="nofollow noopener noreferrer">dist-system-practice/experiment/swarm/</a>。</p>
<p>下面一步步进行解释。</p>
<h3 id="1141-创建远程docker环境" style="position:relative;"><a href="#1141-%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8Bdocker%E7%8E%AF%E5%A2%83" aria-label="1141 创建远程docker环境 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>11.4.1 创建远程docker环境</h3>
<p><strong>虚拟机</strong></p>
<p>docker-machine可以使用远程物理host进行docker环境部署和操控，也可以在本地进行虚拟机的制作，并进行控制和部署。虚拟机需要单独下载并安装<code class="language-text">virtualbox</code>。</p>
<p>MAC下安装：</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ brew cask <span class="token function">install</span> virtualbox</code></pre></div>
<p>此外需要下载virtualbox的镜像，并放到对应的文件夹下，下载releases：<a href="https://github.com/boot2docker/boot2docker/releases/" target="_blank" rel="nofollow noopener noreferrer">boot2docker/boot2docker</a>。下载完成后放到：<code class="language-text">~/.docker/machine/cache</code>。</p>
<p>虚拟机的创建，driver类型为<code class="language-text">virtualbox</code>：</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ docker-machine create <span class="token parameter variable">-d</span> virtualbox <span class="token parameter variable">--help</span> <span class="token comment"># 帮助选项查看</span>

$ docker-machine create <span class="token parameter variable">-d</span> virtualbox <span class="token punctuation">\</span>
    --virtualbox-boot2docker-url ~/.docker/machine/cache/boot2docker.iso <span class="token punctuation">\</span>
    --virtualbox-hostonly-cidr <span class="token string">"192.168.99.1/24"</span> <span class="token punctuation">\</span>
    --engine-opt <span class="token assign-left variable">dns</span><span class="token operator">=</span><span class="token number">192.168</span>.99.1 <span class="token punctuation">\</span>
    host1
Running pre-create checks<span class="token punctuation">..</span>.
<span class="token punctuation">(</span>host1<span class="token punctuation">)</span> Boot2Docker URL was explicitly <span class="token builtin class-name">set</span> to <span class="token string">"/Users/xxx/.docker/machine/cache/boot2docker.iso"</span> at create time, so Docker Machine cannot upgrade this machine to the latest version.
Creating machine<span class="token punctuation">..</span>.
<span class="token punctuation">(</span>host1<span class="token punctuation">)</span> Boot2Docker URL was explicitly <span class="token builtin class-name">set</span> to <span class="token string">"/Users/xxx/.docker/machine/cache/boot2docker.iso"</span> at create time, so Docker Machine cannot upgrade this machine to the latest version.
<span class="token punctuation">(</span>host1<span class="token punctuation">)</span> Downloading /Users/xxx/.docker/machine/cache/boot2docker.iso from /Users/xxx/.docker/machine/cache/boot2docker.iso<span class="token punctuation">..</span>.
<span class="token punctuation">(</span>host1<span class="token punctuation">)</span> Creating VirtualBox VM<span class="token punctuation">..</span>.
<span class="token punctuation">(</span>host1<span class="token punctuation">)</span> Creating SSH key<span class="token punctuation">..</span>.
<span class="token punctuation">(</span>host1<span class="token punctuation">)</span> Starting the VM<span class="token punctuation">..</span>.
<span class="token punctuation">(</span>host1<span class="token punctuation">)</span> Check network to re-create <span class="token keyword">if</span> needed<span class="token punctuation">..</span>.
<span class="token punctuation">(</span>host1<span class="token punctuation">)</span> Waiting <span class="token keyword">for</span> an IP<span class="token punctuation">..</span>.
Waiting <span class="token keyword">for</span> machine to be running, this may take a few minutes<span class="token punctuation">..</span>.
Detecting operating system of created instance<span class="token punctuation">..</span>.
Waiting <span class="token keyword">for</span> SSH to be available<span class="token punctuation">..</span>.
Detecting the provisioner<span class="token punctuation">..</span>.
Provisioning with boot2docker<span class="token punctuation">..</span>.
Copying certs to the <span class="token builtin class-name">local</span> machine directory<span class="token punctuation">..</span>.
Copying certs to the remote machine<span class="token punctuation">..</span>.
Setting Docker configuration on the remote daemon<span class="token punctuation">..</span>.
Checking connection to Docker<span class="token punctuation">..</span>.
Docker is up and running<span class="token operator">!</span>
To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine <span class="token function">env</span> host1

$ docker-machine <span class="token function">ls</span>
NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORS
host1     -        virtualbox   Running   tcp://192.168.99.100:2376           v18.09.2
host2     -        virtualbox   Running   tcp://192.168.99.101:2376           v18.09.2</code></pre></div>
<p><strong>远程host</strong></p>
<p>远程物理host创建，driver类型为<code class="language-text">generic</code>（文档：<a href="https://docs.docker.com/machine/drivers/generic/" target="_blank" rel="nofollow noopener noreferrer">Generic</a>）。如果要创建某些受官方支持的云服务的远程环境，可以参考：<a href="https://docs.docker.com/machine/drivers/" target="_blank" rel="nofollow noopener noreferrer">Machine drivers</a>。如果创建的只是普通的远程host实例，则选择driver为<code class="language-text">generic</code>即可。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ docker-machine create <span class="token parameter variable">-d</span> generic <span class="token parameter variable">--help</span> <span class="token comment"># 帮助选项查看</span>

$ docker-machine create <span class="token parameter variable">-d</span> generic <span class="token punctuation">\</span>
    --generic-ip-address<span class="token operator">=</span>x.x.x.x <span class="token punctuation">\</span>
    --generic-ssh-port <span class="token number">22</span> <span class="token punctuation">\</span>
    --generic-ssh-key ~/.ssh/id_rsa <span class="token punctuation">\</span>
    --generic-ssh-user root <span class="token punctuation">\</span>
    vultr
Running pre-create checks<span class="token punctuation">..</span>.
Creating machine<span class="token punctuation">..</span>.
<span class="token punctuation">(</span>vultr<span class="token punctuation">)</span> No SSH key specified. Assuming an existing key at the default location.
Waiting <span class="token keyword">for</span> machine to be running, this may take a few minutes<span class="token punctuation">..</span>.
Detecting operating system of created instance<span class="token punctuation">..</span>.
Waiting <span class="token keyword">for</span> SSH to be available<span class="token punctuation">..</span>.
Detecting the provisioner<span class="token punctuation">..</span>.
Provisioning with ubuntu<span class="token punctuation">(</span>systemd<span class="token punctuation">)</span><span class="token punctuation">..</span>.
Installing Docker<span class="token punctuation">..</span>.
Copying certs to the <span class="token builtin class-name">local</span> machine directory<span class="token punctuation">..</span>.
Copying certs to the remote machine<span class="token punctuation">..</span>.
Setting Docker configuration on the remote daemon<span class="token punctuation">..</span>.
Checking connection to Docker<span class="token punctuation">..</span>.
Error creating machine: Error checking the host: Error checking and/or regenerating the certs: There was an error validating certificates <span class="token keyword">for</span> <span class="token function">host</span> <span class="token string">"x.x.x.x:2376"</span><span class="token builtin class-name">:</span> tls: DialWithDialer timed out
You can attempt to regenerate them using <span class="token string">'docker-machine regenerate-certs [name]'</span><span class="token builtin class-name">.</span>
Be advised that this will trigger a Docker daemon restart <span class="token function">which</span> might stop running containers.

$ docker-machine regenerate-certs vultr
Regenerate TLS machine certs?  Warning: this is irreversible. <span class="token punctuation">(</span>y/n<span class="token punctuation">)</span>: y
Regenerating TLS certificates
Waiting <span class="token keyword">for</span> SSH to be available<span class="token punctuation">..</span>.
Detecting the provisioner<span class="token punctuation">..</span>.
Installing Docker<span class="token punctuation">..</span>.
Copying certs to the <span class="token builtin class-name">local</span> machine directory<span class="token punctuation">..</span>.
Copying certs to the remote machine<span class="token punctuation">..</span>.
Setting Docker configuration on the remote daemon<span class="token punctuation">..</span>.

$ docker-machine <span class="token function">ls</span>
NAME      ACTIVE   DRIVER       STATE     URL                       SWARM   DOCKER     ERRORS
vultr     -        generic      Running   tcp://x.x.x.x:2376                v18.09.6</code></pre></div>
<h3 id="1142-抹除远程docker环境" style="position:relative;"><a href="#1142-%E6%8A%B9%E9%99%A4%E8%BF%9C%E7%A8%8Bdocker%E7%8E%AF%E5%A2%83" aria-label="1142 抹除远程docker环境 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>11.4.2 抹除远程docker环境</h3>
<p>其实主要是在本地控制记录中将对象删除：</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ docker-machine <span class="token function">rm</span> vultr
About to remove vultr
WARNING: This action will delete both <span class="token builtin class-name">local</span> reference and remote instance.
Are you sure? <span class="token punctuation">(</span>y/n<span class="token punctuation">)</span>: y
Successfully removed vultr</code></pre></div>
<h3 id="1143-远程命令执行" style="position:relative;"><a href="#1143-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C" aria-label="1143 远程命令执行 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>11.4.3 远程命令执行</h3>
<p>当远程实例创建完成之后，在管理者机器上形成记录，并能够远程进行命令的执行。远程命令执行有两种方法：</p>
<p><strong>ssh</strong></p>
<p>使用<code class="language-text">docker-machine ssh $name "$command"</code>的方式可以执行远程命令，如果使用<code class="language-text">docker-machine ssh $name</code>则可以直接登录到远程机器环境。</p>
<p><strong>env</strong></p>
<p>ssh方法可以做很多事情，但打命令会比较繁琐，毕竟每条命令都需要带上docker-machine前缀。另一种方法则是使用<code class="language-text">eval "$(docker-machine env $name)"</code>命令，来将当前会话窗口的执行环境切换到<code class="language-text">$name</code>机器，即当上述命令执行完毕后，当前会话内的所有命令都是在<code class="language-text">$name</code>机器上执行的，而不是管理者机器。</p>
<p>如果要退出远程机器的会话，则需要执行：<code class="language-text">eval "$(docker-machine env -u)"</code>。</p>
<h3 id="1144-swarm集群管理" style="position:relative;"><a href="#1144-swarm%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86" aria-label="1144 swarm集群管理 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>11.4.4 Swarm集群管理</h3>
<p>Swarm集群由一个Manager节点，多个备用Manager节点，以及大量Worker节点组成。官方文档：<a href="https://docs.docker.com/engine/reference/commandline/swarm/" target="_blank" rel="nofollow noopener noreferrer">docker swarm</a>。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">node</span> <span class="token function">ls</span>
ID                            <span class="token environment constant">HOSTNAME</span>            STATUS              AVAILABILITY        MANAGER STATUS
3fff9l59dvn5jvot2s27gf9n2 *   ManagerX            Ready               Active              Leader
4byjmtcm1ag8qffxjwnhwsf4l     WorkerA             Ready               Active
sks1qb0zqlaetmpsqfj5tfx56     WorkerB             Ready               Active</code></pre></div>
<p>Manager状态正常为<code class="language-text">Leader</code>，备选为<code class="language-text">Reachable</code>。Worker节点正常状态为<code class="language-text">Active</code>。</p>
<p><strong>创建Swarm集群</strong><br>
记住，所有的Swarm集群操作都必须要到远程机器上执行，而不是在管理者机器上执行。也就是说必须使用<code class="language-text">docker-machine ssh ...</code>或<code class="language-text">eval "$(docker-machine env ...)"</code>来操作。</p>
<p>如果要创建一个Swarm集群，需要到被选为Manager的节点上：</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> swarm init --advertise-addr <span class="token number">192.168</span>.99.100
Swarm initialized: current <span class="token function">node</span> <span class="token punctuation">(</span>lvfnka9mz92699ke3j189dznd<span class="token punctuation">)</span> is now a manager.

To <span class="token function">add</span> a worker to this swarm, run the following command:

    <span class="token function">docker</span> swarm <span class="token function">join</span> <span class="token parameter variable">--token</span> SWMTKN-1-4zc49exg8u9vh9nsasua10xzu2a5qaxahmgblxkejltw6v6mt0-aadqrk196sgi97z4nkn6eagjl <span class="token number">192.168</span>.99.100:2377

To <span class="token function">add</span> a manager to this swarm, run <span class="token string">'docker swarm join-token manager'</span> and follow the instructions.</code></pre></div>
<p>后面的IP地址为被选为Manager的机器的自机IP。</p>
<p><strong>添加Worker节点</strong></p>
<p>要向一个只有Manager的Swarm集群添加Worker节点：</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> swarm <span class="token function">join</span> <span class="token parameter variable">--token</span> SWMTKN-1-4zc49exg8u9vh9nsasua10xzu2a5qaxahmgblxkejltw6v6mt0-aadqrk196sgi97z4nkn6eagjl <span class="token number">192.168</span>.99.100:2377
This <span class="token function">node</span> joined a swarm as a worker.</code></pre></div>
<p>这句命令在刚才Manager创建Swarm集群的时候已经被打印出来了，照做即可。不要忘记该命令必须到被要求加入Swarm集群的Worker节点上执行。</p>
<p><strong>离开集群</strong><br>
如果需要将某个节点剔除出集群，则需要到该节点上执行：</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> swarm leave <span class="token parameter variable">--force</span>
Node left the swarm.</code></pre></div>
<p>Manager节点必须要带上<code class="language-text">--force</code>option，Worker节点则不需要。</p>
<h3 id="1145-service" style="position:relative;"><a href="#1145-service" aria-label="1145 service permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>11.4.5 Service</h3>
<p>在Swarm集群中，一个容器被称为<code class="language-text">服务 Service</code>，实际上还是个容器，只不过叫法不一样而已。官方文档：<a href="https://docs.docker.com/engine/reference/commandline/service/" target="_blank" rel="nofollow noopener noreferrer">docker service</a>。</p>
<p><strong>创建服务</strong></p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">service</span> create <span class="token punctuation">\</span>
    <span class="token parameter variable">--name</span> memcached <span class="token punctuation">\</span>
    <span class="token parameter variable">--network</span> dist_net <span class="token punctuation">\</span>
    <span class="token parameter variable">--replicas</span> <span class="token number">1</span> <span class="token punctuation">\</span>
    <span class="token parameter variable">-p</span> <span class="token number">11211</span>:11211 <span class="token punctuation">\</span>
    <span class="token parameter variable">--constraint</span> <span class="token assign-left variable">node.hostname</span><span class="token operator">==</span>host1 <span class="token punctuation">\</span>
    memcached:1.5.14-alpine <span class="token punctuation">\</span>
    <span class="token parameter variable">-l</span> <span class="token number">0.0</span>.0.0 <span class="token punctuation">\</span>
    <span class="token parameter variable">-p</span> <span class="token number">11211</span> <span class="token punctuation">\</span>
    <span class="token parameter variable">-m</span> <span class="token number">64</span>
uezlg3xa9ku412l4la8i8tue7
overall progress: <span class="token number">1</span> out of <span class="token number">1</span> tasks
<span class="token number">1</span>/1: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>
verify: Service converged</code></pre></div>
<p>大部分的option和使用docker run的时候没有差别，这里需要注意的是：</p>
<ul>
<li>replicas：在整个集群中，指定的服务需要启动多少个，如果是类似于web server这样的无状态角色，就很容易理解，一般和<code class="language-text">constraint</code>结合使用，指定部署的节点范围</li>
<li>constraint：限制部署的对象节点，范例中<code class="language-text">node.hostname</code>指定的是被命令的单个节点，该服务只允许部署到这个节点上</li>
</ul>
<p><strong>停止服务</strong></p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">rm</span> memcached
memcached</code></pre></div>
<p><strong>其他命令</strong><br>
其他服务相关命令可以查看：</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token parameter variable">--help</span></code></pre></div>
<h3 id="1146-stack" style="position:relative;"><a href="#1146-stack" aria-label="1146 stack permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>11.4.6 Stack</h3>
<p>类似于docker service就是docker run的Swarm版本，stack可以理解为Swarm版本的compose。一样需要指定一个compose.yaml配置文件，然后开始stack的部署。这里需要注意，一般compose的部分选项在Swarm的stack中是不可用的，当然大部分都是通用的。</p>
<p><strong>启动stack</strong></p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> stack deploy ./cluster.yaml dist
Creating network dist_net
Creating <span class="token function">service</span> dist_memcache_admin
Creating <span class="token function">service</span> dist_memcached</code></pre></div>
<p><strong>停止stack</strong></p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> stack <span class="token function">rm</span> dist
Removing <span class="token function">service</span> dist_memcache_admin
Removing <span class="token function">service</span> dist_memcached
Removing network dist_net</code></pre></div>
<h3 id="1147-状态查看命令" style="position:relative;"><a href="#1147-%E7%8A%B6%E6%80%81%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4" aria-label="1147 状态查看命令 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>11.4.7 状态查看命令</h3>
<p><strong>查看所有远程主机</strong></p>
<p>该命令需要在管理者机器上执行，不是远程主机，注意。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ docker-machine <span class="token function">ls</span>
NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORS
host1     -        virtualbox   Running   tcp://192.168.99.100:2376           v18.09.2
host2     -        virtualbox   Running   tcp://192.168.99.101:2376           v18.09.2</code></pre></div>
<p><strong>查看Swarm集群所有节点</strong></p>
<p>需要到Swarm集群Manager节点上执行命令。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">node</span> <span class="token function">ls</span>
ID                            <span class="token environment constant">HOSTNAME</span>            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
z70e57nrkfpbcs33j5pyzzaqi *   host1               Ready               Active              Leader              <span class="token number">18.09</span>.2
x2f6tereq1btochykl18lrrtv     host2               Ready               Active                                  <span class="token number">18.09</span>.2</code></pre></div>
<p><strong>查看Swarm单个节点细节</strong></p>
<p>需要到对应节点上执行命令。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">node</span> inspect host1 <span class="token parameter variable">--pretty</span>
ID:                 un1mkdvkh814oehap89wna4zw
Hostname:           host1
Joined at:          <span class="token number">2019</span>-06-24 08:04:35.836543206 +0000 utc
Status:
 State:             Ready
 Availability:      Active
 Address:           <span class="token number">192.168</span>.99.116
Manager Status:
 Address:           <span class="token number">192.168</span>.99.116:2377
 Raft Status:       Reachable
 Leader:            Yes
Platform:
 Operating System:  linux
 Architecture:      x86_64
Resources:
 CPUs:              <span class="token number">1</span>
 Memory:            <span class="token number">989</span>.4MiB
Plugins:
 Log:               awslogs, fluentd, gcplogs, gelf, journald, json-file, local, logentries, splunk, syslog
 Network:           bridge, host, macvlan, null, overlay
 Volume:            <span class="token builtin class-name">local</span>
Engine Version:     <span class="token number">18.09</span>.2</code></pre></div>
<p><strong>查看Swarm集群所有服务</strong></p>
<p>需要到Swarm集群Manager节点上执行命令。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ls</span>
ID                  NAME                MODE                REPLICAS            IMAGE                                PORTS
b3ozvdgrgudv        memcache_admin      replicated          <span class="token number">1</span>/1                 plopix/docker-memcacheadmin:latest   *:9083-<span class="token operator">></span><span class="token number">9083</span>/tcp
yujhl39733lg        memcached           replicated          <span class="token number">1</span>/1                 memcached:1.5.14-alpine              *:11211-<span class="token operator">></span><span class="token number">11211</span>/tcp</code></pre></div>
<p><strong>查看Swarm集群单个服务</strong></p>
<p>需要到Swarm集群Manager节点上执行命令。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> memcached
ID                  NAME                IMAGE                     NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS
oe41a6ioom9r        memcached.1         memcached:1.5.14-alpine   host1               Running             Running about a minute ago

$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> memcache_admin
ID                  NAME                IMAGE                                NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS
w9y6zhukra0w        memcache_admin.1    plopix/docker-memcacheadmin:latest   host2               Running             </code></pre></div>
<p><strong>查看Swarm集群Stack细节</strong></p>
<p>需要到Swarm集群Manager节点上执行命令。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> stack <span class="token function">ps</span> dist
ID                  NAME                    IMAGE                                NODE                DESIRED STATE       CURRENT STATE            ERROR                        PORTS
kscj4niatj9n        dist_memcached.1        memcached:1.5.14-alpine              host1               Running             Running <span class="token number">1</span> second ago
4hcwv6ni3elv        dist_memcache_admin.1   plopix/docker-memcacheadmin:latest   host2               Running             Running <span class="token number">31</span> seconds ago</code></pre></div>
<p><strong>查看Swarm单个服务的日志</strong></p>
<p>需要到Swarm集群Manager节点上执行命令。服务日志其实就是容器日志。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">service</span> logs <span class="token variable">$name</span></code></pre></div>
<h2 id="115-issues" style="position:relative;"><a href="#115-issues" aria-label="115 issues permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>11.5 Issues</h2>
<p>从compose.yaml进行docker stack deploy出来的服务总是会遇到：<code class="language-text">getaddrinfo(): name does not resolve</code>，启动的服务无法解析域名，一直都没有查到问题。</p>
<p>一开始以为是dns问题：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/34296230/how-to-change-default-docker-machines-dns-settings" target="_blank" rel="nofollow noopener noreferrer">How to change “default” docker-machine’s dns settings</a></li>
<li><a href="https://github.com/moby/moby/issues/34259" target="_blank" rel="nofollow noopener noreferrer">docker stack deploy completely ignores dns settings #34259</a></li>
</ul>
<p>然后根据stackoverflow的讨论进行machine create的options设定，发现<code class="language-text">--engine-opt dns=8.8.8.8</code>会被docker-machine create忽略：</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">cat ~/.docker/machine/machines/cache/config.json
    "HostOptions": {
        "Driver": "",
        "Memory": 0,
        "Disk": 0,
        "EngineOptions": {
            "ArbitraryFlags": [
                "dns=192.168.99.1"
            ],
            "Dns": null,
            ...</code></pre></div>
<p>Dns选项为null，而要求的内容则出现在了EngineOptions > ArbitraryFlags里。</p>
<p>最后抛开DNS不管，直接不使用compose配置文件，也不使用docker stack deploy命令，直接使用docker service create命令，和compose配置文件中一模一样的option却发现启动成功。估计是stack命令内部实现有点问题。</p>
<p>Swarm因为与K8S竞争失败，最近已经很久听不到消息了，官方的资料以及社区的讨论都是非常老的资料，有问题什么都查不到。此外，很简单的一个容器服务，在Swarm集群中以Service启动非常非常慢，好几十秒才把很简单的一个memcached启动起来。实际使用如果也是这种性能的话是完全不能接受的。</p>
<p>总之，Swarm的现状来看，完全不适合使用在生产环境。应用风险非常之高。</p>
<h1 id="12-其他" style="position:relative;"><a href="#12-%E5%85%B6%E4%BB%96" aria-label="12 其他 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>12. 其他</h1>
<h2 id="121-什么是docker-host" style="position:relative;"><a href="#121-%E4%BB%80%E4%B9%88%E6%98%AFdocker-host" aria-label="121 什么是docker host permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>12.1 什么是docker host</h2>
<p>在很多docker的文档里都提到了<code class="language-text">docker host</code>这个概念。至于什么是docker host，可以参见链接：<a href="https://forums.docker.com/t/clarify-what-is-the-host/29640/2" target="_blank" rel="nofollow noopener noreferrer">Clarify what is the host</a>。</p>
<blockquote>
<p>I think you pretty much found out the answer by yourself. In that diagram you mention a ‘docker host’ is any machine that is running the Docker daemon. This means that you’re either running Docker natively in your operating system, or a virtual machine that has Docker installed.</p>
<p>Docker machine is basically the second option. When you do a docker-machine create it creates a new virtual machine with Docker already installed. This means that to access any containers running on this machine you’ll have to use the IP address of the virtual machine. Also, to give Docker access to a file you’ll either have to copy it to the VM that’s running Docker, or share a directory between your OS and the VM that’s running Docker.</p>
</blockquote>
<h2 id="122-comdockerhyperkit-x00-cpu-consumption-mac" style="position:relative;"><a href="#122-comdockerhyperkit-x00-cpu-consumption-mac" aria-label="122 comdockerhyperkit x00 cpu consumption mac permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>12.2 com.docker.hyperkit X00% cpu consumption MAC</h2>
<p>在MAC上使用docker，如果放一些有真实负载的container，一般都会遇到这个问题（甚至是没什么负载，只是搭建环境都会）。</p>
<p>官方论坛有一个issue：<a href="https://github.com/docker/for-mac/issues/1759#issuecomment-481742599" target="_blank" rel="nofollow noopener noreferrer">High CPU Utilization of Hyperkit in Mac #1759</a>，到现在还是<code class="language-text">open状态</code>，且看起来解决遥遥无期。</p>
<p>issue中似乎有用的只有改大max open file选项这条意见，具体操作可以参见：<a href="https://wilsonmar.github.io/maximum-limits/" target="_blank" rel="nofollow noopener noreferrer">Maximum limits (macOS etc.)</a>。</p>
<p>不确定是否一定能起效果，应该是对部分情况有效的。但对我来说貌似是没用，我的ulimit已经是：</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ launchctl limit maxfiles
<span class="token comment"># maxfiles    65536          65536</span></code></pre></div>
<h1 id="资料" style="position:relative;"><a href="#%E8%B5%84%E6%96%99" aria-label="资料 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>资料</h1>
<h2 id="docker官方" style="position:relative;"><a href="#docker%E5%AE%98%E6%96%B9" aria-label="docker官方 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Docker官方</h2>
<ul>
<li><a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank" rel="nofollow noopener noreferrer">Docker Desktop for Mac</a></li>
<li><a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="nofollow noopener noreferrer">Get started with Docker Desktop for Mac</a></li>
<li><a href="https://hub.docker.com" target="_blank" rel="nofollow noopener noreferrer">docker hub</a></li>
<li><a href="https://docs.docker.com/registry/" target="_blank" rel="nofollow noopener noreferrer">Docker Registry</a></li>
<li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="nofollow noopener noreferrer">Best practices for writing Dockerfiles</a></li>
</ul>
<h2 id="docker命令" style="position:relative;"><a href="#docker%E5%91%BD%E4%BB%A4" aria-label="docker命令 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Docker命令</h2>
<ul>
<li><a href="https://www.jianshu.com/p/ea4a00c6c21c" target="_blank" rel="nofollow noopener noreferrer">Docker run 命令参数及使用</a></li>
<li><a href="https://www.centos.bz/2017/01/docker-run-uts-ipc/" target="_blank" rel="nofollow noopener noreferrer">Docker run参考(5) – UTS(–uts)和IPC (–ipc)设置</a></li>
<li><a href="https://stackoverflow.com/a/19689048" target="_blank" rel="nofollow noopener noreferrer">How do you attach and detach from Docker’s process?</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30555962" target="_blank" rel="nofollow noopener noreferrer">Dockerfile: ENTRYPOINT和CMD的区别</a></li>
<li><a href="https://medium.freecodecamp.org/docker-entrypoint-cmd-dockerfile-best-practices-abc591c30e21" target="_blank" rel="nofollow noopener noreferrer">Docker ENTRYPOINT &#x26; CMD: Dockerfile best practices</a></li>
<li><a href="https://howchoo.com/g/zwjhogrkywe/how-to-add-a-health-check-to-your-docker-container" target="_blank" rel="nofollow noopener noreferrer">How to add a health check to your Docker container</a></li>
<li><a href="https://medium.freecodecamp.org/expose-vs-publish-docker-port-commands-explained-simply-434593dbc9a3" target="_blank" rel="nofollow noopener noreferrer">Expose vs publish: Docker port commands explained simply</a></li>
</ul>
<h2 id="镜像相关" style="position:relative;"><a href="#%E9%95%9C%E5%83%8F%E7%9B%B8%E5%85%B3" aria-label="镜像相关 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>镜像相关</h2>
<ul>
<li><a href="https://github.com/gliderlabs/docker-alpine" target="_blank" rel="nofollow noopener noreferrer">gliderlabs/docker-alpine</a></li>
<li><a href="https://hub.docker.com/_/alpine" target="_blank" rel="nofollow noopener noreferrer">docker hub > alpine</a></li>
<li><a href="https://github.com/gliderlabs/docker-alpine#why" target="_blank" rel="nofollow noopener noreferrer">gliderlabs/docker-alpine#Why?</a></li>
<li><a href="https://wiki.alpinelinux.org/wiki/Comparison_with_other_distros" target="_blank" rel="nofollow noopener noreferrer">Comparison with other distros</a></li>
<li><a href="https://nickjanetakis.com/blog/benchmarking-debian-vs-alpine-as-a-base-docker-image" target="_blank" rel="nofollow noopener noreferrer">Benchmarking Debian vs Alpine as a Base Docker Image</a></li>
<li><a href="https://thenewstack.io/alpine-linux-heart-docker/" target="_blank" rel="nofollow noopener noreferrer">Meet Alpine Linux, Docker’s Distribution of Choice for Containers</a></li>
<li><a href="https://github.com/gliderlabs/docker-alpine/issues/255" target="_blank" rel="nofollow noopener noreferrer">DNS Issue #255</a></li>
<li><a href="https://github.com/gliderlabs/docker-alpine/blob/master/docs/caveats.md#dns" target="_blank" rel="nofollow noopener noreferrer">caveats.md >> DNS</a></li>
<li><a href="https://cameronlonsdale.com/2018/11/26/whats-in-a-docker-image/" target="_blank" rel="nofollow noopener noreferrer">What’s in a Docker image?</a>。</li>
<li><a href="https://stackoverflow.com/questions/31222377/what-are-docker-image-layers" target="_blank" rel="nofollow noopener noreferrer">What are Docker image “layers”?</a></li>
<li><a href="https://forums.docker.com/t/do-number-of-layers-in-an-image-affect-the-runtime-performance/43119" target="_blank" rel="nofollow noopener noreferrer">Do number of layers (in an image) affect the runtime performance?</a></li>
<li><a href="https://medium.com/@jessgreb01/digging-into-docker-layers-c22f948ed612" target="_blank" rel="nofollow noopener noreferrer">Digging into Docker layers</a></li>
</ul>
<h2 id="其他" style="position:relative;"><a href="#%E5%85%B6%E4%BB%96" aria-label="其他 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>其他</h2>
<ul>
<li><a href="https://forums.docker.com/t/clarify-what-is-the-host/29640/2" target="_blank" rel="nofollow noopener noreferrer">Clarify what is the host</a></li>
<li><a href="https://github.com/grpc/grpc-node/issues/604" target="_blank" rel="nofollow noopener noreferrer">grpc/grpc-node#604</a></li>
<li><a href="https://juejin.im/entry/5b3df2b4f265da0f6e5156de" target="_blank" rel="nofollow noopener noreferrer">docker-machine</a></li>
<li><a href="http://dockone.io/article/1261" target="_blank" rel="nofollow noopener noreferrer">Docker网络模式</a></li>
<li><a href="https://coolshell.cn/articles/17061.html" target="_blank" rel="nofollow noopener noreferrer">DOCKER基础技术：AUFS</a></li>
<li><a href="https://coolshell.cn/articles/17200.html" target="_blank" rel="nofollow noopener noreferrer">DOCKER基础技术：DEVICEMAPPER</a></li>
<li><a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="nofollow noopener noreferrer">DOCKER基础技术：LINUX NAMESPACE（上）</a></li>
<li><a href="https://coolshell.cn/articles/17029.html" target="_blank" rel="nofollow noopener noreferrer">DOCKER基础技术：LINUX NAMESPACE（下）</a></li>
<li><a href="https://coolshell.cn/articles/17049.html" target="_blank" rel="nofollow noopener noreferrer">DOCKER基础技术：LINUX CGROUP</a></li>
<li><a href="https://rk700.github.io/2016/10/26/linux-capabilities/" target="_blank" rel="nofollow noopener noreferrer">Linux的capabilities机制</a></li>
<li><a href="http://cizixs.com/2017/08/25/linux-cgroup/" target="_blank" rel="nofollow noopener noreferrer">docker 容器基础技术：linux cgroup 简介</a></li>
<li><a href="https://infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank" rel="nofollow noopener noreferrer">Docker 背后的内核知识——cgroups 资源限制</a></li>
<li><a href="https://medium.com/@asishrs/docker-limit-resource-utilization-using-cgroup-parent-72a646651f9d" target="_blank" rel="nofollow noopener noreferrer">Docker limit resource utilization using cgroup-parent</a></li>
<li><a href="https://medium.com/@kasunmaduraeng/docker-namespace-and-cgroups-dece27c209c7" target="_blank" rel="nofollow noopener noreferrer">Docker Namespace and Cgroups</a></li>
<li><a href="https://my.oschina.net/HardySimpson/blog/868186" target="_blank" rel="nofollow noopener noreferrer">cgroup, docker,和kubernetes</a></li>
<li><a href="https://www.cnblogs.com/sammyliu/p/5886833.html" target="_blank" rel="nofollow noopener noreferrer">理解Docker（4）：Docker 容器使用 cgroups 限制资源使用</a></li>
<li><a href="https://www.ctl.io/developers/blog/post/gracefully-stopping-docker-containers/" target="_blank" rel="nofollow noopener noreferrer">Gracefully Stopping Docker Containers</a></li>
<li><a href="https://coolshell.cn/articles/18654.html" target="_blank" rel="nofollow noopener noreferrer">记一次KUBERNETES/DOCKER网络排障</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31820191" target="_blank" rel="nofollow noopener noreferrer">Docker 空间使用分析与清理</a></li>
<li><a href="https://www.cnblogs.com/sparkdev/p/7821376.html" target="_blank" rel="nofollow noopener noreferrer">查看 docker 容器使用的资源</a></li>
</ul>
<h2 id="docker-info-id_app_docker_info" style="position:relative;"><a href="#docker-info-id_app_docker_info" aria-label="docker info id_app_docker_info permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>docker info {#ID_APP_DOCKER_INFO}</h2>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 1
Server Version: 18.09.2
Storage Driver: overlay2
 Backing Filesystem: extfs
 Supports d_type: true
 Native Overlay Diff: true
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: bridge host macvlan null overlay
 Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Init Binary: docker-init
containerd version: 9754871865f7fe2f4e74d43e2fc7ccd237edcbce
runc version: 09c8266bf2fcf9519a651b04ae54c967b9ab86ec
init version: fec3683
Security Options:
 seccomp
  Profile: default
Kernel Version: 4.9.125-linuxkit
Operating System: Docker for Mac
OSType: linux
Architecture: x86_64
CPUs: 4
Total Memory: 1.952GiB
Name: linuxkit-025000000001
ID: CNVU:5KZS:A2M7:WY5W:NUEW:KPW3:WXOA:IH2Q:EBAN:LP7C:3EQR:36U4
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): true
 File Descriptors: 24
 Goroutines: 50
 System Time: 2019-03-27T06:19:11.1044801Z
 EventsListeners: 2
HTTP Proxy: gateway.docker.internal:3128
HTTPS Proxy: gateway.docker.internal:3129
Registry: https://index.docker.io/v1/
Labels:
Experimental: false
Insecure Registries:
 127.0.0.0/8
Live Restore Enabled: false
Product License: Community Engine</code></pre></div>
<blockquote>
<p>EOF</p>
</blockquote></div></div></div><div class="Post-module--footer--NpFTW"><div class="Meta-module--meta--3YYBJ"><p class="Meta-module--date--U0EV3">Published<!-- --> <!-- -->2019/1/17</p></div><div class="Tags-module--tags--1r6Jk"><ul class="Tags-module--list--3a6Ka"><li class="Tags-module--item--2JSXQ"><a class="Tags-module--link--hkiai" href="/tag/docker/">Docker</a></li><li class="Tags-module--item--2JSXQ"><a class="Tags-module--link--hkiai" href="/tag/keynote/">Keynote</a></li></ul></div><div class="Author-module--author--2kT-Q"><p class="Author-module--bio--2YX8-">Some tech &amp; personal blog posts<a class="Author-module--twitter--1B6I5" href="https://github.com/agreatfool" rel="noopener noreferrer" target="_blank"><strong>Jonathan Dai</strong> on Github</a></p></div></div><div class="Post-module--comments--2bE-0"><div id="disqus_thread"></div></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/posts/2019/01/docker-note";window.___webpackCompilationHash="371f6387a60c9395e7f3";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-c743c10e2eb6467040f1.js"],"app":["/app-591a9ca27468496ecc74.js"],"component---cache-caches-gatsby-plugin-offline-app-shell-js":["/component---cache-caches-gatsby-plugin-offline-app-shell-js-0c915c7b1bdb5eac4fdf.js"],"component---src-templates-categories-template-categories-template-tsx":["/component---src-templates-categories-template-categories-template-tsx-5cf1ee016fbabd4cc244.js"],"component---src-templates-category-template-category-template-tsx":["/component---src-templates-category-template-category-template-tsx-b229c8135c3921c8d3f6.js"],"component---src-templates-index-template-index-template-tsx":["/component---src-templates-index-template-index-template-tsx-ae0b72bf804b6a6d8f8b.js"],"component---src-templates-not-found-template-not-found-template-tsx":["/component---src-templates-not-found-template-not-found-template-tsx-34764a7195a0a3d20525.js"],"component---src-templates-page-template-page-template-tsx":["/component---src-templates-page-template-page-template-tsx-8d9df3d13cb146b2b124.js"],"component---src-templates-post-template-post-template-tsx":["/component---src-templates-post-template-post-template-tsx-55cf601722552b1f230a.js"],"component---src-templates-tag-template-tag-template-tsx":["/component---src-templates-tag-template-tag-template-tsx-dd56e504ecc95c1d80fe.js"],"component---src-templates-tags-template-tags-template-tsx":["/component---src-templates-tags-template-tags-template-tsx-285b7a03795d0591a93e.js"]};/*]]>*/</script><script src="/polyfill-c743c10e2eb6467040f1.js" nomodule=""></script><script src="/app-591a9ca27468496ecc74.js" async=""></script><script src="/framework-c14ed818a88fa3beed0f.js" async=""></script><script src="/webpack-runtime-62a0cf7d177c0bdb700e.js" async=""></script></body></html>